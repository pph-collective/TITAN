{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview TITAN (Treatment of Infectious Transmissions through Agent-based Network) is an agent-based simulation model used to explore contact transmission in complex social networks. Starting with the initializing agent population, TITAN iterates over a series of stochastic interactions where agents can interact with one another, transmit infections through various medium, and enter and exit the care continuum. The purpose of TITAN is to evaluate the impact of prevention and treatment models on incidence and prevalence rates of the targeted disease(s) through the use of data fitting simulated trajectories and rich statistics of primary/sub-population attributable proportions. Agent populations are defined as graphs (nodes connected by edges). Nodes in the graph are used to represent the attributes (or collection of attributes) of an agent (person), and edges define the type of relationship between agents. In practice, a graph represents a social network of connected people through various relationship types, and provides the medium for which agents can interact. Visualizing the TITAN network during a model run. Hover over an agent's dot to highlight their relationships to other agents. See the Visualizing TITAN Observable notebook to learn more.","title":"Overview"},{"location":"#overview","text":"TITAN (Treatment of Infectious Transmissions through Agent-based Network) is an agent-based simulation model used to explore contact transmission in complex social networks. Starting with the initializing agent population, TITAN iterates over a series of stochastic interactions where agents can interact with one another, transmit infections through various medium, and enter and exit the care continuum. The purpose of TITAN is to evaluate the impact of prevention and treatment models on incidence and prevalence rates of the targeted disease(s) through the use of data fitting simulated trajectories and rich statistics of primary/sub-population attributable proportions. Agent populations are defined as graphs (nodes connected by edges). Nodes in the graph are used to represent the attributes (or collection of attributes) of an agent (person), and edges define the type of relationship between agents. In practice, a graph represents a social network of connected people through various relationship types, and provides the medium for which agents can interact. Visualizing the TITAN network during a model run. Hover over an agent's dot to highlight their relationships to other agents. See the Visualizing TITAN Observable notebook to learn more.","title":"Overview"},{"location":"contributing/","text":"We welcome issues and pull requests to help improve the TITAN model. We use the following guidelines to ensure standards are met. GitHub Workflow When working on TITAN, make a branch from develop to make changes in, then make a pull request to develop when ready for review. Branches develop is the primary working branch for the project main is the branch releases are made off of and is in stable condition at all times topic branches are created for new features, fixes, or really any changes Commitizen All commits should use the angular style. Commitizen makes this easy. pip install --user commitizen Then use cz commit where you would have previously done git commit . Code Standards Testing We strive to have test coverage for all of the features of TITAN. When adding a new feature or fixing a bug, add tests for the new feature or that test the bug condition to make sure that the bug doesn't crop up agin. pytest is the library used for testing. To run all of the tests: python -m pytest To run only the unit tests: python -m pytest -m unit Code Style black The code must conform to black 's standards and this is automatically checked via github actions. To automatically fix files, run black . from the root of the TITAN directory. flake8 The code must not have any egregious linting errors. And others should be minimized as reasonable. Check for egregious errors: flake8 titan -- count -- select = E9 , F63 , F7 , F82 -- show - source -- statistics Check for all warnings: flake8 titan -- count -- exit - zero -- max - complexity = 12 -- max - line - length = 88 -- statistics Typing Please use type hints on all signatures where reasonable. This will make sure the code is more readable, can be statically tested for type soundness, and helps fill in the documentation. Run the below to check for type errors: mypy titan Documentation All functions and methods should have an up to date google style docstring . These docstrings are used to build TITAN's documentation website. Additional prose can be added to the website by editing the appropriate markdown file in the docs/ directory. To develop/see the docs locally, run: mkdocs serve then navigate to http://localhost:8000 to see your docs. They will automoatically reload as you make changes to files.","title":"Contributing"},{"location":"contributing/#github-workflow","text":"When working on TITAN, make a branch from develop to make changes in, then make a pull request to develop when ready for review.","title":"GitHub Workflow"},{"location":"contributing/#branches","text":"develop is the primary working branch for the project main is the branch releases are made off of and is in stable condition at all times topic branches are created for new features, fixes, or really any changes","title":"Branches"},{"location":"contributing/#commitizen","text":"All commits should use the angular style. Commitizen makes this easy. pip install --user commitizen Then use cz commit where you would have previously done git commit .","title":"Commitizen"},{"location":"contributing/#code-standards","text":"","title":"Code Standards"},{"location":"contributing/#testing","text":"We strive to have test coverage for all of the features of TITAN. When adding a new feature or fixing a bug, add tests for the new feature or that test the bug condition to make sure that the bug doesn't crop up agin. pytest is the library used for testing. To run all of the tests: python -m pytest To run only the unit tests: python -m pytest -m unit","title":"Testing"},{"location":"contributing/#code-style","text":"","title":"Code Style"},{"location":"contributing/#black","text":"The code must conform to black 's standards and this is automatically checked via github actions. To automatically fix files, run black . from the root of the TITAN directory.","title":"black"},{"location":"contributing/#flake8","text":"The code must not have any egregious linting errors. And others should be minimized as reasonable. Check for egregious errors: flake8 titan -- count -- select = E9 , F63 , F7 , F82 -- show - source -- statistics Check for all warnings: flake8 titan -- count -- exit - zero -- max - complexity = 12 -- max - line - length = 88 -- statistics","title":"flake8"},{"location":"contributing/#typing","text":"Please use type hints on all signatures where reasonable. This will make sure the code is more readable, can be statically tested for type soundness, and helps fill in the documentation. Run the below to check for type errors: mypy titan","title":"Typing"},{"location":"contributing/#documentation","text":"All functions and methods should have an up to date google style docstring . These docstrings are used to build TITAN's documentation website. Additional prose can be added to the website by editing the appropriate markdown file in the docs/ directory. To develop/see the docs locally, run: mkdocs serve then navigate to http://localhost:8000 to see your docs. They will automoatically reload as you make changes to files.","title":"Documentation"},{"location":"getting_started/","text":"Getting Started To get started, install titan using a local python (version 3.6 or later) install or virtual env using pip . Once installed, the model can be run using the run_titan program and configured using param files. pip install titan-model run_titan -p my_params.yml run_titan -h Tip Running a large job locally? Look into using pypy instead of python for MOAR performance. This is what we use on OSCAR. Otherwise, all of the instructions hold, just using pypy and pypy's pip. Development Setup Planning to help work on the titan codebase? Here are the tools and processes you need to know about: Git/Github We use git for version control and GitHub for our remote repository. To get started, clone the repository to your local machine. git clone https://github.com/pph-collective/TITAN.git We use angular commits to standardize our commits and encourage better messages. Commitizen makes this easy. Once installed (would recommend doing this globally as opposed to just for this project), run cz commit instead of git commit . Poetry Poetry is a python packaging and dependency management tool. We use this to install/add/remove dependencies, build our package, and publish it to pypy. Install poetry per the install instructions , then complete the below steps. poetry install -E linting -E docs The -E flags tell poetry that we want the optional dependencies that we use for linting (mypy, black, flake8) and for building documentation. We recommend using a recent python version for development (check out pyenv for a way to manage different python versions). You may need to tell poetry which installation of python to use - see their instructions . Poetry installs all of the dependencies into a virtual environment so that they are isolated from other projects you are working on. To run any shell commands in the environment, prefix them with poetry run (e.g. poetry run run_titan -p my_params.yml or poetry run pytest ) or start a poetry shell with poetry shell . black Black formats our files nicely. Our files must be formatted nicely to be merged back into the titan repo. poetry run black . flake8 Flake8 checks for common linting mistake (e.g. unused imports or variables). We have some checks that are required to be fixed and some that are optional. # stop the build if there are Python syntax errors or undefined names poetry run flake8 titan -- count -- select = E9 , F63 , F7 , F82 -- show - source -- statistics # exit - zero treats all errors as warnings . The GitHub editor is 127 chars wide poetry run flake8 titan -- count -- exit - zero -- max - complexity = 12 -- max - line - length = 88 -- statistics mypy Mypy is a static type checker. It will check the typing annotations and our code to make sure everything makes sense (e.g. we don't pass a string to a function that requires a number). poetry run mypy titan pytest Pytest is our test runner. It runs all of our unit and integration tests and reports back any errors or failures. These should almost always pass (the almost refers to our stochastic integration tests which have some element of randomness in their success). poetry run pytest # runs all tests poetry run pytest -m unit # only unit tests poetry run pytest -m integration_deterministic # only deterministic integration tests poetry run pytest -m integration_stochastic # only stochastic integration tests pypy pypy is a JIT compiled version of python which generally makes code faster. It is important that titan remain installable/usable with pypy and we test for this with GitHub actions. However, pypy doesn't play well with some of our linting tools, so we don't typically use it for development.","title":"Installation"},{"location":"getting_started/#getting-started","text":"To get started, install titan using a local python (version 3.6 or later) install or virtual env using pip . Once installed, the model can be run using the run_titan program and configured using param files. pip install titan-model run_titan -p my_params.yml run_titan -h Tip Running a large job locally? Look into using pypy instead of python for MOAR performance. This is what we use on OSCAR. Otherwise, all of the instructions hold, just using pypy and pypy's pip.","title":"Getting Started"},{"location":"getting_started/#development-setup","text":"Planning to help work on the titan codebase? Here are the tools and processes you need to know about:","title":"Development Setup"},{"location":"getting_started/#gitgithub","text":"We use git for version control and GitHub for our remote repository. To get started, clone the repository to your local machine. git clone https://github.com/pph-collective/TITAN.git We use angular commits to standardize our commits and encourage better messages. Commitizen makes this easy. Once installed (would recommend doing this globally as opposed to just for this project), run cz commit instead of git commit .","title":"Git/Github"},{"location":"getting_started/#poetry","text":"Poetry is a python packaging and dependency management tool. We use this to install/add/remove dependencies, build our package, and publish it to pypy. Install poetry per the install instructions , then complete the below steps. poetry install -E linting -E docs The -E flags tell poetry that we want the optional dependencies that we use for linting (mypy, black, flake8) and for building documentation. We recommend using a recent python version for development (check out pyenv for a way to manage different python versions). You may need to tell poetry which installation of python to use - see their instructions . Poetry installs all of the dependencies into a virtual environment so that they are isolated from other projects you are working on. To run any shell commands in the environment, prefix them with poetry run (e.g. poetry run run_titan -p my_params.yml or poetry run pytest ) or start a poetry shell with poetry shell .","title":"Poetry"},{"location":"getting_started/#black","text":"Black formats our files nicely. Our files must be formatted nicely to be merged back into the titan repo. poetry run black .","title":"black"},{"location":"getting_started/#flake8","text":"Flake8 checks for common linting mistake (e.g. unused imports or variables). We have some checks that are required to be fixed and some that are optional. # stop the build if there are Python syntax errors or undefined names poetry run flake8 titan -- count -- select = E9 , F63 , F7 , F82 -- show - source -- statistics # exit - zero treats all errors as warnings . The GitHub editor is 127 chars wide poetry run flake8 titan -- count -- exit - zero -- max - complexity = 12 -- max - line - length = 88 -- statistics","title":"flake8"},{"location":"getting_started/#mypy","text":"Mypy is a static type checker. It will check the typing annotations and our code to make sure everything makes sense (e.g. we don't pass a string to a function that requires a number). poetry run mypy titan","title":"mypy"},{"location":"getting_started/#pytest","text":"Pytest is our test runner. It runs all of our unit and integration tests and reports back any errors or failures. These should almost always pass (the almost refers to our stochastic integration tests which have some element of randomness in their success). poetry run pytest # runs all tests poetry run pytest -m unit # only unit tests poetry run pytest -m integration_deterministic # only deterministic integration tests poetry run pytest -m integration_stochastic # only stochastic integration tests","title":"pytest"},{"location":"getting_started/#pypy","text":"pypy is a JIT compiled version of python which generally makes code faster. It is important that titan remain installable/usable with pypy and we test for this with GitHub actions. However, pypy doesn't play well with some of our linting tools, so we don't typically use it for development.","title":"pypy"},{"location":"run_local/","text":"Running the Model The model has a wrapper script called run_titan.py that makes running a full simulation easy. TITAN can also be run from an interactive repl or a custom script. run_titan.py To run the model, execute the run_titan.py program within the /titan/ directory. See TITAN params for documentation on how to set and use parameters. Results of the model are generated and aggregated into the /results/ directory by default. If the model is re-run, the existing results will be overwritten. Usage Below are the results of python run_titan.py --help . It highlights all of the command line arguments that can be passed to the script. usage : run_titan . py [ -h ] [ -n [NMC ] ] [ -S SETTING ] - p PARAMS [ -o OUTDIR ] [ -b BASE ] [ -e ] [ --savepop ] [ --poppath POPPATH ] [ -w SWEEP [SWEEP ... ] ] [ -W SWEEPFILE ] [ -r ROWS ] [ -F ] Run TITAN model optional arguments : - h , -- help show this help message and exit - n [ NMC ] , -- nMC [ NMC ] number of monte carlo runs to complete - S SETTING , -- setting SETTING setting directory to use - p PARAMS , -- params PARAMS directory or file with params yaml ( s ) - o OUTDIR , -- outdir OUTDIR directory name to save results to - b BASE , -- base BASE whether to use base setting - e , -- error Error on unused parameters instead of warning -- savepop Save population after creation , but before model run . -- poppath POPPATH Path to saved population ( directory or . tar . gz file ) - w SWEEP [ SWEEP ... ] , -- sweep SWEEP [ SWEEP ... ] Optional and repeatable definitions of numeric params to sweep . Expected format is param : start : stop [ :step ] - W SWEEPFILE , -- sweepfile SWEEPFILE Optional . CSV file with param sweep definitions . Header row must contain param paths , with data rows containing values . If this is passed , any ` - w ` args will be ignored . - r ROWS , -- rows ROWS Optional . Which data rows of sweepfile to use in format start : stop . - F , --force Run model even if number of sweeps exceeds 100 titan . run_titan . main ( setting , params_path , num_reps , outdir , sweeps , force , sweepfile = None , rows = None , error_on_unused = False , save_pop = False , pop_path = None ) Run TITAN! Parameters: Name Type Description Default setting str setting name to use, matches a folder name in settings/ required params_path str path to params file or directory required num_reps int number of time to repeat each sweep required outdir str directory where results are to be saved required sweeps List[str] array of strings in param:start:stop:step format required force bool if true, will run even if combination of sweeps results in greater than 100 runs required sweepfile Optional[str] path to csv file of sweep definitions None rows Optional[str] which rows of the csv to load to create sweeps in start:stop format None error_on_unused bool error if there are parameters that are unused by the model False save_pop bool if true, will save the population to file after creation False pop_path Optional[str] path to a population to load instead of creating a new population for each run None Source code in titan/run_titan.py def main ( setting : str , params_path : str , num_reps : int , outdir : str , sweeps : List [ str ], force : bool , sweepfile : Optional [ str ] = None , rows : Optional [ str ] = None , error_on_unused : bool = False , save_pop : bool = False , pop_path : Optional [ str ] = None , ): \"\"\" Run TITAN! args: setting: setting name to use, matches a folder name in `settings/` params_path: path to params file or directory num_reps: number of time to repeat each sweep outdir: directory where results are to be saved sweeps: array of strings in param:start:stop:step format force: if true, will run even if combination of sweeps results in greater than 100 runs sweepfile: path to csv file of sweep definitions rows: which rows of the csv to load to create sweeps in start:stop format error_on_unused: error if there are parameters that are unused by the model save_pop: if true, will save the population to file after creation pop_path: path to a population to load instead of creating a new population for each run \"\"\" outfile_dir = setup_outdir ( outdir , save_pop ) # generate params - if no setting, set to none setting = setting . lower () setting_parsed = None if setting == \"custom\" else setting params = create_params ( setting_parsed , params_path , outfile_dir , error_on_unused = error_on_unused , ) # set up sweeps sweep_defs = get_sweep_defs ( sweepfile , rows , sweeps , num_reps , force ) tic = time_mod . time () wct = [] # wall clock times with Pool ( processes = NCORES , maxtasksperchild = 1 ) as pool : # set max tasks/child to prevent processor drift results = [ pool . apply_async ( single_run , ( sweep_def , outfile_dir , params , save_pop , pop_path ) ) for sweep_def in sweep_defs ] while True : if all ([ r . ready () for r in results ]): break else : time_mod . sleep ( 1 ) for r in results : try : t = r . get () wct . append ( t ) except Exception : traceback . print_exc () toc = time_mod . time () - tic consolidate_files ( outfile_dir ) for task , time_t in enumerate ( wct ): print (( \"wall clock time on for simulation %d : %8.4f seconds\" % ( task , time_t ))) def mean ( seq ): return sum ( seq ) / len ( seq ) print (( \" \\n SUMMARY: \\n all tasks - mean: %8.4f seconds\" % mean ( wct ))) print (( \"all tasks - min: %8.4f seconds\" % min ( wct ))) print (( \"all tasks - max: %8.4f seconds\" % max ( wct ))) print (( \"all tasks - sum: %8.4f seconds\" % sum ( wct ))) print ( f \"all tasks - total: { toc } seconds\" ) Running Interactively The model can also be run interactively in the repl. Start a python session from the root directory of TITAN , and follow along! We'll use the sample params file tests/params/basic.yml in all of these examples, but feel free to use a different one. Here is how to perform the basic steps of running the model: from titan.parse_params import create_params from titan.model import TITAN outdir = 'results' params = create_params ( None , 'tests/params/basic.yml' , outdir ) model = TITAN ( params ) model . run ( outdir ) This creates a params object using no setting (the None ), our test params, and tells create_params to put our computed params file in a directory called results . the 'results' directory must already be created We then use those params to create our model, and run it. We also have the model results saved to our results directory. We should now see a params.yml in our 'results' directory, and some reports showing what happened at different timesteps in the model. If we wanted to debug something, or look at a very specific metric that wasn't in our reports, we could instead step through the model one time-step at a time. Resuming from our code above, here's how we could do that. model2 = TITAN ( params ) start_time = 0 end_time = 10 for i in range ( start_time , end_time ): model2 . time = i # update the model's time model2 . step ( outdir ) # do some introspection here, like... print ( model2 . pop . haart_counts ) # make sure the model state is reset for a new time step model2 . reset_trackets () If we want to write and read in a population instead of letting the model create one... from titan import population_io as pio from titan.population import Population from copy import deepcopy # let's make a copy of our params and tinker with the population a bit params2 = deepcopy ( params ) params2 . demographics . white . MSM . hiv . prob = 0.4 pop = Population ( params2 ) poppath = pio . write ( pop , outdir ) pop2 = pio . read ( poppath ) # this should be the same population as pop # pass a population to the model to use that instead of creating a new one model3 = TITAN ( param2 , pop2 ) model3 . run ( outdir ) Running the Tests To make sure everything is working, run the tests. A few of the tests (marked integration_stochastic ) sometimes fail as they are testing for general behavior and not specific correctness, but all other tests should always pass. python -m pytest","title":"Running locally"},{"location":"run_local/#running-the-model","text":"The model has a wrapper script called run_titan.py that makes running a full simulation easy. TITAN can also be run from an interactive repl or a custom script.","title":"Running the Model"},{"location":"run_local/#run_titanpy","text":"To run the model, execute the run_titan.py program within the /titan/ directory. See TITAN params for documentation on how to set and use parameters. Results of the model are generated and aggregated into the /results/ directory by default. If the model is re-run, the existing results will be overwritten.","title":"run_titan.py"},{"location":"run_local/#usage","text":"Below are the results of python run_titan.py --help . It highlights all of the command line arguments that can be passed to the script. usage : run_titan . py [ -h ] [ -n [NMC ] ] [ -S SETTING ] - p PARAMS [ -o OUTDIR ] [ -b BASE ] [ -e ] [ --savepop ] [ --poppath POPPATH ] [ -w SWEEP [SWEEP ... ] ] [ -W SWEEPFILE ] [ -r ROWS ] [ -F ] Run TITAN model optional arguments : - h , -- help show this help message and exit - n [ NMC ] , -- nMC [ NMC ] number of monte carlo runs to complete - S SETTING , -- setting SETTING setting directory to use - p PARAMS , -- params PARAMS directory or file with params yaml ( s ) - o OUTDIR , -- outdir OUTDIR directory name to save results to - b BASE , -- base BASE whether to use base setting - e , -- error Error on unused parameters instead of warning -- savepop Save population after creation , but before model run . -- poppath POPPATH Path to saved population ( directory or . tar . gz file ) - w SWEEP [ SWEEP ... ] , -- sweep SWEEP [ SWEEP ... ] Optional and repeatable definitions of numeric params to sweep . Expected format is param : start : stop [ :step ] - W SWEEPFILE , -- sweepfile SWEEPFILE Optional . CSV file with param sweep definitions . Header row must contain param paths , with data rows containing values . If this is passed , any ` - w ` args will be ignored . - r ROWS , -- rows ROWS Optional . Which data rows of sweepfile to use in format start : stop . - F , --force Run model even if number of sweeps exceeds 100","title":"Usage"},{"location":"run_local/#titan.run_titan.main","text":"Run TITAN! Parameters: Name Type Description Default setting str setting name to use, matches a folder name in settings/ required params_path str path to params file or directory required num_reps int number of time to repeat each sweep required outdir str directory where results are to be saved required sweeps List[str] array of strings in param:start:stop:step format required force bool if true, will run even if combination of sweeps results in greater than 100 runs required sweepfile Optional[str] path to csv file of sweep definitions None rows Optional[str] which rows of the csv to load to create sweeps in start:stop format None error_on_unused bool error if there are parameters that are unused by the model False save_pop bool if true, will save the population to file after creation False pop_path Optional[str] path to a population to load instead of creating a new population for each run None Source code in titan/run_titan.py def main ( setting : str , params_path : str , num_reps : int , outdir : str , sweeps : List [ str ], force : bool , sweepfile : Optional [ str ] = None , rows : Optional [ str ] = None , error_on_unused : bool = False , save_pop : bool = False , pop_path : Optional [ str ] = None , ): \"\"\" Run TITAN! args: setting: setting name to use, matches a folder name in `settings/` params_path: path to params file or directory num_reps: number of time to repeat each sweep outdir: directory where results are to be saved sweeps: array of strings in param:start:stop:step format force: if true, will run even if combination of sweeps results in greater than 100 runs sweepfile: path to csv file of sweep definitions rows: which rows of the csv to load to create sweeps in start:stop format error_on_unused: error if there are parameters that are unused by the model save_pop: if true, will save the population to file after creation pop_path: path to a population to load instead of creating a new population for each run \"\"\" outfile_dir = setup_outdir ( outdir , save_pop ) # generate params - if no setting, set to none setting = setting . lower () setting_parsed = None if setting == \"custom\" else setting params = create_params ( setting_parsed , params_path , outfile_dir , error_on_unused = error_on_unused , ) # set up sweeps sweep_defs = get_sweep_defs ( sweepfile , rows , sweeps , num_reps , force ) tic = time_mod . time () wct = [] # wall clock times with Pool ( processes = NCORES , maxtasksperchild = 1 ) as pool : # set max tasks/child to prevent processor drift results = [ pool . apply_async ( single_run , ( sweep_def , outfile_dir , params , save_pop , pop_path ) ) for sweep_def in sweep_defs ] while True : if all ([ r . ready () for r in results ]): break else : time_mod . sleep ( 1 ) for r in results : try : t = r . get () wct . append ( t ) except Exception : traceback . print_exc () toc = time_mod . time () - tic consolidate_files ( outfile_dir ) for task , time_t in enumerate ( wct ): print (( \"wall clock time on for simulation %d : %8.4f seconds\" % ( task , time_t ))) def mean ( seq ): return sum ( seq ) / len ( seq ) print (( \" \\n SUMMARY: \\n all tasks - mean: %8.4f seconds\" % mean ( wct ))) print (( \"all tasks - min: %8.4f seconds\" % min ( wct ))) print (( \"all tasks - max: %8.4f seconds\" % max ( wct ))) print (( \"all tasks - sum: %8.4f seconds\" % sum ( wct ))) print ( f \"all tasks - total: { toc } seconds\" )","title":"main()"},{"location":"run_local/#running-interactively","text":"The model can also be run interactively in the repl. Start a python session from the root directory of TITAN , and follow along! We'll use the sample params file tests/params/basic.yml in all of these examples, but feel free to use a different one. Here is how to perform the basic steps of running the model: from titan.parse_params import create_params from titan.model import TITAN outdir = 'results' params = create_params ( None , 'tests/params/basic.yml' , outdir ) model = TITAN ( params ) model . run ( outdir ) This creates a params object using no setting (the None ), our test params, and tells create_params to put our computed params file in a directory called results . the 'results' directory must already be created We then use those params to create our model, and run it. We also have the model results saved to our results directory. We should now see a params.yml in our 'results' directory, and some reports showing what happened at different timesteps in the model. If we wanted to debug something, or look at a very specific metric that wasn't in our reports, we could instead step through the model one time-step at a time. Resuming from our code above, here's how we could do that. model2 = TITAN ( params ) start_time = 0 end_time = 10 for i in range ( start_time , end_time ): model2 . time = i # update the model's time model2 . step ( outdir ) # do some introspection here, like... print ( model2 . pop . haart_counts ) # make sure the model state is reset for a new time step model2 . reset_trackets () If we want to write and read in a population instead of letting the model create one... from titan import population_io as pio from titan.population import Population from copy import deepcopy # let's make a copy of our params and tinker with the population a bit params2 = deepcopy ( params ) params2 . demographics . white . MSM . hiv . prob = 0.4 pop = Population ( params2 ) poppath = pio . write ( pop , outdir ) pop2 = pio . read ( poppath ) # this should be the same population as pop # pass a population to the model to use that instead of creating a new one model3 = TITAN ( param2 , pop2 ) model3 . run ( outdir )","title":"Running Interactively"},{"location":"run_local/#running-the-tests","text":"To make sure everything is working, run the tests. A few of the tests (marked integration_stochastic ) sometimes fail as they are testing for general behavior and not specific correctness, but all other tests should always pass. python -m pytest","title":"Running the Tests"},{"location":"run_oscar/","text":"See the titan-oscar repository for instructions on installing and running TITAN on OSCAR.","title":"Running on Oscar"},{"location":"api/agent/","text":"This class constructs and represents an agent within the population __init__ ( self , sex_type , age , race , drug_use , location , id = None ) special Initialize an agent based on given properties Parameters: Name Type Description Default id Optional[int] Unique agent ID None sex_type str Name of defined sex type (e.g. MSM) [params.classes.sex_types] required age int Agents initialization age required race str Race of agent [params.classes.races] required drug_use str Drug use flag [params.classes.drug_types] required Source code in titan/agent.py def __init__ ( self , sex_type : str , age : int , race : str , drug_use : str , location : Location , id : Optional [ int ] = None , ) -> None : \"\"\" Initialize an agent based on given properties Args: id: Unique agent ID sex_type: Name of defined sex type (e.g. MSM) [params.classes.sex_types] age: Agents initialization age race: Race of agent [params.classes.races] drug_use: Drug use flag [params.classes.drug_types] \"\"\" # self.id is unique ID number used to track each person agent. if id is not None : self . id = id else : self . id = self . next_agent_id self . update_id_counter ( self . id ) # agent properties self . sex_type = sex_type self . age = age self . age_bin = 0 self . race = race self . drug_type = drug_use self . location = location self . component = \"-1\" # updated after relationships created self . sex_role = \"versatile\" # agent-partner params self . relationships : Set [ Relationship ] = set () self . partners : Dict [ str , Set ] = {} self . mean_num_partners : Dict [ str , int ] = {} self . target_partners : Dict [ str , int ] = {} # agent exposures params # model features for exposure in exposures . BaseExposure . __subclasses__ (): setattr ( self , exposure . name , exposure ( self )) # model features for feature in features . BaseFeature . __subclasses__ (): setattr ( self , feature . name , feature ( self )) __repr__ ( self ) special Repr formatting of agent object Returns: Type Description str agent ID as str Source code in titan/agent.py def __repr__ ( self ) -> str : \"\"\" Repr formatting of agent object returns: agent ID as str \"\"\" return str ( self . id ) __str__ ( self ) special String formatting of agent object Returns: Type Description str String formatted tab-deliminated agent properties Source code in titan/agent.py def __str__ ( self ) -> str : \"\"\" String formatting of agent object returns: String formatted tab-deliminated agent properties \"\"\" return ( f \" \\t { self . id } \\t { self . age } \\t { self . sex_type } \\t { self . drug_type } \\t \" # type: ignore[attr-defined] f \" { self . race } \\t { self . hiv . active } \" # type: ignore[attr-defined] ) get_num_partners ( self , bond_types = None ) Get the number of partners an agent has, optionally filtered by bond type Parameters: Name Type Description Default bond_types Optional[Iterable[str]] list of bond types which will filter the partners, otherwise total number of partners returned None Returns: Type Description int the number of partners the agent has Source code in titan/agent.py def get_num_partners ( self , bond_types : Optional [ Iterable [ str ]] = None ) -> int : \"\"\" Get the number of partners an agent has, optionally filtered by bond type args: bond_types: list of bond types which will filter the partners, otherwise total number of partners returned returns: the number of partners the agent has \"\"\" return len ( self . get_partners ( bond_types )) get_partners ( self , bond_types = None ) Get all of an agents partners or those with specific bond types Parameters: Name Type Description Default bond_types Optional[Iterable[str]] list of bond types which will filter the partners, otherwise all partners returned None Returns: Type Description Set[Agent] set of agent's partners Source code in titan/agent.py def get_partners ( self , bond_types : Optional [ Iterable [ str ]] = None ) -> Set [ \"Agent\" ]: \"\"\" Get all of an agents partners or those with specific bond types args: bond_types: list of bond types which will filter the partners, otherwise all partners returned returns: set of agent's partners \"\"\" if bond_types : partners = set () for bond in bond_types : partners . update ( self . partners [ bond ]) else : partners = { partner for partner in self . iter_partners ()} return partners has_partners ( self ) Determine whether an agent has any partners Returns: Type Description bool whether an agent has at least one partner Source code in titan/agent.py def has_partners ( self ) -> bool : \"\"\" Determine whether an agent has any partners returns: whether an agent has at least one partner \"\"\" return any ( self . iter_partners ()) is_msm ( self ) Determine whether an agent is a man who can have sex with men Returns: Type Description bool if agent is MSM Source code in titan/agent.py def is_msm ( self ) -> bool : \"\"\" Determine whether an agent is a man who can have sex with men returns: if agent is MSM \"\"\" sex_dict = self . location . params . classes . sex_types if sex_dict [ self . sex_type ] . gender != \"M\" : return False for sex_type in sex_dict [ self . sex_type ] . sleeps_with : if sex_dict [ sex_type ] . gender == \"M\" : return True return False iter_partners ( self ) Get an iterator over an agent's partners Returns: Type Description Iterator[Agent] iterator of agent partners Source code in titan/agent.py def iter_partners ( self ) -> Iterator [ \"Agent\" ]: \"\"\" Get an iterator over an agent's partners returns: iterator of agent partners \"\"\" for partner_set in self . partners . values (): for partner in partner_set : yield partner","title":"Agent"},{"location":"api/agent/#titan.agent.Agent.__init__","text":"Initialize an agent based on given properties Parameters: Name Type Description Default id Optional[int] Unique agent ID None sex_type str Name of defined sex type (e.g. MSM) [params.classes.sex_types] required age int Agents initialization age required race str Race of agent [params.classes.races] required drug_use str Drug use flag [params.classes.drug_types] required Source code in titan/agent.py def __init__ ( self , sex_type : str , age : int , race : str , drug_use : str , location : Location , id : Optional [ int ] = None , ) -> None : \"\"\" Initialize an agent based on given properties Args: id: Unique agent ID sex_type: Name of defined sex type (e.g. MSM) [params.classes.sex_types] age: Agents initialization age race: Race of agent [params.classes.races] drug_use: Drug use flag [params.classes.drug_types] \"\"\" # self.id is unique ID number used to track each person agent. if id is not None : self . id = id else : self . id = self . next_agent_id self . update_id_counter ( self . id ) # agent properties self . sex_type = sex_type self . age = age self . age_bin = 0 self . race = race self . drug_type = drug_use self . location = location self . component = \"-1\" # updated after relationships created self . sex_role = \"versatile\" # agent-partner params self . relationships : Set [ Relationship ] = set () self . partners : Dict [ str , Set ] = {} self . mean_num_partners : Dict [ str , int ] = {} self . target_partners : Dict [ str , int ] = {} # agent exposures params # model features for exposure in exposures . BaseExposure . __subclasses__ (): setattr ( self , exposure . name , exposure ( self )) # model features for feature in features . BaseFeature . __subclasses__ (): setattr ( self , feature . name , feature ( self ))","title":"__init__()"},{"location":"api/agent/#titan.agent.Agent.__repr__","text":"Repr formatting of agent object Returns: Type Description str agent ID as str Source code in titan/agent.py def __repr__ ( self ) -> str : \"\"\" Repr formatting of agent object returns: agent ID as str \"\"\" return str ( self . id )","title":"__repr__()"},{"location":"api/agent/#titan.agent.Agent.__str__","text":"String formatting of agent object Returns: Type Description str String formatted tab-deliminated agent properties Source code in titan/agent.py def __str__ ( self ) -> str : \"\"\" String formatting of agent object returns: String formatted tab-deliminated agent properties \"\"\" return ( f \" \\t { self . id } \\t { self . age } \\t { self . sex_type } \\t { self . drug_type } \\t \" # type: ignore[attr-defined] f \" { self . race } \\t { self . hiv . active } \" # type: ignore[attr-defined] )","title":"__str__()"},{"location":"api/agent/#titan.agent.Agent.get_num_partners","text":"Get the number of partners an agent has, optionally filtered by bond type Parameters: Name Type Description Default bond_types Optional[Iterable[str]] list of bond types which will filter the partners, otherwise total number of partners returned None Returns: Type Description int the number of partners the agent has Source code in titan/agent.py def get_num_partners ( self , bond_types : Optional [ Iterable [ str ]] = None ) -> int : \"\"\" Get the number of partners an agent has, optionally filtered by bond type args: bond_types: list of bond types which will filter the partners, otherwise total number of partners returned returns: the number of partners the agent has \"\"\" return len ( self . get_partners ( bond_types ))","title":"get_num_partners()"},{"location":"api/agent/#titan.agent.Agent.get_partners","text":"Get all of an agents partners or those with specific bond types Parameters: Name Type Description Default bond_types Optional[Iterable[str]] list of bond types which will filter the partners, otherwise all partners returned None Returns: Type Description Set[Agent] set of agent's partners Source code in titan/agent.py def get_partners ( self , bond_types : Optional [ Iterable [ str ]] = None ) -> Set [ \"Agent\" ]: \"\"\" Get all of an agents partners or those with specific bond types args: bond_types: list of bond types which will filter the partners, otherwise all partners returned returns: set of agent's partners \"\"\" if bond_types : partners = set () for bond in bond_types : partners . update ( self . partners [ bond ]) else : partners = { partner for partner in self . iter_partners ()} return partners","title":"get_partners()"},{"location":"api/agent/#titan.agent.Agent.has_partners","text":"Determine whether an agent has any partners Returns: Type Description bool whether an agent has at least one partner Source code in titan/agent.py def has_partners ( self ) -> bool : \"\"\" Determine whether an agent has any partners returns: whether an agent has at least one partner \"\"\" return any ( self . iter_partners ())","title":"has_partners()"},{"location":"api/agent/#titan.agent.Agent.is_msm","text":"Determine whether an agent is a man who can have sex with men Returns: Type Description bool if agent is MSM Source code in titan/agent.py def is_msm ( self ) -> bool : \"\"\" Determine whether an agent is a man who can have sex with men returns: if agent is MSM \"\"\" sex_dict = self . location . params . classes . sex_types if sex_dict [ self . sex_type ] . gender != \"M\" : return False for sex_type in sex_dict [ self . sex_type ] . sleeps_with : if sex_dict [ sex_type ] . gender == \"M\" : return True return False","title":"is_msm()"},{"location":"api/agent/#titan.agent.Agent.iter_partners","text":"Get an iterator over an agent's partners Returns: Type Description Iterator[Agent] iterator of agent partners Source code in titan/agent.py def iter_partners ( self ) -> Iterator [ \"Agent\" ]: \"\"\" Get an iterator over an agent's partners returns: iterator of agent partners \"\"\" for partner_set in self . partners . values (): for partner in partner_set : yield partner","title":"iter_partners()"},{"location":"api/agent_set/","text":"Container for agents into heirarchical sets (e.g. all_agents > hiv_agents) __contains__ ( self , item ) special Is an agent a member of this agent set Examples: if agent in agent_set : # do something Returns: Type Description bool whether agent is part of set Source code in titan/agent.py def __contains__ ( self , item ) -> bool : \"\"\" Is an agent a member of this agent set example: ```py if agent in agent_set: # do something ``` returns: whether agent is part of set \"\"\" return self . members . __contains__ ( item ) __init__ ( self , id , parent = None ) special Constructor of an AgentSet Parameters: Name Type Description Default id str name of the set required parent Optional[AgentSet] the set this set is a subset of None Source code in titan/agent.py def __init__ ( self , id : str , parent : Optional [ \"AgentSet\" ] = None , ): \"\"\" Constructor of an AgentSet args: id: name of the set parent: the set this set is a subset of \"\"\" # members stores agent set members in a dictionary keyed by ID self . id = id self . members : Set [ Agent ] = set () self . subset : Dict [ str , AgentSet ] = {} # parent_set stores the parent set if this set is a member of an # AgentSet class instance. For example, for a set that is a # member of a larger set, the _parent_set for that set would # be that larger set. self . parent_set = parent if parent : parent . add_subset ( self ) __iter__ ( self ) special Iterate over the memers in the set Examples: for agent in agent_set : # do something with agent Returns: Type Description Iterator[titan.agent.Agent] iterator over member agents Source code in titan/agent.py def __iter__ ( self ) -> Iterator [ Agent ]: \"\"\" Iterate over the memers in the set example: ```py for agent in agent_set: # do something with agent ``` returns: iterator over member agents \"\"\" return self . members . __iter__ () add_agent ( self , agent ) Adds an agent to the set and any parent sets Parameters: Name Type Description Default agent Agent agent to add required Source code in titan/agent.py def add_agent ( self , agent : Agent ) -> None : \"\"\" Adds an agent to the set and any parent sets args: agent: agent to add \"\"\" self . members . add ( agent ) if self . parent_set is not None : self . parent_set . add_agent ( agent ) add_subset ( self , subset ) Adds a new AgentSet to the current sets subset. Parameters: Name Type Description Default subset AgentSet subset to add to this set required Source code in titan/agent.py def add_subset ( self , subset : \"AgentSet\" ) -> None : \"\"\" Adds a new AgentSet to the current sets subset. args: subset: subset to add to this set \"\"\" if subset . id not in self . subset : self . subset [ subset . id ] = subset clear_set ( self ) Clears a set of any members and subsets Source code in titan/agent.py def clear_set ( self ): \"\"\" Clears a set of any members and subsets \"\"\" self . members : Set [ Agent ] = set () self . subset : Dict [ str , str ] = {} iter_subset ( self ) Iterate over the subsets of this agent set Returns: Type Description Iterator[AgentSet] iterator of agent sets Source code in titan/agent.py def iter_subset ( self ) -> Iterator [ \"AgentSet\" ]: \"\"\" Iterate over the subsets of this agent set returns: iterator of agent sets \"\"\" for subset in list ( self . subset . values ()): yield subset num_members ( self ) Number of members in the set Returns: Type Description int number of members Source code in titan/agent.py def num_members ( self ) -> int : \"\"\" Number of members in the set returns: number of members \"\"\" return len ( self . members ) print_subsets ( self , printer =< built - in function print > ) Pretty print the subsets of this agent set Source code in titan/agent.py def print_subsets ( self , printer = print ): \"\"\" Pretty print the subsets of this agent set \"\"\" lines = [] lines . append ( f \" \\t __________ { self . id } __________\" ) # lines.append(\"\\tID\\t\\tN\\t\\t%\") lines . append ( \" \\t {:^6} \\t\\t {:^5} \\t\\t {:^4} \" . format ( \"ID\" , \"N\" , \"%\" )) for set in self . iter_subset (): lines . append ( \" \\t {:^6} \\t\\t {:^5} \\t\\t {:.2} \" . format ( set . id , set . num_members (), safe_divide ( set . num_members (), set . parent_set . num_members ()), ) ) for subset in set . iter_subset (): lines . append ( \" \\t {:4} \\t\\t {:5} \\t\\t {:.2} \" . format ( subset . id , subset . num_members (), safe_divide ( subset . num_members (), subset . parent_set . num_members () ), ) ) lines . append ( \" \\t ______________ END ______________\" ) printer ( \" \\n \" . join ( lines )) remove_agent ( self , agent ) Removes agent from agent set if they are a member of the set. Also removes the agent from any subsets. Parameters: Name Type Description Default agent Agent agent to remove required Source code in titan/agent.py def remove_agent ( self , agent : Agent ) -> None : \"\"\" Removes agent from agent set if they are a member of the set. Also removes the agent from any subsets. args: agent: agent to remove \"\"\" if agent in self . members : self . members . remove ( agent ) for subset in self . iter_subset (): subset . remove_agent ( agent )","title":"AgentSet"},{"location":"api/agent_set/#titan.agent.AgentSet.__contains__","text":"Is an agent a member of this agent set Examples: if agent in agent_set : # do something Returns: Type Description bool whether agent is part of set Source code in titan/agent.py def __contains__ ( self , item ) -> bool : \"\"\" Is an agent a member of this agent set example: ```py if agent in agent_set: # do something ``` returns: whether agent is part of set \"\"\" return self . members . __contains__ ( item )","title":"__contains__()"},{"location":"api/agent_set/#titan.agent.AgentSet.__init__","text":"Constructor of an AgentSet Parameters: Name Type Description Default id str name of the set required parent Optional[AgentSet] the set this set is a subset of None Source code in titan/agent.py def __init__ ( self , id : str , parent : Optional [ \"AgentSet\" ] = None , ): \"\"\" Constructor of an AgentSet args: id: name of the set parent: the set this set is a subset of \"\"\" # members stores agent set members in a dictionary keyed by ID self . id = id self . members : Set [ Agent ] = set () self . subset : Dict [ str , AgentSet ] = {} # parent_set stores the parent set if this set is a member of an # AgentSet class instance. For example, for a set that is a # member of a larger set, the _parent_set for that set would # be that larger set. self . parent_set = parent if parent : parent . add_subset ( self )","title":"__init__()"},{"location":"api/agent_set/#titan.agent.AgentSet.__iter__","text":"Iterate over the memers in the set Examples: for agent in agent_set : # do something with agent Returns: Type Description Iterator[titan.agent.Agent] iterator over member agents Source code in titan/agent.py def __iter__ ( self ) -> Iterator [ Agent ]: \"\"\" Iterate over the memers in the set example: ```py for agent in agent_set: # do something with agent ``` returns: iterator over member agents \"\"\" return self . members . __iter__ ()","title":"__iter__()"},{"location":"api/agent_set/#titan.agent.AgentSet.add_agent","text":"Adds an agent to the set and any parent sets Parameters: Name Type Description Default agent Agent agent to add required Source code in titan/agent.py def add_agent ( self , agent : Agent ) -> None : \"\"\" Adds an agent to the set and any parent sets args: agent: agent to add \"\"\" self . members . add ( agent ) if self . parent_set is not None : self . parent_set . add_agent ( agent )","title":"add_agent()"},{"location":"api/agent_set/#titan.agent.AgentSet.add_subset","text":"Adds a new AgentSet to the current sets subset. Parameters: Name Type Description Default subset AgentSet subset to add to this set required Source code in titan/agent.py def add_subset ( self , subset : \"AgentSet\" ) -> None : \"\"\" Adds a new AgentSet to the current sets subset. args: subset: subset to add to this set \"\"\" if subset . id not in self . subset : self . subset [ subset . id ] = subset","title":"add_subset()"},{"location":"api/agent_set/#titan.agent.AgentSet.clear_set","text":"Clears a set of any members and subsets Source code in titan/agent.py def clear_set ( self ): \"\"\" Clears a set of any members and subsets \"\"\" self . members : Set [ Agent ] = set () self . subset : Dict [ str , str ] = {}","title":"clear_set()"},{"location":"api/agent_set/#titan.agent.AgentSet.iter_subset","text":"Iterate over the subsets of this agent set Returns: Type Description Iterator[AgentSet] iterator of agent sets Source code in titan/agent.py def iter_subset ( self ) -> Iterator [ \"AgentSet\" ]: \"\"\" Iterate over the subsets of this agent set returns: iterator of agent sets \"\"\" for subset in list ( self . subset . values ()): yield subset","title":"iter_subset()"},{"location":"api/agent_set/#titan.agent.AgentSet.num_members","text":"Number of members in the set Returns: Type Description int number of members Source code in titan/agent.py def num_members ( self ) -> int : \"\"\" Number of members in the set returns: number of members \"\"\" return len ( self . members )","title":"num_members()"},{"location":"api/agent_set/#titan.agent.AgentSet.print_subsets","text":"Pretty print the subsets of this agent set Source code in titan/agent.py def print_subsets ( self , printer = print ): \"\"\" Pretty print the subsets of this agent set \"\"\" lines = [] lines . append ( f \" \\t __________ { self . id } __________\" ) # lines.append(\"\\tID\\t\\tN\\t\\t%\") lines . append ( \" \\t {:^6} \\t\\t {:^5} \\t\\t {:^4} \" . format ( \"ID\" , \"N\" , \"%\" )) for set in self . iter_subset (): lines . append ( \" \\t {:^6} \\t\\t {:^5} \\t\\t {:.2} \" . format ( set . id , set . num_members (), safe_divide ( set . num_members (), set . parent_set . num_members ()), ) ) for subset in set . iter_subset (): lines . append ( \" \\t {:4} \\t\\t {:5} \\t\\t {:.2} \" . format ( subset . id , subset . num_members (), safe_divide ( subset . num_members (), subset . parent_set . num_members () ), ) ) lines . append ( \" \\t ______________ END ______________\" ) printer ( \" \\n \" . join ( lines ))","title":"print_subsets()"},{"location":"api/agent_set/#titan.agent.AgentSet.remove_agent","text":"Removes agent from agent set if they are a member of the set. Also removes the agent from any subsets. Parameters: Name Type Description Default agent Agent agent to remove required Source code in titan/agent.py def remove_agent ( self , agent : Agent ) -> None : \"\"\" Removes agent from agent set if they are a member of the set. Also removes the agent from any subsets. args: agent: agent to remove \"\"\" if agent in self . members : self . members . remove ( agent ) for subset in self . iter_subset (): subset . remove_agent ( agent )","title":"remove_agent()"},{"location":"api/location/","text":"Locations can be used in TITAN to differentiate agents by \"geography\". The primary features of locations are: Differentiated parameters via location scaling/overrides Allows different demographics or interventions by location See params app for details Location based assorting (including based on neighboring locations) Can have agents assort with agents from their own location vs neighbors vs all others Neighboring locations are determined by the edges defined in params.location See params app for details on assorting rules It is also possible to define edges via a geography CSV (see utils ). This is also exposed via the grid2edges command line utility (run grid2edges --help for usage). Migration between locations When an agent migrates locations, they adopt the parameters of their new location Migration can cause the population numbers in a location to drift over time See params app for details Location __init__ ( self , name , defn , params ) special This class constructs and represents a location within the model. A location can have an arbitrary geographic granularity. Parameters: Name Type Description Default name str name of the location required defn ObjMap definition for this location required params ObjMap model parameters required Source code in titan/location.py def __init__ ( self , name : str , defn : ObjMap , params : ObjMap ): \"\"\" This class constructs and represents a location within the model. A location can have an arbitrary geographic granularity. args: name: name of the location defn: definition for this location params: model parameters \"\"\" # location properties self . name = name self . params = self . create_params ( params ) self . ppl = defn . ppl # percent of overall population assigned to this location self . category = defn . category # arbitrary category, can be used for migration # value/weight maps needed for creating new agents in this location self . pop_weights : Dict [ str , Dict [ str , List [ Any ]]] = {} self . role_weights : Dict [ str , Dict ] = {} self . drug_weights : Dict [ str , Dict ] = {} self . init_weights () self . migration_weights : Dict [ str , Any ] = {} self . neighbors : Set [ str ] = set () # or maybe edges instead create_params ( self , params ) Scale or override the generic parameters with any location based scaling from params.location.scaling Parameters: Name Type Description Default params ObjMap model parameters required Returns: Type Description ObjMap new parameter object with scaled values for this location Source code in titan/location.py def create_params ( self , params : ObjMap ) -> ObjMap : \"\"\" Scale or override the generic parameters with any location based scaling from params.location.scaling args: params: model parameters returns: new parameter object with scaled values for this location \"\"\" new_params = deepcopy ( params ) defns = new_params . location . scaling [ self . name ] for param_path , defn in defns . items (): if param_path != \"ls_default\" : if defn . field == \"scalar\" : utils . scale_param ( new_params , param_path , defn . scalar ) elif defn . field == \"override\" : utils . override_param ( new_params , param_path , defn . override ) return new_params init_weights ( self ) Create the containers to hold values and weights for randomly selecting: sex_role drug_type race sex_type Source code in titan/location.py def init_weights ( self ): \"\"\" Create the containers to hold values and weights for randomly selecting: * sex_role * drug_type * race * sex_type \"\"\" def init_weight_dict ( d , item ): d [ item ] = {} d [ item ][ \"values\" ] = [] d [ item ][ \"weights\" ] = [] def add_weight ( d , v , w ): d [ \"values\" ] . append ( v ) d [ \"weights\" ] . append ( w ) total_ppl = 0 for race , race_param in self . params . demographics . items (): self . role_weights [ race ] = {} self . drug_weights [ race ] = {} init_weight_dict ( self . pop_weights , race ) total_ppl += race_param . ppl for st , st_param in race_param . sex_type . items (): add_weight ( self . pop_weights [ race ], st , st_param . ppl ) init_weight_dict ( self . role_weights [ race ], st ) init_weight_dict ( self . drug_weights [ race ], st ) for role , prob in st_param . sex_role . init . items (): add_weight ( self . role_weights [ race ][ st ], role , prob ) for dt , dt_param in st_param . drug_type . items (): add_weight ( self . drug_weights [ race ][ st ], dt , dt_param . ppl ) assert math . isclose ( sum ( self . role_weights [ race ][ st ][ \"weights\" ]), 1 , abs_tol = 0.001 ), f \" { self . name } 's' { race } { st } role weights must add to 1\" assert math . isclose ( sum ( self . drug_weights [ race ][ st ][ \"weights\" ]), 1 , abs_tol = 0.001 ), f \"ppl of { self . name } 's' { race } { st } drug_types must add to 1\" assert math . isclose ( sum ( self . pop_weights [ race ][ \"weights\" ]), 1 , abs_tol = 0.001 ), f \"ppl of { self . name } 's' { race } sex_types must add to 1\" assert math . isclose ( total_ppl , 1 , abs_tol = 0.001 ), f \"ppl of { self . name } 's' races must add to 1\" LocationEdge __init__ ( self , loc1 , loc2 , distance , id = None ) special Construct a location edge, which holds attributes that relate two Locations. Parameters: Name Type Description Default loc1 Location the first location required loc2 Location the other location required distance float a measure of distance between the locations required id Optional[int] a unique identifier for this edge None Source code in titan/location.py def __init__ ( self , loc1 : Location , loc2 : Location , distance : float , id : Optional [ int ] = None ): \"\"\" Construct a location edge, which holds attributes that relate two Locations. args: loc1: the first location loc2: the other location distance: a measure of distance between the locations id: a unique identifier for this edge \"\"\" assert loc1 != loc2 , \"can't have a location self-edge\" # self.id is unique ID number used to track each edge. if id is not None : self . id = id else : self . id = self . next_edge_id self . update_id_counter ( self . id ) self . edge = set ({ loc1 , loc2 }) self . distance = distance loc1 . neighbors . add ( loc2 . name ) loc2 . neighbors . add ( loc1 . name ) Geography __init__ ( self , params ) special Umbrella class to initialize/store locations and location edges for a population Parameters: Name Type Description Default params ObjMap model parameters required Source code in titan/location.py def __init__ ( self , params : ObjMap ): \"\"\" Umbrella class to initialize/store locations and location edges for a population args: params: model parameters \"\"\" self . locations : Dict [ str , Location ] = { location : Location ( location , defn , params ) for location , defn in params . classes . locations . items () } self . categories : Dict [ str , List [ Location ]] = {} for location in self . locations . values (): if location . category in self . categories : self . categories [ location . category ] . append ( location ) else : self . categories [ location . category ] = [ location ] if params . location . migration . enabled : with open ( params . location . migration . probs_file , newline = \"\" ) as f : reader = csv . DictReader ( f ) for row in reader : from_loc = row . pop ( \"\" ) prob = float ( row . pop ( \"prob\" , 1 )) values = list ( row . keys ()) weights = list ( map ( float , row . values ())) assert math . isclose ( sum ( weights ), 1 , abs_tol = 0.001 ), f \"Migration weights for { from_loc } must add to 1\" if params . location . migration . attribute == \"name\" : self . locations [ from_loc ] . migration_weights [ \"prob\" ] = prob self . locations [ from_loc ] . migration_weights [ \"weights\" ] = weights self . locations [ from_loc ] . migration_weights [ \"values\" ] = values elif params . location . migration . attribute == \"category\" : for location in self . categories [ from_loc ]: location . migration_weights [ \"prob\" ] = prob location . migration_weights [ \"weights\" ] = weights location . migration_weights [ \"values\" ] = values else : raise ValueError ( \"Unknown migration attribute\" ) self . edges : Set [ LocationEdge ] = set () for name , defn in params . location . edges . items (): if name != \"edge_default\" : loc1 = self . locations [ defn . location_1 ] loc2 = self . locations [ defn . location_2 ] self . edges . add ( LocationEdge ( loc1 , loc2 , defn . distance ))","title":"Location"},{"location":"api/location/#location","text":"","title":"Location"},{"location":"api/location/#titan.location.Location.__init__","text":"This class constructs and represents a location within the model. A location can have an arbitrary geographic granularity. Parameters: Name Type Description Default name str name of the location required defn ObjMap definition for this location required params ObjMap model parameters required Source code in titan/location.py def __init__ ( self , name : str , defn : ObjMap , params : ObjMap ): \"\"\" This class constructs and represents a location within the model. A location can have an arbitrary geographic granularity. args: name: name of the location defn: definition for this location params: model parameters \"\"\" # location properties self . name = name self . params = self . create_params ( params ) self . ppl = defn . ppl # percent of overall population assigned to this location self . category = defn . category # arbitrary category, can be used for migration # value/weight maps needed for creating new agents in this location self . pop_weights : Dict [ str , Dict [ str , List [ Any ]]] = {} self . role_weights : Dict [ str , Dict ] = {} self . drug_weights : Dict [ str , Dict ] = {} self . init_weights () self . migration_weights : Dict [ str , Any ] = {} self . neighbors : Set [ str ] = set () # or maybe edges instead","title":"__init__()"},{"location":"api/location/#titan.location.Location.create_params","text":"Scale or override the generic parameters with any location based scaling from params.location.scaling Parameters: Name Type Description Default params ObjMap model parameters required Returns: Type Description ObjMap new parameter object with scaled values for this location Source code in titan/location.py def create_params ( self , params : ObjMap ) -> ObjMap : \"\"\" Scale or override the generic parameters with any location based scaling from params.location.scaling args: params: model parameters returns: new parameter object with scaled values for this location \"\"\" new_params = deepcopy ( params ) defns = new_params . location . scaling [ self . name ] for param_path , defn in defns . items (): if param_path != \"ls_default\" : if defn . field == \"scalar\" : utils . scale_param ( new_params , param_path , defn . scalar ) elif defn . field == \"override\" : utils . override_param ( new_params , param_path , defn . override ) return new_params","title":"create_params()"},{"location":"api/location/#titan.location.Location.init_weights","text":"Create the containers to hold values and weights for randomly selecting: sex_role drug_type race sex_type Source code in titan/location.py def init_weights ( self ): \"\"\" Create the containers to hold values and weights for randomly selecting: * sex_role * drug_type * race * sex_type \"\"\" def init_weight_dict ( d , item ): d [ item ] = {} d [ item ][ \"values\" ] = [] d [ item ][ \"weights\" ] = [] def add_weight ( d , v , w ): d [ \"values\" ] . append ( v ) d [ \"weights\" ] . append ( w ) total_ppl = 0 for race , race_param in self . params . demographics . items (): self . role_weights [ race ] = {} self . drug_weights [ race ] = {} init_weight_dict ( self . pop_weights , race ) total_ppl += race_param . ppl for st , st_param in race_param . sex_type . items (): add_weight ( self . pop_weights [ race ], st , st_param . ppl ) init_weight_dict ( self . role_weights [ race ], st ) init_weight_dict ( self . drug_weights [ race ], st ) for role , prob in st_param . sex_role . init . items (): add_weight ( self . role_weights [ race ][ st ], role , prob ) for dt , dt_param in st_param . drug_type . items (): add_weight ( self . drug_weights [ race ][ st ], dt , dt_param . ppl ) assert math . isclose ( sum ( self . role_weights [ race ][ st ][ \"weights\" ]), 1 , abs_tol = 0.001 ), f \" { self . name } 's' { race } { st } role weights must add to 1\" assert math . isclose ( sum ( self . drug_weights [ race ][ st ][ \"weights\" ]), 1 , abs_tol = 0.001 ), f \"ppl of { self . name } 's' { race } { st } drug_types must add to 1\" assert math . isclose ( sum ( self . pop_weights [ race ][ \"weights\" ]), 1 , abs_tol = 0.001 ), f \"ppl of { self . name } 's' { race } sex_types must add to 1\" assert math . isclose ( total_ppl , 1 , abs_tol = 0.001 ), f \"ppl of { self . name } 's' races must add to 1\"","title":"init_weights()"},{"location":"api/location/#locationedge","text":"","title":"LocationEdge"},{"location":"api/location/#titan.location.LocationEdge.__init__","text":"Construct a location edge, which holds attributes that relate two Locations. Parameters: Name Type Description Default loc1 Location the first location required loc2 Location the other location required distance float a measure of distance between the locations required id Optional[int] a unique identifier for this edge None Source code in titan/location.py def __init__ ( self , loc1 : Location , loc2 : Location , distance : float , id : Optional [ int ] = None ): \"\"\" Construct a location edge, which holds attributes that relate two Locations. args: loc1: the first location loc2: the other location distance: a measure of distance between the locations id: a unique identifier for this edge \"\"\" assert loc1 != loc2 , \"can't have a location self-edge\" # self.id is unique ID number used to track each edge. if id is not None : self . id = id else : self . id = self . next_edge_id self . update_id_counter ( self . id ) self . edge = set ({ loc1 , loc2 }) self . distance = distance loc1 . neighbors . add ( loc2 . name ) loc2 . neighbors . add ( loc1 . name )","title":"__init__()"},{"location":"api/location/#geography","text":"","title":"Geography"},{"location":"api/location/#titan.location.Geography.__init__","text":"Umbrella class to initialize/store locations and location edges for a population Parameters: Name Type Description Default params ObjMap model parameters required Source code in titan/location.py def __init__ ( self , params : ObjMap ): \"\"\" Umbrella class to initialize/store locations and location edges for a population args: params: model parameters \"\"\" self . locations : Dict [ str , Location ] = { location : Location ( location , defn , params ) for location , defn in params . classes . locations . items () } self . categories : Dict [ str , List [ Location ]] = {} for location in self . locations . values (): if location . category in self . categories : self . categories [ location . category ] . append ( location ) else : self . categories [ location . category ] = [ location ] if params . location . migration . enabled : with open ( params . location . migration . probs_file , newline = \"\" ) as f : reader = csv . DictReader ( f ) for row in reader : from_loc = row . pop ( \"\" ) prob = float ( row . pop ( \"prob\" , 1 )) values = list ( row . keys ()) weights = list ( map ( float , row . values ())) assert math . isclose ( sum ( weights ), 1 , abs_tol = 0.001 ), f \"Migration weights for { from_loc } must add to 1\" if params . location . migration . attribute == \"name\" : self . locations [ from_loc ] . migration_weights [ \"prob\" ] = prob self . locations [ from_loc ] . migration_weights [ \"weights\" ] = weights self . locations [ from_loc ] . migration_weights [ \"values\" ] = values elif params . location . migration . attribute == \"category\" : for location in self . categories [ from_loc ]: location . migration_weights [ \"prob\" ] = prob location . migration_weights [ \"weights\" ] = weights location . migration_weights [ \"values\" ] = values else : raise ValueError ( \"Unknown migration attribute\" ) self . edges : Set [ LocationEdge ] = set () for name , defn in params . location . edges . items (): if name != \"edge_default\" : loc1 = self . locations [ defn . location_1 ] loc2 = self . locations [ defn . location_2 ] self . edges . add ( LocationEdge ( loc1 , loc2 , defn . distance ))","title":"__init__()"},{"location":"api/model/","text":"TITAN The TITAN class is used to model agent interactions as they progress through time. The model can be run on an existing Population or it can create a Population during its construction. The most common entry point to the model is run , which will run the model for all time steps. To run step by step, step can be iterated through instead, just be sure to reset_trackers between step s. __init__ ( self , params , pop = None ) special This is the core class used to simulate the spread of exposures through a relationship based network. Parameters: Name Type Description Default params ObjMap the parameter object for this model required pop Optional[population.Population] an initialized population to run the model on None Source code in titan/model.py def __init__ ( self , params : ObjMap , pop : Optional [ \"population.Population\" ] = None , ): \"\"\" This is the core class used to simulate the spread of exposures through a relationship based network. args: params: the parameter object for this model pop: an initialized population to run the model on \"\"\" self . id = nanoid . generate ( size = 8 ) self . params = params # pre-fetch commonly used param sub-sets for performance self . calibration = params . calibration utils . set_up_logging ( params ) logging . info ( f \"Model ID: { self . id } \" ) logging . info ( \"=== Begin Initialization Protocol === \\n \" ) if pop is None : logging . info ( \" Generating new population\" ) self . pop = population . Population ( params ) else : logging . info ( \" Using provided population\" ) self . pop = pop self . time = - 1 * self . params . model . time . burn_steps # burn is negative time self . features = [ feature for feature in features . BaseFeature . __subclasses__ () if self . params . features [ feature . name ] ] # set up the in-scope exposures self . exposures = [ exposure for exposure in exposures . BaseExposure . __subclasses__ () if self . params . exposures [ exposure . name ] ] self . interactions = { interaction . name : interaction for interaction in interactions . BaseInteraction . __subclasses__ () } # Set seed format. 0: pure random, else: fixed value self . run_seed = utils . get_check_rand_int ( params . model . seed . run ) logging . info ( f \" Run seed was set to: { self . run_seed } \" ) self . run_random = random . Random ( self . run_seed ) self . np_random = np . random . default_rng ( self . run_seed ) random . seed ( self . run_seed ) logging . info (( \" FIRST RANDOM CALL {} \" . format ( random . randint ( 0 , 100 )))) logging . info ( \" Resetting death count\" ) self . deaths : List [ \"ag.Agent\" ] = [] # Number of death logging . info ( \" \\n === Initialization Protocol Finished ===\" ) agents_interact ( self , rel ) Let an agent interact with a partner. Based on the interaction types of the relationship, interact in the following ways: Peer Change Agent Injection Sex Parameters: Name Type Description Default rel ag.Relationship The relationship that the agents interact in required Source code in titan/model.py def agents_interact ( self , rel : \"ag.Relationship\" ): \"\"\" Let an agent interact with a partner. Based on the interaction types of the relationship, interact in the following ways: * Peer Change Agent * Injection * Sex args: rel : The relationship that the agents interact in \"\"\" interaction_types = self . params . classes . bond_types [ rel . bond_type ] . acts_allowed # If either agent is incarcerated, skip their interaction if rel . agent1 . incar . active or rel . agent2 . incar . active : # type: ignore[attr-defined] return for interaction_type in interaction_types : interaction = self . interactions [ interaction_type ] interaction . interact ( self , rel ) die_and_replace ( self ) Let agents die and replace the dead agent with a new agent randomly. Source code in titan/model.py def die_and_replace ( self ): \"\"\" Let agents die and replace the dead agent with a new agent randomly. \"\"\" # die stage for agent in self . pop . all_agents : # agent incarcerated, don't evaluate for death if agent . incar . active : continue # death rate per 1 person-month p = ( prob . get_death_rate ( agent . hiv . active , agent . hiv . aids , agent . drug_type , agent . sex_type , agent . haart . adherent , agent . race , agent . location , self . params . model . time . steps_per_year , ) * self . calibration . mortality ) if self . run_random . random () < p : self . deaths . append ( agent ) # End all existing relationships for rel in copy ( agent . relationships ): rel . progress ( force = True ) self . pop . remove_relationship ( rel ) # replace stage for agent in self . deaths : # mark agent component as -1 (no componenet) agent . component = \"-1\" # Remove agent from agent class and sub-sets self . pop . remove_agent ( agent ) new_agent = self . pop . create_agent ( agent . location , agent . race , self . time , agent . sex_type , agent . drug_type ) self . pop . add_agent ( new_agent ) make_agent_zero ( self ) Identify an agent as agent zero and HIV convert them Source code in titan/model.py def make_agent_zero ( self ): \"\"\" Identify an agent as agent zero and HIV convert them \"\"\" bonds = [ # Find what bond_types have the allowed interaction bond for bond , act_type in self . params . classes . bond_types . items () if self . params . agent_zero . interaction_type in act_type . acts_allowed ] max_partners = 0 max_agent = None zero_eligible = [] for agent in self . pop . all_agents : num_partners = agent . get_num_partners ( bond_types = bonds ) if num_partners >= self . params . agent_zero . num_partners : zero_eligible . append ( agent ) if num_partners > max_partners : max_partners = num_partners max_agent = agent agent_zero = utils . safe_random_choice ( zero_eligible , self . run_random ) if agent_zero : # if eligible agent, make agent 0 logging . info ( f \" \\t Agent zero selected: { agent_zero } \" ) zero_attr = getattr ( agent_zero , self . params . agent_zero . exposure ) zero_attr . convert ( self ) elif self . params . agent_zero . fallback and max_agent is not None : logging . info ( f \" \\t Fallback agent zero selected: { agent_zero } \" ) zero_attr = getattr ( max_agent , self . params . agent_zero . exposure ) zero_attr . convert ( self ) else : raise ValueError ( \"No agent zero!\" ) print_stats ( self , stat , outdir ) Create/update all of the reports defined in the params Source code in titan/model.py def print_stats ( self , stat : Dict [ str , Dict [ str , int ]], outdir : str ): \"\"\" Create/update all of the reports defined in the params \"\"\" for report in self . params . outputs . reports : printer = getattr ( ao , report ) printer ( self . id , self . time , self . run_seed , self . pop . pop_seed , stat , self . params , outdir , ) # network-based reports if ( self . time % self . params . outputs . print_frequency == 0 and self . params . model . network . enable ): network_outdir = os . path . join ( outdir , \"network\" ) if self . params . outputs . network . calc_component_stats : ao . print_components ( self . id , self . time , self . run_seed , self . pop . pop_seed , self . pop . connected_components (), network_outdir , ) if self . params . outputs . network . calc_network_stats : ao . write_network_stats ( self . pop . graph , network_outdir , self . id , self . time ) if self . params . outputs . network . edge_list : ao . write_graph_edgelist ( self . pop . graph , network_outdir , self . id , self . time ) run ( self , outdir ) Runs the model for the number of time steps defined in params, at each time step does: Increments time Takes one step Resets trackers Parameters: Name Type Description Default outdir str path to directory where results should be saved required Source code in titan/model.py def run ( self , outdir : str ): \"\"\" Runs the model for the number of time steps defined in params, at each time step does: 1. Increments time 2. Takes one step 3. Resets trackers args: outdir: path to directory where results should be saved \"\"\" # make sure initial state of things get printed stats = ao . get_stats ( self . pop . all_agents , self . deaths , self . params , self . exposures , self . features , self . time , ) self . print_stats ( stats , outdir ) if self . params . model . time . burn_steps > 0 : logging . info ( \" ===! Start Burn Loop !===\" ) # time starts at negative burn steps, model run starts at t = 1 while self . time < self . params . model . time . num_steps : if self . time == 0 : if self . params . model . time . burn_steps > 0 : logging . info ( \" ===! Burn Loop Complete !===\" ) logging . info ( \" ===! Start Main Loop !===\" ) self . time += 1 self . step ( outdir ) self . reset_trackers () logging . info ( \" ===! Main Loop Complete !===\" ) step ( self , outdir ) A single time step in the model: Perform timeline_scaling updates to params if needed Update all agents Write/update reports with this timestep's data Parameters: Name Type Description Default outdir str path to directory where reports should be saved required Source code in titan/model.py def step ( self , outdir : str ): \"\"\" A single time step in the model: 1. Perform timeline_scaling updates to params if needed 2. Update all agents 3. Write/update reports with this timestep's data args: outdir: path to directory where reports should be saved \"\"\" logging . info ( f \" \\n .: TIME { self . time } \" ) logging . info ( \" STARTING HIV count: {} Total Incarcerated: {} HR+: {} \" \"PrEP: {} \" . format ( len ( exposures . HIV . agents ), sum ([ 1 for a in self . pop . all_agents if a . incar . active ]), # type: ignore[attr-defined] sum ([ 1 for a in self . pop . all_agents if a . high_risk . active ]), # type: ignore[attr-defined] sum ([ 1 for a in self . pop . all_agents if a . prep . active ]), # type: ignore[attr-defined] ) ) self . timeline_scaling () self . update_all_agents () stats = ao . get_stats ( self . pop . all_agents , self . deaths , self . params , self . exposures , self . features , self . time , ) self . print_stats ( stats , outdir ) logging . info ( f \"Number of relationships: { len ( self . pop . relationships ) } \" ) self . pop . all_agents . print_subsets ( logging . info ) timeline_scaling ( self ) Scale/un-scale any params with timeline_scaling definitions per their definition. Applied to all parameters (main model, and location specific). Source code in titan/model.py def timeline_scaling ( self ): \"\"\" Scale/un-scale any params with timeline_scaling definitions per their definition. Applied to all parameters (main model, and location specific). \"\"\" if not self . params . features . timeline_scaling : return None # gather all of the param objectss to be scaled params_set = [ self . params ] for location in self . pop . geography . locations . values (): params_set . append ( location . params ) # iterate over each param and update the values if the time is right for params in params_set : for defn in params . timeline_scaling . timeline . values (): param = defn . parameter if param != \"ts_default\" : if defn . start_time == self . time : logging . info ( f \"timeline scaling - { param } \" ) utils . scale_param ( params , param , defn . scalar ) elif defn . stop_time == self . time : logging . info ( f \"timeline un-scaling - { param } \" ) utils . scale_param ( params , param , 1 / defn . scalar ) update_agent ( self , agent ) Update an agent at the given model timestep. Update the agent's status for: * age * all exposures * all features (agent level) Source code in titan/model.py def update_agent ( self , agent ): \"\"\" Update an agent at the given model timestep. Update the agent's status for: * age * all exposures * all features (agent level) \"\"\" # happy birthday agents! if self . time > 0 and ( self . time % self . params . model . time . steps_per_year ) == 0 : agent . age += 1 for exposure in self . exposures : agent_feature = getattr ( agent , exposure . name ) agent_feature . update_agent ( self ) for feature in self . features : agent_feature = getattr ( agent , feature . name ) agent_feature . update_agent ( self ) update_all_agents ( self ) The core of the model. For a time step, update all of the agents and relationships: End relationships with no remaining duration Agent death/replacement Agent migration (if enabled) Update partner assignments (create new relationships as needed) Create an agent zero (if enabled and the time is right) Agents in relationships interact Update features at the population level Update each agent's status for: age all exposures all features (agent level) Source code in titan/model.py def update_all_agents ( self ): \"\"\" The core of the model. For a time step, update all of the agents and relationships: 1. End relationships with no remaining duration 2. Agent death/replacement 3. Agent migration (if enabled) 4. Update partner assignments (create new relationships as needed) 5. Create an agent zero (if enabled and the time is right) 6. Agents in relationships interact 7. Update features at the population level 8. Update each agent's status for: * age * all exposures * all features (agent level) \"\"\" # If static network, ignore relationship progression if not self . params . features . static_network : for rel in copy ( self . pop . relationships ): if rel . progress (): self . pop . remove_relationship ( rel ) if self . params . features . die_and_replace : self . die_and_replace () if self . params . location . migration . enabled : self . pop . migrate () if not self . params . features . static_network : self . pop . update_partner_assignments ( t = self . time ) # If agent zero enabled, create agent zero at the beginning of main loop. if ( self . time == self . params . agent_zero . start_time and self . params . features . agent_zero ): self . make_agent_zero () for rel in self . pop . relationships : self . agents_interact ( rel ) for feature in self . features : feature . update_pop ( self ) for agent in self . pop . all_agents : self . update_agent ( agent )","title":"Model"},{"location":"api/model/#titan","text":"The TITAN class is used to model agent interactions as they progress through time. The model can be run on an existing Population or it can create a Population during its construction. The most common entry point to the model is run , which will run the model for all time steps. To run step by step, step can be iterated through instead, just be sure to reset_trackers between step s.","title":"TITAN"},{"location":"api/model/#titan.model.TITAN.__init__","text":"This is the core class used to simulate the spread of exposures through a relationship based network. Parameters: Name Type Description Default params ObjMap the parameter object for this model required pop Optional[population.Population] an initialized population to run the model on None Source code in titan/model.py def __init__ ( self , params : ObjMap , pop : Optional [ \"population.Population\" ] = None , ): \"\"\" This is the core class used to simulate the spread of exposures through a relationship based network. args: params: the parameter object for this model pop: an initialized population to run the model on \"\"\" self . id = nanoid . generate ( size = 8 ) self . params = params # pre-fetch commonly used param sub-sets for performance self . calibration = params . calibration utils . set_up_logging ( params ) logging . info ( f \"Model ID: { self . id } \" ) logging . info ( \"=== Begin Initialization Protocol === \\n \" ) if pop is None : logging . info ( \" Generating new population\" ) self . pop = population . Population ( params ) else : logging . info ( \" Using provided population\" ) self . pop = pop self . time = - 1 * self . params . model . time . burn_steps # burn is negative time self . features = [ feature for feature in features . BaseFeature . __subclasses__ () if self . params . features [ feature . name ] ] # set up the in-scope exposures self . exposures = [ exposure for exposure in exposures . BaseExposure . __subclasses__ () if self . params . exposures [ exposure . name ] ] self . interactions = { interaction . name : interaction for interaction in interactions . BaseInteraction . __subclasses__ () } # Set seed format. 0: pure random, else: fixed value self . run_seed = utils . get_check_rand_int ( params . model . seed . run ) logging . info ( f \" Run seed was set to: { self . run_seed } \" ) self . run_random = random . Random ( self . run_seed ) self . np_random = np . random . default_rng ( self . run_seed ) random . seed ( self . run_seed ) logging . info (( \" FIRST RANDOM CALL {} \" . format ( random . randint ( 0 , 100 )))) logging . info ( \" Resetting death count\" ) self . deaths : List [ \"ag.Agent\" ] = [] # Number of death logging . info ( \" \\n === Initialization Protocol Finished ===\" )","title":"__init__()"},{"location":"api/model/#titan.model.TITAN.agents_interact","text":"Let an agent interact with a partner. Based on the interaction types of the relationship, interact in the following ways: Peer Change Agent Injection Sex Parameters: Name Type Description Default rel ag.Relationship The relationship that the agents interact in required Source code in titan/model.py def agents_interact ( self , rel : \"ag.Relationship\" ): \"\"\" Let an agent interact with a partner. Based on the interaction types of the relationship, interact in the following ways: * Peer Change Agent * Injection * Sex args: rel : The relationship that the agents interact in \"\"\" interaction_types = self . params . classes . bond_types [ rel . bond_type ] . acts_allowed # If either agent is incarcerated, skip their interaction if rel . agent1 . incar . active or rel . agent2 . incar . active : # type: ignore[attr-defined] return for interaction_type in interaction_types : interaction = self . interactions [ interaction_type ] interaction . interact ( self , rel )","title":"agents_interact()"},{"location":"api/model/#titan.model.TITAN.die_and_replace","text":"Let agents die and replace the dead agent with a new agent randomly. Source code in titan/model.py def die_and_replace ( self ): \"\"\" Let agents die and replace the dead agent with a new agent randomly. \"\"\" # die stage for agent in self . pop . all_agents : # agent incarcerated, don't evaluate for death if agent . incar . active : continue # death rate per 1 person-month p = ( prob . get_death_rate ( agent . hiv . active , agent . hiv . aids , agent . drug_type , agent . sex_type , agent . haart . adherent , agent . race , agent . location , self . params . model . time . steps_per_year , ) * self . calibration . mortality ) if self . run_random . random () < p : self . deaths . append ( agent ) # End all existing relationships for rel in copy ( agent . relationships ): rel . progress ( force = True ) self . pop . remove_relationship ( rel ) # replace stage for agent in self . deaths : # mark agent component as -1 (no componenet) agent . component = \"-1\" # Remove agent from agent class and sub-sets self . pop . remove_agent ( agent ) new_agent = self . pop . create_agent ( agent . location , agent . race , self . time , agent . sex_type , agent . drug_type ) self . pop . add_agent ( new_agent )","title":"die_and_replace()"},{"location":"api/model/#titan.model.TITAN.make_agent_zero","text":"Identify an agent as agent zero and HIV convert them Source code in titan/model.py def make_agent_zero ( self ): \"\"\" Identify an agent as agent zero and HIV convert them \"\"\" bonds = [ # Find what bond_types have the allowed interaction bond for bond , act_type in self . params . classes . bond_types . items () if self . params . agent_zero . interaction_type in act_type . acts_allowed ] max_partners = 0 max_agent = None zero_eligible = [] for agent in self . pop . all_agents : num_partners = agent . get_num_partners ( bond_types = bonds ) if num_partners >= self . params . agent_zero . num_partners : zero_eligible . append ( agent ) if num_partners > max_partners : max_partners = num_partners max_agent = agent agent_zero = utils . safe_random_choice ( zero_eligible , self . run_random ) if agent_zero : # if eligible agent, make agent 0 logging . info ( f \" \\t Agent zero selected: { agent_zero } \" ) zero_attr = getattr ( agent_zero , self . params . agent_zero . exposure ) zero_attr . convert ( self ) elif self . params . agent_zero . fallback and max_agent is not None : logging . info ( f \" \\t Fallback agent zero selected: { agent_zero } \" ) zero_attr = getattr ( max_agent , self . params . agent_zero . exposure ) zero_attr . convert ( self ) else : raise ValueError ( \"No agent zero!\" )","title":"make_agent_zero()"},{"location":"api/model/#titan.model.TITAN.print_stats","text":"Create/update all of the reports defined in the params Source code in titan/model.py def print_stats ( self , stat : Dict [ str , Dict [ str , int ]], outdir : str ): \"\"\" Create/update all of the reports defined in the params \"\"\" for report in self . params . outputs . reports : printer = getattr ( ao , report ) printer ( self . id , self . time , self . run_seed , self . pop . pop_seed , stat , self . params , outdir , ) # network-based reports if ( self . time % self . params . outputs . print_frequency == 0 and self . params . model . network . enable ): network_outdir = os . path . join ( outdir , \"network\" ) if self . params . outputs . network . calc_component_stats : ao . print_components ( self . id , self . time , self . run_seed , self . pop . pop_seed , self . pop . connected_components (), network_outdir , ) if self . params . outputs . network . calc_network_stats : ao . write_network_stats ( self . pop . graph , network_outdir , self . id , self . time ) if self . params . outputs . network . edge_list : ao . write_graph_edgelist ( self . pop . graph , network_outdir , self . id , self . time )","title":"print_stats()"},{"location":"api/model/#titan.model.TITAN.run","text":"Runs the model for the number of time steps defined in params, at each time step does: Increments time Takes one step Resets trackers Parameters: Name Type Description Default outdir str path to directory where results should be saved required Source code in titan/model.py def run ( self , outdir : str ): \"\"\" Runs the model for the number of time steps defined in params, at each time step does: 1. Increments time 2. Takes one step 3. Resets trackers args: outdir: path to directory where results should be saved \"\"\" # make sure initial state of things get printed stats = ao . get_stats ( self . pop . all_agents , self . deaths , self . params , self . exposures , self . features , self . time , ) self . print_stats ( stats , outdir ) if self . params . model . time . burn_steps > 0 : logging . info ( \" ===! Start Burn Loop !===\" ) # time starts at negative burn steps, model run starts at t = 1 while self . time < self . params . model . time . num_steps : if self . time == 0 : if self . params . model . time . burn_steps > 0 : logging . info ( \" ===! Burn Loop Complete !===\" ) logging . info ( \" ===! Start Main Loop !===\" ) self . time += 1 self . step ( outdir ) self . reset_trackers () logging . info ( \" ===! Main Loop Complete !===\" )","title":"run()"},{"location":"api/model/#titan.model.TITAN.step","text":"A single time step in the model: Perform timeline_scaling updates to params if needed Update all agents Write/update reports with this timestep's data Parameters: Name Type Description Default outdir str path to directory where reports should be saved required Source code in titan/model.py def step ( self , outdir : str ): \"\"\" A single time step in the model: 1. Perform timeline_scaling updates to params if needed 2. Update all agents 3. Write/update reports with this timestep's data args: outdir: path to directory where reports should be saved \"\"\" logging . info ( f \" \\n .: TIME { self . time } \" ) logging . info ( \" STARTING HIV count: {} Total Incarcerated: {} HR+: {} \" \"PrEP: {} \" . format ( len ( exposures . HIV . agents ), sum ([ 1 for a in self . pop . all_agents if a . incar . active ]), # type: ignore[attr-defined] sum ([ 1 for a in self . pop . all_agents if a . high_risk . active ]), # type: ignore[attr-defined] sum ([ 1 for a in self . pop . all_agents if a . prep . active ]), # type: ignore[attr-defined] ) ) self . timeline_scaling () self . update_all_agents () stats = ao . get_stats ( self . pop . all_agents , self . deaths , self . params , self . exposures , self . features , self . time , ) self . print_stats ( stats , outdir ) logging . info ( f \"Number of relationships: { len ( self . pop . relationships ) } \" ) self . pop . all_agents . print_subsets ( logging . info )","title":"step()"},{"location":"api/model/#titan.model.TITAN.timeline_scaling","text":"Scale/un-scale any params with timeline_scaling definitions per their definition. Applied to all parameters (main model, and location specific). Source code in titan/model.py def timeline_scaling ( self ): \"\"\" Scale/un-scale any params with timeline_scaling definitions per their definition. Applied to all parameters (main model, and location specific). \"\"\" if not self . params . features . timeline_scaling : return None # gather all of the param objectss to be scaled params_set = [ self . params ] for location in self . pop . geography . locations . values (): params_set . append ( location . params ) # iterate over each param and update the values if the time is right for params in params_set : for defn in params . timeline_scaling . timeline . values (): param = defn . parameter if param != \"ts_default\" : if defn . start_time == self . time : logging . info ( f \"timeline scaling - { param } \" ) utils . scale_param ( params , param , defn . scalar ) elif defn . stop_time == self . time : logging . info ( f \"timeline un-scaling - { param } \" ) utils . scale_param ( params , param , 1 / defn . scalar )","title":"timeline_scaling()"},{"location":"api/model/#titan.model.TITAN.update_agent","text":"Update an agent at the given model timestep. Update the agent's status for: * age * all exposures * all features (agent level) Source code in titan/model.py def update_agent ( self , agent ): \"\"\" Update an agent at the given model timestep. Update the agent's status for: * age * all exposures * all features (agent level) \"\"\" # happy birthday agents! if self . time > 0 and ( self . time % self . params . model . time . steps_per_year ) == 0 : agent . age += 1 for exposure in self . exposures : agent_feature = getattr ( agent , exposure . name ) agent_feature . update_agent ( self ) for feature in self . features : agent_feature = getattr ( agent , feature . name ) agent_feature . update_agent ( self )","title":"update_agent()"},{"location":"api/model/#titan.model.TITAN.update_all_agents","text":"The core of the model. For a time step, update all of the agents and relationships: End relationships with no remaining duration Agent death/replacement Agent migration (if enabled) Update partner assignments (create new relationships as needed) Create an agent zero (if enabled and the time is right) Agents in relationships interact Update features at the population level Update each agent's status for: age all exposures all features (agent level) Source code in titan/model.py def update_all_agents ( self ): \"\"\" The core of the model. For a time step, update all of the agents and relationships: 1. End relationships with no remaining duration 2. Agent death/replacement 3. Agent migration (if enabled) 4. Update partner assignments (create new relationships as needed) 5. Create an agent zero (if enabled and the time is right) 6. Agents in relationships interact 7. Update features at the population level 8. Update each agent's status for: * age * all exposures * all features (agent level) \"\"\" # If static network, ignore relationship progression if not self . params . features . static_network : for rel in copy ( self . pop . relationships ): if rel . progress (): self . pop . remove_relationship ( rel ) if self . params . features . die_and_replace : self . die_and_replace () if self . params . location . migration . enabled : self . pop . migrate () if not self . params . features . static_network : self . pop . update_partner_assignments ( t = self . time ) # If agent zero enabled, create agent zero at the beginning of main loop. if ( self . time == self . params . agent_zero . start_time and self . params . features . agent_zero ): self . make_agent_zero () for rel in self . pop . relationships : self . agents_interact ( rel ) for feature in self . features : feature . update_pop ( self ) for agent in self . pop . all_agents : self . update_agent ( agent )","title":"update_all_agents()"},{"location":"api/partnering/","text":"get_mean_rel_duration ( params ) Find the average partnership duration by bond type Parameters: Name Type Description Default params parse_params.ObjMap The current model's parameters required Source code in titan/partnering.py def get_mean_rel_duration ( params : \"parse_params.ObjMap\" ): \"\"\" Find the average partnership duration by bond type args: params: The current model's parameters \"\"\" mean_rel_duration : Dict [ str , Dict ] = {} for bond in params . partnership . duration : mean_rel_duration [ bond ] = {} for race in params . classes . races : if params . partnership . duration [ bond ][ race ] . type == \"bins\" : weights = [] vals = [] dur_bins = params . partnership . duration [ bond ][ race ] . bins for bins in dur_bins : if bins > 1 : weights . append ( dur_bins [ bins ] . prob - dur_bins [ bins - 1 ] . prob ) else : weights . append ( dur_bins [ bins ] . prob ) vals . append ( np . average ([ dur_bins [ bins ] . min , dur_bins [ bins ] . max ])) mean_rel_duration [ bond ][ race ] = np . average ( vals , weights = weights ) else : mean_rel_duration [ bond ][ race ] = params . partnership . duration [ bond ][ race ] . distribution . mean assert ( mean_rel_duration [ bond ][ race ] > 0 ), \"All bonds must have a positive duration!\" return mean_rel_duration get_partnership_duration ( params , rand_gen , bond_type , race ) Get duration of a relationship drawn from bins or a distribution per the params [params.partnership.duration] Parameters: Name Type Description Default params parse_params.ObjMap model parameters required rand_gen np random number generator required bond_type str type of bond for the relationship whose duration is being determined required Returns: Type Description int number of time steps the partnership should endure Source code in titan/partnering.py def get_partnership_duration ( params : \"parse_params.ObjMap\" , rand_gen , bond_type : str , race : Optional [ str ] ) -> int : \"\"\" Get duration of a relationship drawn from bins or a distribution per the params [params.partnership.duration] args: params: model parameters rand_gen: np random number generator bond_type: type of bond for the relationship whose duration is being determined returns: number of time steps the partnership should endure \"\"\" if params . partnership . duration [ bond_type ][ race ] . type == \"bins\" : dur_info = params . partnership . duration [ bond_type ][ race ] . bins i = utils . get_independent_bin ( rand_gen , dur_info ) duration = utils . safe_random_int ( dur_info [ i ] . min , dur_info [ i ] . max , rand_gen ) else : dist = params . partnership . duration [ bond_type ][ race ] . distribution duration = int ( utils . safe_dist ( dist , rand_gen )) return duration select_partner ( agent , partnerable_agents , sex_partners , pwid_agents , params , rand_gen , bond_type ) Get a partner for the agent. Parameters: Name Type Description Default agent agent.Agent agent in need of a partner required partnerable_agents Set[agent.Agent] agents that can be selected as a partner required sex_partners Dict mapping from sex_type to agents in the population that can sleep with that sex_type required pwid_agents agent.AgentSet agents with drug_type===\"Inj\" required params parse_params.ObjMap model parameters required rand_gen random number generator required bond_type str type of relationship that is being formed with the partner required Returns: Type Description Optional[agent.Agent] new partner or None Source code in titan/partnering.py def select_partner ( agent : \"agent.Agent\" , partnerable_agents : Set [ \"agent.Agent\" ], sex_partners : Dict , pwid_agents : \"agent.AgentSet\" , params : \"parse_params.ObjMap\" , rand_gen , bond_type : str , ) -> Optional [ \"agent.Agent\" ]: \"\"\" Get a partner for the agent. args: agent : agent in need of a partner partnerable_agents: agents that can be selected as a partner sex_partners: mapping from sex_type to agents in the population that can sleep with that sex_type pwid_agents: agents with `drug_type===\"Inj\"` params: model parameters rand_gen: random number generator bond_type: type of relationship that is being formed with the partner returns: new partner or `None` \"\"\" eligible = copy ( partnerable_agents ) eligible -= agent . get_partners () eligible -= { agent } acts_allowed = params . classes . bond_types [ bond_type ] . acts_allowed if \"injection\" in acts_allowed : eligible &= pwid_agents . members if \"sex\" in acts_allowed : eligible &= sex_partners [ agent . sex_type ] # short circuit to avoid attempting to assort with no eligible partners if not eligible : return None if params . features . assort_mix : match_fns = get_match_fns ( params . assort_mix . values (), agent , bond_type , rand_gen ) # if no definitions match this agent, don't try to assort if len ( match_fns ) > 0 : for partner in utils . safe_shuffle ( eligible , rand_gen ): if is_assortable ( partner , match_fns ): return partner return None return utils . safe_random_choice ( eligible , rand_gen ) sex_possible ( agent_sex_type , partner_sex_type , sex_types ) Determine if sex is possible. Parameters: Name Type Description Default agent_sex_type str name of agent's sex type required partner_sex_type str name of partner's sex type required sex_types parse_params.ObjMap params defining in scope sex types required Returns: Type Description bool whether sex is possible between agents of these sex types Source code in titan/partnering.py @utils . memo def sex_possible ( agent_sex_type : str , partner_sex_type : str , sex_types : \"parse_params.ObjMap\" ) -> bool : \"\"\" Determine if sex is possible. args: agent_sex_type: name of agent's sex type partner_sex_type: name of partner's sex type sex_types: params defining in scope sex types returns: whether sex is possible between agents of these sex types \"\"\" # Check input if agent_sex_type not in sex_types : raise ValueError ( f \"Invalid agent_sex_type! { agent_sex_type } \" ) if partner_sex_type not in sex_types : raise ValueError ( f \"Invalid partner_sex_type! { partner_sex_type } \" ) agent_match = agent_sex_type in sex_types [ partner_sex_type ] . sleeps_with partner_match = partner_sex_type in sex_types [ agent_sex_type ] . sleeps_with return agent_match and partner_match","title":"Partnering"},{"location":"api/partnering/#titan.partnering.get_mean_rel_duration","text":"Find the average partnership duration by bond type Parameters: Name Type Description Default params parse_params.ObjMap The current model's parameters required Source code in titan/partnering.py def get_mean_rel_duration ( params : \"parse_params.ObjMap\" ): \"\"\" Find the average partnership duration by bond type args: params: The current model's parameters \"\"\" mean_rel_duration : Dict [ str , Dict ] = {} for bond in params . partnership . duration : mean_rel_duration [ bond ] = {} for race in params . classes . races : if params . partnership . duration [ bond ][ race ] . type == \"bins\" : weights = [] vals = [] dur_bins = params . partnership . duration [ bond ][ race ] . bins for bins in dur_bins : if bins > 1 : weights . append ( dur_bins [ bins ] . prob - dur_bins [ bins - 1 ] . prob ) else : weights . append ( dur_bins [ bins ] . prob ) vals . append ( np . average ([ dur_bins [ bins ] . min , dur_bins [ bins ] . max ])) mean_rel_duration [ bond ][ race ] = np . average ( vals , weights = weights ) else : mean_rel_duration [ bond ][ race ] = params . partnership . duration [ bond ][ race ] . distribution . mean assert ( mean_rel_duration [ bond ][ race ] > 0 ), \"All bonds must have a positive duration!\" return mean_rel_duration","title":"get_mean_rel_duration()"},{"location":"api/partnering/#titan.partnering.get_partnership_duration","text":"Get duration of a relationship drawn from bins or a distribution per the params [params.partnership.duration] Parameters: Name Type Description Default params parse_params.ObjMap model parameters required rand_gen np random number generator required bond_type str type of bond for the relationship whose duration is being determined required Returns: Type Description int number of time steps the partnership should endure Source code in titan/partnering.py def get_partnership_duration ( params : \"parse_params.ObjMap\" , rand_gen , bond_type : str , race : Optional [ str ] ) -> int : \"\"\" Get duration of a relationship drawn from bins or a distribution per the params [params.partnership.duration] args: params: model parameters rand_gen: np random number generator bond_type: type of bond for the relationship whose duration is being determined returns: number of time steps the partnership should endure \"\"\" if params . partnership . duration [ bond_type ][ race ] . type == \"bins\" : dur_info = params . partnership . duration [ bond_type ][ race ] . bins i = utils . get_independent_bin ( rand_gen , dur_info ) duration = utils . safe_random_int ( dur_info [ i ] . min , dur_info [ i ] . max , rand_gen ) else : dist = params . partnership . duration [ bond_type ][ race ] . distribution duration = int ( utils . safe_dist ( dist , rand_gen )) return duration","title":"get_partnership_duration()"},{"location":"api/partnering/#titan.partnering.select_partner","text":"Get a partner for the agent. Parameters: Name Type Description Default agent agent.Agent agent in need of a partner required partnerable_agents Set[agent.Agent] agents that can be selected as a partner required sex_partners Dict mapping from sex_type to agents in the population that can sleep with that sex_type required pwid_agents agent.AgentSet agents with drug_type===\"Inj\" required params parse_params.ObjMap model parameters required rand_gen random number generator required bond_type str type of relationship that is being formed with the partner required Returns: Type Description Optional[agent.Agent] new partner or None Source code in titan/partnering.py def select_partner ( agent : \"agent.Agent\" , partnerable_agents : Set [ \"agent.Agent\" ], sex_partners : Dict , pwid_agents : \"agent.AgentSet\" , params : \"parse_params.ObjMap\" , rand_gen , bond_type : str , ) -> Optional [ \"agent.Agent\" ]: \"\"\" Get a partner for the agent. args: agent : agent in need of a partner partnerable_agents: agents that can be selected as a partner sex_partners: mapping from sex_type to agents in the population that can sleep with that sex_type pwid_agents: agents with `drug_type===\"Inj\"` params: model parameters rand_gen: random number generator bond_type: type of relationship that is being formed with the partner returns: new partner or `None` \"\"\" eligible = copy ( partnerable_agents ) eligible -= agent . get_partners () eligible -= { agent } acts_allowed = params . classes . bond_types [ bond_type ] . acts_allowed if \"injection\" in acts_allowed : eligible &= pwid_agents . members if \"sex\" in acts_allowed : eligible &= sex_partners [ agent . sex_type ] # short circuit to avoid attempting to assort with no eligible partners if not eligible : return None if params . features . assort_mix : match_fns = get_match_fns ( params . assort_mix . values (), agent , bond_type , rand_gen ) # if no definitions match this agent, don't try to assort if len ( match_fns ) > 0 : for partner in utils . safe_shuffle ( eligible , rand_gen ): if is_assortable ( partner , match_fns ): return partner return None return utils . safe_random_choice ( eligible , rand_gen )","title":"select_partner()"},{"location":"api/partnering/#titan.partnering.sex_possible","text":"Determine if sex is possible. Parameters: Name Type Description Default agent_sex_type str name of agent's sex type required partner_sex_type str name of partner's sex type required sex_types parse_params.ObjMap params defining in scope sex types required Returns: Type Description bool whether sex is possible between agents of these sex types Source code in titan/partnering.py @utils . memo def sex_possible ( agent_sex_type : str , partner_sex_type : str , sex_types : \"parse_params.ObjMap\" ) -> bool : \"\"\" Determine if sex is possible. args: agent_sex_type: name of agent's sex type partner_sex_type: name of partner's sex type sex_types: params defining in scope sex types returns: whether sex is possible between agents of these sex types \"\"\" # Check input if agent_sex_type not in sex_types : raise ValueError ( f \"Invalid agent_sex_type! { agent_sex_type } \" ) if partner_sex_type not in sex_types : raise ValueError ( f \"Invalid partner_sex_type! { partner_sex_type } \" ) agent_match = agent_sex_type in sex_types [ partner_sex_type ] . sleeps_with partner_match = partner_sex_type in sex_types [ agent_sex_type ] . sleeps_with return agent_match and partner_match","title":"sex_possible()"},{"location":"api/population/","text":"Population The Population class is used to represent the population of agents the model is running on. On construction, it stochastically creates the population described in the params . At its core, it is a graph with nodes ( all_agents ) and edges ( relationships ), it can be formally backed by a NetworkX graph by enabling the graph in the prams file. This allows for some graph-specific logic to be applied throughout the running of the model (e.g. trimming components, writing network statistics). __init__ ( self , params , id = None ) special Initialize Population object. Parameters: Name Type Description Default params parse_params.ObjMap Model parameters required id Optional[str] 8 character identifier for a model None Source code in titan/population.py def __init__ ( self , params : \"parse_params.ObjMap\" , id : Optional [ str ] = None ): \"\"\" Initialize Population object. args: params : Model parameters id: 8 character identifier for a model \"\"\" if id is None : self . id = nanoid . generate ( size = 8 ) else : self . id = id utils . set_up_logging ( params ) logging . info ( f \"Population ID: { self . id } \" ) self . pop_seed = utils . get_check_rand_int ( params . model . seed . ppl ) # Init RNG for population creation to pop_seed self . pop_random = random . Random ( self . pop_seed ) self . np_random = np . random . default_rng ( self . pop_seed ) self . enable_graph = params . model . network . enable self . components : List = [] if self . enable_graph : self . graph = nx . Graph () else : self . graph = None self . params = params # set up the in-scope exposures self . exposures = [ exposure for exposure in exposures . BaseExposure . __subclasses__ () if self . params . exposures [ exposure . name ] ] # initialize the class level items for exposure in self . exposures : exposure . init_class ( params ) # set up the in-scope features self . features = [ feature for feature in features . BaseFeature . __subclasses__ () if self . params . features [ feature . name ] ] # initialize the class level items for feature in self . features : feature . init_class ( params ) # set up the population's locations and edges self . geography = location . Geography ( params ) # All agent set list self . all_agents = ag . AgentSet ( \"AllAgents\" ) # pwid agents (performance for partnering) self . pwid_agents = ag . AgentSet ( \"PWID\" , parent = self . all_agents ) # agents who can take on a partner self . partnerable_agents : Dict [ str , Set [ \"ag.Agent\" ]] = {} for bond_type in self . params . classes . bond_types . keys (): self . partnerable_agents [ bond_type ] = set () # who can sleep with whom self . sex_partners : Dict [ str , Set [ \"ag.Agent\" ]] = {} for sex_type in self . params . classes . sex_types . keys (): self . sex_partners [ sex_type ] = set () self . relationships : Set [ \"ag.Relationship\" ] = set () # find average partnership durations self . mean_rel_duration : Dict [ str , Dict ] = partnering . get_mean_rel_duration ( self . params ) logging . info ( \" Creating agents\" ) # for each location in the population, create agents per that location's demographics init_time = - 1 * self . params . model . time . burn_steps for loc in self . geography . locations . values (): for race in params . classes . races : for i in range ( round ( params . model . num_pop * loc . ppl * loc . params . demographics [ race ] . ppl ) ): if self . all_agents . num_members () >= self . params . model . num_pop : logging . warning ( \"WARNING: not adding agent to population - too many agents\" ) break agent = self . create_agent ( loc , race , init_time ) self . add_agent ( agent ) # initialize relationships logging . info ( \" Creating Relationships\" ) self . update_partner_assignments ( 0 ) add_agent ( self , agent ) Adds an agent to the population Parameters: Name Type Description Default agent ag.Agent The agent to be added required Source code in titan/population.py def add_agent ( self , agent : \"ag.Agent\" ): \"\"\" Adds an agent to the population args: agent : The agent to be added \"\"\" # Add to all agent set self . all_agents . add_agent ( agent ) if agent . drug_type == \"Inj\" : self . pwid_agents . add_agent ( agent ) # who can sleep with this agent for sex_type in self . params . classes . sex_types [ agent . sex_type ] . sleeps_with : self . sex_partners [ sex_type ] . add ( agent ) if self . enable_graph : self . graph . add_node ( agent ) add_relationship ( self , rel ) Add a new relationship to the population. Parameters: Name Type Description Default rel ag.Relationship The Relationship to be added required Source code in titan/population.py def add_relationship ( self , rel : \"ag.Relationship\" ): \"\"\" Add a new relationship to the population. args: rel : The Relationship to be added \"\"\" self . relationships . add ( rel ) if self . enable_graph : self . graph . add_edge ( rel . agent1 , rel . agent2 , type = rel . bond_type ) connected_components ( self ) Get connected components in graph (if enabled) Returns: Type Description List list of connected components Source code in titan/population.py def connected_components ( self ) -> List : \"\"\" Get connected components in graph (if enabled) returns: list of connected components \"\"\" if self . enable_graph : return self . components else : raise ValueError ( \"Can't get connected_components, population doesn't have graph enabled.\" ) create_agent ( self , loc , race , time , sex_type = None , drug_type = None ) Create a new agent with randomly assigned attributes according to population demographics [params.demographics] Parameters: Name Type Description Default loc location.Location location the agent will live in required race str race of the new agent required time int current time step of the model required sex_type Optional[str] sex_type of the new agent None Returns: Type Description ag.Agent a new agent Source code in titan/population.py def create_agent ( self , loc : \"location.Location\" , race : str , time : int , sex_type : Optional [ str ] = None , drug_type : Optional [ str ] = None , ) -> \"ag.Agent\" : \"\"\" Create a new agent with randomly assigned attributes according to population demographics [params.demographics] args: loc: location the agent will live in race : race of the new agent time: current time step of the model sex_type : sex_type of the new agent returns: a new agent \"\"\" if sex_type is None : sex_type = utils . safe_random_choice ( loc . pop_weights [ race ][ \"values\" ], self . pop_random , weights = loc . pop_weights [ race ][ \"weights\" ], ) # no choice available if sex_type is None : raise ValueError ( \"Agent must have sex type\" ) # Determine drugtype if drug_type is None : drug_type = utils . safe_random_choice ( loc . drug_weights [ race ][ sex_type ][ \"values\" ], self . pop_random , weights = loc . drug_weights [ race ][ sex_type ][ \"weights\" ], ) # no choice available if drug_type is None : raise ValueError ( \"Agent must have drug type\" ) age , age_bin = self . get_age ( loc , race ) agent = ag . Agent ( sex_type , age , race , drug_type , loc ) agent . age_bin = age_bin sex_role = utils . safe_random_choice ( loc . role_weights [ race ][ sex_type ][ \"values\" ], self . pop_random , weights = loc . role_weights [ race ][ sex_type ][ \"weights\" ], ) if sex_role is None : raise ValueError ( \"Agent must have sex role\" ) else : agent . sex_role = sex_role agent_params = ( agent . location . params . demographics [ race ] . sex_type [ sex_type ] . drug_type [ drug_type ] ) for exposure in self . exposures : agent_feature = getattr ( agent , exposure . name ) agent_feature . init_agent ( self , time ) for bond , bond_def in loc . params . classes . bond_types . items (): agent . partners [ bond ] = set () dist_info = agent_params . num_partners [ bond ] agent . mean_num_partners [ bond ] = ceil ( utils . safe_dist ( dist_info , self . np_random ) * utils . safe_divide ( agent . location . params . calibration . sex . partner , self . mean_rel_duration [ bond ][ race ], ) ) # so not zero if added mid-year agent . target_partners [ bond ] = agent . mean_num_partners [ bond ] if \"injection\" in bond_def . acts_allowed : assert agent . drug_type == \"Inj\" or agent . mean_num_partners [ bond ] == 0 if agent . target_partners [ bond ] > 0 : self . partnerable_agents [ bond ] . add ( agent ) for feature in self . features : agent_feature = getattr ( agent , feature . name ) agent_feature . init_agent ( self , time ) return agent get_age ( self , loc , race ) Given the population characteristics, get a random age to assign to an agent given the race of that agent Parameters: Name Type Description Default race str race of the agent whose age is being generated required Returns: Type Description Tuple[int, int] age and the bin the age came from Source code in titan/population.py def get_age ( self , loc : \"location.Location\" , race : str ) -> Tuple [ int , int ]: \"\"\" Given the population characteristics, get a random age to assign to an agent given the race of that agent args: race : race of the agent whose age is being generated returns: age and the bin the age came from \"\"\" bins = loc . params . demographics [ race ] . age i = utils . get_independent_bin ( self . pop_random , bins ) age = self . pop_random . randrange ( bins [ i ] . min , bins [ i ] . max ) return age , i migrate ( self ) Have agents migrate between locations with probabilities defined in location.migration.matrix_file . Source code in titan/population.py def migrate ( self ): \"\"\" Have agents migrate between locations with probabilities defined in `location.migration.matrix_file`. \"\"\" m_attr = self . params . location . migration . attribute for a in self . all_agents : m_param = a . location . migration_weights if self . pop_random . random () < m_param [ \"prob\" ]: new_loc = utils . safe_random_choice ( m_param [ \"values\" ], self . pop_random , weights = m_param [ \"weights\" ], ) if m_attr == \"name\" : a . location = self . geography . locations [ new_loc ] elif m_attr == \"category\" : a . location = utils . safe_random_choice ( self . geography . categories [ new_loc ], self . pop_random ) remove_agent ( self , agent ) Remove an agent from the population. Parameters: Name Type Description Default agent ag.Agent Agent to remove required Source code in titan/population.py def remove_agent ( self , agent : \"ag.Agent\" ): \"\"\" Remove an agent from the population. args: agent : Agent to remove \"\"\" self . all_agents . remove_agent ( agent ) for partner_type in self . sex_partners : if agent in self . sex_partners [ partner_type ]: self . sex_partners [ partner_type ] . remove ( agent ) for exposure in self . exposures : agent_attr = getattr ( agent , exposure . name ) if agent_attr . active : exposure . remove_agent ( agent ) for feature in self . features : agent_attr = getattr ( agent , feature . name ) if agent_attr . active : feature . remove_agent ( agent ) if self . enable_graph : self . graph . remove_node ( agent ) for bond in self . partnerable_agents . values (): if agent in bond : bond . remove ( agent ) remove_relationship ( self , rel ) Remove a relationship from the population. Parameters: Name Type Description Default rel ag.Relationship Relationship to remove required Source code in titan/population.py def remove_relationship ( self , rel : \"ag.Relationship\" ): \"\"\" Remove a relationship from the population. args: rel : Relationship to remove \"\"\" self . relationships . remove ( rel ) # without this relationship, are agents partnerable again? self . update_partnerability ( rel . agent1 ) self . update_partnerability ( rel . agent2 ) if self . enable_graph : self . graph . remove_edge ( rel . agent1 , rel . agent2 ) trim_graph ( self ) Initialize network with graph-based algorithm for relationship adding/pruning Source code in titan/population.py def trim_graph ( self ): \"\"\" Initialize network with graph-based algorithm for relationship adding/pruning \"\"\" if self . params . model . network . type == \"comp_size\" : def trim_component ( component , max_size ): for agent in component . nodes : if ( self . pop_random . random () < self . params . calibration . network . trim . prob ): for rel in copy ( agent . relationships ): if len ( agent . relationships ) == 1 : break # Make sure that agents stay part of the # network by keeping one bond rel . progress ( force = True ) self . remove_relationship ( rel ) # recurse on new sub-components sub_comps = utils . connected_components ( component ) for sub_comp in sub_comps : if sub_comp . number_of_nodes () > max_size : trim_component ( component , max_size ) else : break components = self . connected_components () for comp in components : if ( comp . number_of_nodes () > self . params . model . network . component_size . max ): logging . info ( \"TOO BIG\" , comp , comp . number_of_nodes ()) trim_component ( comp , self . params . model . network . component_size . max ) logging . info ( f \" Total agents in graph: { self . graph . number_of_nodes () } \" ) update_agent_components ( self ) Update the component IDs associated with each agent based on the current state of the graph Source code in titan/population.py def update_agent_components ( self ): \"\"\" Update the component IDs associated with each agent based on the current state of the graph \"\"\" if self . enable_graph : self . components = utils . connected_components ( self . graph ) for id , component in enumerate ( self . components ): for agent in component . nodes : agent . component = str ( id ) self . params . classes . components = list ( map ( str , range ( - 1 , len ( self . components ))) ) update_agent_partners ( self , agent , bond_type , components ) Finds and bonds new partner. Creates relationship object for partnership, calcs partnership duration, adds it to the population, and adds to networkX graph if self.enable_graph is set True. Parameters: Name Type Description Default agent ag.Agent Agent that is seeking a new partner required bond_type str What type of bond the agent is seeking to make required Returns: Type Description bool True if no match was found for agent (used for retries) Source code in titan/population.py def update_agent_partners ( self , agent : \"ag.Agent\" , bond_type : str , components : List ) -> bool : \"\"\" Finds and bonds new partner. Creates relationship object for partnership, calcs partnership duration, adds it to the population, and adds to networkX graph if self.enable_graph is set True. args: agent: Agent that is seeking a new partner bond_type: What type of bond the agent is seeking to make returns: True if no match was found for agent (used for retries) \"\"\" partnerable_agents = self . partnerable_agents [ bond_type ] if ( self . pop_random . random () < self . params . partnership . network . same_component . prob and agent . has_partners () ): # find agent's component agent_component : Set [ \"ag.Agent\" ] = set () for comp in components : if agent in comp : agent_component = comp break partnerable_agents = partnerable_agents & agent_component partner = partnering . select_partner ( agent , partnerable_agents , self . sex_partners , self . pwid_agents , self . params , self . pop_random , bond_type , ) no_match = True if partner : race = utils . safe_random_choice ([ agent . race , partner . race ], self . pop_random ) duration = partnering . get_partnership_duration ( agent . location . params , self . np_random , bond_type , race ) relationship = ag . Relationship ( agent , partner , duration , bond_type = bond_type ) self . add_relationship ( relationship ) # can partner still partner? if len ( partner . partners [ bond_type ]) > ( partner . target_partners [ bond_type ] * self . params . calibration . partnership . buffer ): self . partnerable_agents [ bond_type ] . remove ( partner ) no_match = False return no_match update_partner_assignments ( self , t ) Determines which agents will seek new partners from All_agentSet. Calls update_agent_partners for any agents that desire partners. Parameters: Name Type Description Default t int current time step of the model required Source code in titan/population.py def update_partner_assignments ( self , t : int ): \"\"\" Determines which agents will seek new partners from All_agentSet. Calls update_agent_partners for any agents that desire partners. args: t: current time step of the model \"\"\" # update agent targets annually if t % self . params . model . time . steps_per_year == 0 : self . update_partner_targets () if self . enable_graph : network_components = [ set ( g . nodes ()) for g in self . components ] else : network_components = [] # Now create partnerships until available partnerships are out for bond in self . params . classes . bond_types : eligible_agents = deque ( [ a for a in self . all_agents if len ( a . partners [ bond ]) < a . target_partners [ bond ] ] ) attempts = { a : 0 for a in eligible_agents } while eligible_agents : agent = eligible_agents . popleft () if len ( agent . partners [ bond ]) < agent . target_partners [ bond ]: # no match if self . update_agent_partners ( agent , bond , network_components ): attempts [ agent ] += 1 # add agent back to eligible pool if ( len ( agent . partners [ bond ]) < agent . target_partners [ bond ] and attempts [ agent ] < self . params . calibration . partnership . break_point ): eligible_agents . append ( agent ) if self . enable_graph : self . trim_graph () self . update_agent_components () update_partner_targets ( self ) Update the target number of partners for each agent and bond type Source code in titan/population.py def update_partner_targets ( self ): \"\"\" Update the target number of partners for each agent and bond type \"\"\" for a in self . all_agents : for bond in self . params . classes . bond_types : a . target_partners [ bond ] = utils . poisson ( a . mean_num_partners [ bond ], self . np_random ) self . update_partnerability ( a ) update_partnerability ( self , a ) Update whether each agent in the population is currently able to form new relationships for each bond type Source code in titan/population.py def update_partnerability ( self , a ): \"\"\" Update whether each agent in the population is currently able to form new relationships for each bond type \"\"\" for bond in self . params . classes . bond_types . keys (): if a in self . partnerable_agents [ bond ]: if len ( a . partners [ bond ]) > ( a . target_partners [ bond ] * self . params . calibration . partnership . buffer ): self . partnerable_agents [ bond ] . remove ( a ) elif len ( a . partners [ bond ]) < ( a . target_partners [ bond ] * self . params . calibration . partnership . buffer ): self . partnerable_agents [ bond ] . add ( a ) Population Reading & Writing Released in v1.1.0 Populations can be saved to file so that they can be analysed in detail or re-used in a future run. run_titan.py allows this using the --savepop [path] option to save the population to the path, and the --poppath [path] option loads the population at the path. The population is saved after creation, but before the model has run. Saving the Population The population is represented as a series of csv files that save the attributes for the core entities (agents, relationships at this time). The population can be saved with only core attributes (e.g. race, sex_type, hiv) or with intervention attributes (e.g. prep, vaccinated) as well. intervention attributes are less likely to work as intended across versions of the model. titan . population_io . write ( pop , dir , compress = True ) Write a non-empty Population to file. Parameters: Name Type Description Default pop Population a non-empty agent population required dir str path to directory where files should be written required compress bool whether to compress and archive the csv True Returns: Type Description str path, or archive name if compress is true Source code in titan/population_io.py def write ( pop : Population , dir : str , compress : bool = True ) -> str : \"\"\" Write a non-empty Population to file. args: pop: a non-empty agent population dir: path to directory where files should be written compress: whether to compress and archive the csv returns: path, or archive name if compress is true \"\"\" assert len ( pop . relationships ) > 0 , \"Can't write empty population\" utils . set_up_logging ( pop . params ) # open agent file agent_file = os . path . join ( dir , f \" { pop . id } _agents.csv\" ) a = next ( iter ( pop . all_agents )) # get all attributes agent_attrs = [ k for k in a . __dict__ . keys () if k not in agent_exclude_attrs ] write_class_file ( agent_file , pop . all_agents , agent_attrs ) extra_files = [] # write agent extras (features, exposures) to their own files def write_extra_class ( extra_attrs , extra_type ): for extra in extra_attrs : extra_obj = getattr ( a , extra ) extra_attrs = list ( extra_obj . __dict__ . keys ()) extra_file = os . path . join ( dir , f \" { pop . id } _ { extra_type } _ { extra } .csv\" ) extra_files . append ( extra_file ) write_extra_class_file ( extra_file , pop . all_agents , extra , extra_attrs ) write_extra_class ( agent_feature_attrs , \"feat\" ) write_extra_class ( agent_exposure_attrs , \"exposure\" ) # open relationship file rel_file = os . path . join ( dir , f \" { pop . id } _relationships.csv\" ) r = next ( iter ( pop . relationships )) rel_attrs = list ( r . __dict__ . keys ()) write_class_file ( rel_file , pop . relationships , rel_attrs ) if compress : archive_name = make_archive ( os . path . join ( dir , f \" { pop . id } _pop\" ), \"gztar\" , root_dir = dir , base_dir = \".\" ) os . remove ( agent_file ) os . remove ( rel_file ) for f in extra_files : os . remove ( f ) return archive_name else : return dir Reading in/using a Saved Population A population can be created from the files saved, however, there is no validation done to ensure the params used when running on this population make sense/match what was originally used when creating it. Some things may validly change (e.g. interventions, reports needed, seeds), but others may result in strange behavior if changed (e.g. race distribution, what classes are in use). titan . population_io . read ( params , path ) Read a population from file and return a Population instance Parameters: Name Type Description Default params ObjMap the parameters used for creating this popultation required path str path where [id]_agents.csv and [id]_relationships.csv are or tar.gz file containing population required Returns: Type Description Population the re-constituted population Source code in titan/population_io.py def read ( params : ObjMap , path : str ) -> Population : \"\"\" Read a population from file and return a Population instance args: params: the parameters used for creating this popultation path: path where [id]_agents.csv and [id]_relationships.csv are or tar.gz file containing population returns: the re-constituted population \"\"\" if os . path . isfile ( path ): dir = mkdtemp () unpack_archive ( path , dir ) path = dir agent_file = glob . glob ( os . path . join ( path , \"*_agents.csv\" ))[ 0 ] rel_file = glob . glob ( os . path . join ( path , \"*_relationships.csv\" ))[ 0 ] feat_files = glob . glob ( os . path . join ( path , \"*_feat_*.csv\" )) exposure_files = glob . glob ( os . path . join ( path , \"*_exposure_*.csv\" )) assert os . path . isfile ( agent_file ), f \"can't find agents.csv in { dir } \" assert os . path . isfile ( rel_file ), f \"can't find relationships.csv in { dir } \" _ , agent_filename = os . path . split ( agent_file ) id = agent_filename [: 8 ] # create feature dict agent_extras : Dict [ str , Dict ] = {} def update_agent_extras ( files , extra_type ): pattern = re . compile ( f \"^.*_ { extra_type } _(.*) \\\\ .csv$\" ) for file in files : m = pattern . match ( file ) if m is not None : extra = m . group ( 1 ) agent_extras [ extra ] = {} with open ( file , newline = \"\" ) as f : reader = csv . DictReader ( f ) for row in reader : agent_extras [ extra ][ int ( row [ \"agent\" ])] = row update_agent_extras ( feat_files , \"feat\" ) update_agent_extras ( exposure_files , \"exposure\" ) # don't create any agents on init params . model . num_pop = 0 pop = Population ( params , id = id ) # re-create all agents and add to population with open ( agent_file , newline = \"\" ) as f : reader = csv . DictReader ( f ) for row in reader : a = create_agent ( row , params . classes . bond_types . keys (), pop . geography . locations , agent_extras , ) pop . add_agent ( a ) # update num_pop to actual population params . model . num_pop = pop . all_agents . num_members () # re-create all relationships and add to population with open ( rel_file , newline = \"\" ) as f : reader = csv . DictReader ( f ) for row in reader : r = create_relationship ( row , pop ) pop . add_relationship ( r ) pop . update_agent_components () return pop","title":"Population"},{"location":"api/population/#population","text":"The Population class is used to represent the population of agents the model is running on. On construction, it stochastically creates the population described in the params . At its core, it is a graph with nodes ( all_agents ) and edges ( relationships ), it can be formally backed by a NetworkX graph by enabling the graph in the prams file. This allows for some graph-specific logic to be applied throughout the running of the model (e.g. trimming components, writing network statistics).","title":"Population"},{"location":"api/population/#titan.population.Population.__init__","text":"Initialize Population object. Parameters: Name Type Description Default params parse_params.ObjMap Model parameters required id Optional[str] 8 character identifier for a model None Source code in titan/population.py def __init__ ( self , params : \"parse_params.ObjMap\" , id : Optional [ str ] = None ): \"\"\" Initialize Population object. args: params : Model parameters id: 8 character identifier for a model \"\"\" if id is None : self . id = nanoid . generate ( size = 8 ) else : self . id = id utils . set_up_logging ( params ) logging . info ( f \"Population ID: { self . id } \" ) self . pop_seed = utils . get_check_rand_int ( params . model . seed . ppl ) # Init RNG for population creation to pop_seed self . pop_random = random . Random ( self . pop_seed ) self . np_random = np . random . default_rng ( self . pop_seed ) self . enable_graph = params . model . network . enable self . components : List = [] if self . enable_graph : self . graph = nx . Graph () else : self . graph = None self . params = params # set up the in-scope exposures self . exposures = [ exposure for exposure in exposures . BaseExposure . __subclasses__ () if self . params . exposures [ exposure . name ] ] # initialize the class level items for exposure in self . exposures : exposure . init_class ( params ) # set up the in-scope features self . features = [ feature for feature in features . BaseFeature . __subclasses__ () if self . params . features [ feature . name ] ] # initialize the class level items for feature in self . features : feature . init_class ( params ) # set up the population's locations and edges self . geography = location . Geography ( params ) # All agent set list self . all_agents = ag . AgentSet ( \"AllAgents\" ) # pwid agents (performance for partnering) self . pwid_agents = ag . AgentSet ( \"PWID\" , parent = self . all_agents ) # agents who can take on a partner self . partnerable_agents : Dict [ str , Set [ \"ag.Agent\" ]] = {} for bond_type in self . params . classes . bond_types . keys (): self . partnerable_agents [ bond_type ] = set () # who can sleep with whom self . sex_partners : Dict [ str , Set [ \"ag.Agent\" ]] = {} for sex_type in self . params . classes . sex_types . keys (): self . sex_partners [ sex_type ] = set () self . relationships : Set [ \"ag.Relationship\" ] = set () # find average partnership durations self . mean_rel_duration : Dict [ str , Dict ] = partnering . get_mean_rel_duration ( self . params ) logging . info ( \" Creating agents\" ) # for each location in the population, create agents per that location's demographics init_time = - 1 * self . params . model . time . burn_steps for loc in self . geography . locations . values (): for race in params . classes . races : for i in range ( round ( params . model . num_pop * loc . ppl * loc . params . demographics [ race ] . ppl ) ): if self . all_agents . num_members () >= self . params . model . num_pop : logging . warning ( \"WARNING: not adding agent to population - too many agents\" ) break agent = self . create_agent ( loc , race , init_time ) self . add_agent ( agent ) # initialize relationships logging . info ( \" Creating Relationships\" ) self . update_partner_assignments ( 0 )","title":"__init__()"},{"location":"api/population/#titan.population.Population.add_agent","text":"Adds an agent to the population Parameters: Name Type Description Default agent ag.Agent The agent to be added required Source code in titan/population.py def add_agent ( self , agent : \"ag.Agent\" ): \"\"\" Adds an agent to the population args: agent : The agent to be added \"\"\" # Add to all agent set self . all_agents . add_agent ( agent ) if agent . drug_type == \"Inj\" : self . pwid_agents . add_agent ( agent ) # who can sleep with this agent for sex_type in self . params . classes . sex_types [ agent . sex_type ] . sleeps_with : self . sex_partners [ sex_type ] . add ( agent ) if self . enable_graph : self . graph . add_node ( agent )","title":"add_agent()"},{"location":"api/population/#titan.population.Population.add_relationship","text":"Add a new relationship to the population. Parameters: Name Type Description Default rel ag.Relationship The Relationship to be added required Source code in titan/population.py def add_relationship ( self , rel : \"ag.Relationship\" ): \"\"\" Add a new relationship to the population. args: rel : The Relationship to be added \"\"\" self . relationships . add ( rel ) if self . enable_graph : self . graph . add_edge ( rel . agent1 , rel . agent2 , type = rel . bond_type )","title":"add_relationship()"},{"location":"api/population/#titan.population.Population.connected_components","text":"Get connected components in graph (if enabled) Returns: Type Description List list of connected components Source code in titan/population.py def connected_components ( self ) -> List : \"\"\" Get connected components in graph (if enabled) returns: list of connected components \"\"\" if self . enable_graph : return self . components else : raise ValueError ( \"Can't get connected_components, population doesn't have graph enabled.\" )","title":"connected_components()"},{"location":"api/population/#titan.population.Population.create_agent","text":"Create a new agent with randomly assigned attributes according to population demographics [params.demographics] Parameters: Name Type Description Default loc location.Location location the agent will live in required race str race of the new agent required time int current time step of the model required sex_type Optional[str] sex_type of the new agent None Returns: Type Description ag.Agent a new agent Source code in titan/population.py def create_agent ( self , loc : \"location.Location\" , race : str , time : int , sex_type : Optional [ str ] = None , drug_type : Optional [ str ] = None , ) -> \"ag.Agent\" : \"\"\" Create a new agent with randomly assigned attributes according to population demographics [params.demographics] args: loc: location the agent will live in race : race of the new agent time: current time step of the model sex_type : sex_type of the new agent returns: a new agent \"\"\" if sex_type is None : sex_type = utils . safe_random_choice ( loc . pop_weights [ race ][ \"values\" ], self . pop_random , weights = loc . pop_weights [ race ][ \"weights\" ], ) # no choice available if sex_type is None : raise ValueError ( \"Agent must have sex type\" ) # Determine drugtype if drug_type is None : drug_type = utils . safe_random_choice ( loc . drug_weights [ race ][ sex_type ][ \"values\" ], self . pop_random , weights = loc . drug_weights [ race ][ sex_type ][ \"weights\" ], ) # no choice available if drug_type is None : raise ValueError ( \"Agent must have drug type\" ) age , age_bin = self . get_age ( loc , race ) agent = ag . Agent ( sex_type , age , race , drug_type , loc ) agent . age_bin = age_bin sex_role = utils . safe_random_choice ( loc . role_weights [ race ][ sex_type ][ \"values\" ], self . pop_random , weights = loc . role_weights [ race ][ sex_type ][ \"weights\" ], ) if sex_role is None : raise ValueError ( \"Agent must have sex role\" ) else : agent . sex_role = sex_role agent_params = ( agent . location . params . demographics [ race ] . sex_type [ sex_type ] . drug_type [ drug_type ] ) for exposure in self . exposures : agent_feature = getattr ( agent , exposure . name ) agent_feature . init_agent ( self , time ) for bond , bond_def in loc . params . classes . bond_types . items (): agent . partners [ bond ] = set () dist_info = agent_params . num_partners [ bond ] agent . mean_num_partners [ bond ] = ceil ( utils . safe_dist ( dist_info , self . np_random ) * utils . safe_divide ( agent . location . params . calibration . sex . partner , self . mean_rel_duration [ bond ][ race ], ) ) # so not zero if added mid-year agent . target_partners [ bond ] = agent . mean_num_partners [ bond ] if \"injection\" in bond_def . acts_allowed : assert agent . drug_type == \"Inj\" or agent . mean_num_partners [ bond ] == 0 if agent . target_partners [ bond ] > 0 : self . partnerable_agents [ bond ] . add ( agent ) for feature in self . features : agent_feature = getattr ( agent , feature . name ) agent_feature . init_agent ( self , time ) return agent","title":"create_agent()"},{"location":"api/population/#titan.population.Population.get_age","text":"Given the population characteristics, get a random age to assign to an agent given the race of that agent Parameters: Name Type Description Default race str race of the agent whose age is being generated required Returns: Type Description Tuple[int, int] age and the bin the age came from Source code in titan/population.py def get_age ( self , loc : \"location.Location\" , race : str ) -> Tuple [ int , int ]: \"\"\" Given the population characteristics, get a random age to assign to an agent given the race of that agent args: race : race of the agent whose age is being generated returns: age and the bin the age came from \"\"\" bins = loc . params . demographics [ race ] . age i = utils . get_independent_bin ( self . pop_random , bins ) age = self . pop_random . randrange ( bins [ i ] . min , bins [ i ] . max ) return age , i","title":"get_age()"},{"location":"api/population/#titan.population.Population.migrate","text":"Have agents migrate between locations with probabilities defined in location.migration.matrix_file . Source code in titan/population.py def migrate ( self ): \"\"\" Have agents migrate between locations with probabilities defined in `location.migration.matrix_file`. \"\"\" m_attr = self . params . location . migration . attribute for a in self . all_agents : m_param = a . location . migration_weights if self . pop_random . random () < m_param [ \"prob\" ]: new_loc = utils . safe_random_choice ( m_param [ \"values\" ], self . pop_random , weights = m_param [ \"weights\" ], ) if m_attr == \"name\" : a . location = self . geography . locations [ new_loc ] elif m_attr == \"category\" : a . location = utils . safe_random_choice ( self . geography . categories [ new_loc ], self . pop_random )","title":"migrate()"},{"location":"api/population/#titan.population.Population.remove_agent","text":"Remove an agent from the population. Parameters: Name Type Description Default agent ag.Agent Agent to remove required Source code in titan/population.py def remove_agent ( self , agent : \"ag.Agent\" ): \"\"\" Remove an agent from the population. args: agent : Agent to remove \"\"\" self . all_agents . remove_agent ( agent ) for partner_type in self . sex_partners : if agent in self . sex_partners [ partner_type ]: self . sex_partners [ partner_type ] . remove ( agent ) for exposure in self . exposures : agent_attr = getattr ( agent , exposure . name ) if agent_attr . active : exposure . remove_agent ( agent ) for feature in self . features : agent_attr = getattr ( agent , feature . name ) if agent_attr . active : feature . remove_agent ( agent ) if self . enable_graph : self . graph . remove_node ( agent ) for bond in self . partnerable_agents . values (): if agent in bond : bond . remove ( agent )","title":"remove_agent()"},{"location":"api/population/#titan.population.Population.remove_relationship","text":"Remove a relationship from the population. Parameters: Name Type Description Default rel ag.Relationship Relationship to remove required Source code in titan/population.py def remove_relationship ( self , rel : \"ag.Relationship\" ): \"\"\" Remove a relationship from the population. args: rel : Relationship to remove \"\"\" self . relationships . remove ( rel ) # without this relationship, are agents partnerable again? self . update_partnerability ( rel . agent1 ) self . update_partnerability ( rel . agent2 ) if self . enable_graph : self . graph . remove_edge ( rel . agent1 , rel . agent2 )","title":"remove_relationship()"},{"location":"api/population/#titan.population.Population.trim_graph","text":"Initialize network with graph-based algorithm for relationship adding/pruning Source code in titan/population.py def trim_graph ( self ): \"\"\" Initialize network with graph-based algorithm for relationship adding/pruning \"\"\" if self . params . model . network . type == \"comp_size\" : def trim_component ( component , max_size ): for agent in component . nodes : if ( self . pop_random . random () < self . params . calibration . network . trim . prob ): for rel in copy ( agent . relationships ): if len ( agent . relationships ) == 1 : break # Make sure that agents stay part of the # network by keeping one bond rel . progress ( force = True ) self . remove_relationship ( rel ) # recurse on new sub-components sub_comps = utils . connected_components ( component ) for sub_comp in sub_comps : if sub_comp . number_of_nodes () > max_size : trim_component ( component , max_size ) else : break components = self . connected_components () for comp in components : if ( comp . number_of_nodes () > self . params . model . network . component_size . max ): logging . info ( \"TOO BIG\" , comp , comp . number_of_nodes ()) trim_component ( comp , self . params . model . network . component_size . max ) logging . info ( f \" Total agents in graph: { self . graph . number_of_nodes () } \" )","title":"trim_graph()"},{"location":"api/population/#titan.population.Population.update_agent_components","text":"Update the component IDs associated with each agent based on the current state of the graph Source code in titan/population.py def update_agent_components ( self ): \"\"\" Update the component IDs associated with each agent based on the current state of the graph \"\"\" if self . enable_graph : self . components = utils . connected_components ( self . graph ) for id , component in enumerate ( self . components ): for agent in component . nodes : agent . component = str ( id ) self . params . classes . components = list ( map ( str , range ( - 1 , len ( self . components ))) )","title":"update_agent_components()"},{"location":"api/population/#titan.population.Population.update_agent_partners","text":"Finds and bonds new partner. Creates relationship object for partnership, calcs partnership duration, adds it to the population, and adds to networkX graph if self.enable_graph is set True. Parameters: Name Type Description Default agent ag.Agent Agent that is seeking a new partner required bond_type str What type of bond the agent is seeking to make required Returns: Type Description bool True if no match was found for agent (used for retries) Source code in titan/population.py def update_agent_partners ( self , agent : \"ag.Agent\" , bond_type : str , components : List ) -> bool : \"\"\" Finds and bonds new partner. Creates relationship object for partnership, calcs partnership duration, adds it to the population, and adds to networkX graph if self.enable_graph is set True. args: agent: Agent that is seeking a new partner bond_type: What type of bond the agent is seeking to make returns: True if no match was found for agent (used for retries) \"\"\" partnerable_agents = self . partnerable_agents [ bond_type ] if ( self . pop_random . random () < self . params . partnership . network . same_component . prob and agent . has_partners () ): # find agent's component agent_component : Set [ \"ag.Agent\" ] = set () for comp in components : if agent in comp : agent_component = comp break partnerable_agents = partnerable_agents & agent_component partner = partnering . select_partner ( agent , partnerable_agents , self . sex_partners , self . pwid_agents , self . params , self . pop_random , bond_type , ) no_match = True if partner : race = utils . safe_random_choice ([ agent . race , partner . race ], self . pop_random ) duration = partnering . get_partnership_duration ( agent . location . params , self . np_random , bond_type , race ) relationship = ag . Relationship ( agent , partner , duration , bond_type = bond_type ) self . add_relationship ( relationship ) # can partner still partner? if len ( partner . partners [ bond_type ]) > ( partner . target_partners [ bond_type ] * self . params . calibration . partnership . buffer ): self . partnerable_agents [ bond_type ] . remove ( partner ) no_match = False return no_match","title":"update_agent_partners()"},{"location":"api/population/#titan.population.Population.update_partner_assignments","text":"Determines which agents will seek new partners from All_agentSet. Calls update_agent_partners for any agents that desire partners. Parameters: Name Type Description Default t int current time step of the model required Source code in titan/population.py def update_partner_assignments ( self , t : int ): \"\"\" Determines which agents will seek new partners from All_agentSet. Calls update_agent_partners for any agents that desire partners. args: t: current time step of the model \"\"\" # update agent targets annually if t % self . params . model . time . steps_per_year == 0 : self . update_partner_targets () if self . enable_graph : network_components = [ set ( g . nodes ()) for g in self . components ] else : network_components = [] # Now create partnerships until available partnerships are out for bond in self . params . classes . bond_types : eligible_agents = deque ( [ a for a in self . all_agents if len ( a . partners [ bond ]) < a . target_partners [ bond ] ] ) attempts = { a : 0 for a in eligible_agents } while eligible_agents : agent = eligible_agents . popleft () if len ( agent . partners [ bond ]) < agent . target_partners [ bond ]: # no match if self . update_agent_partners ( agent , bond , network_components ): attempts [ agent ] += 1 # add agent back to eligible pool if ( len ( agent . partners [ bond ]) < agent . target_partners [ bond ] and attempts [ agent ] < self . params . calibration . partnership . break_point ): eligible_agents . append ( agent ) if self . enable_graph : self . trim_graph () self . update_agent_components ()","title":"update_partner_assignments()"},{"location":"api/population/#titan.population.Population.update_partner_targets","text":"Update the target number of partners for each agent and bond type Source code in titan/population.py def update_partner_targets ( self ): \"\"\" Update the target number of partners for each agent and bond type \"\"\" for a in self . all_agents : for bond in self . params . classes . bond_types : a . target_partners [ bond ] = utils . poisson ( a . mean_num_partners [ bond ], self . np_random ) self . update_partnerability ( a )","title":"update_partner_targets()"},{"location":"api/population/#titan.population.Population.update_partnerability","text":"Update whether each agent in the population is currently able to form new relationships for each bond type Source code in titan/population.py def update_partnerability ( self , a ): \"\"\" Update whether each agent in the population is currently able to form new relationships for each bond type \"\"\" for bond in self . params . classes . bond_types . keys (): if a in self . partnerable_agents [ bond ]: if len ( a . partners [ bond ]) > ( a . target_partners [ bond ] * self . params . calibration . partnership . buffer ): self . partnerable_agents [ bond ] . remove ( a ) elif len ( a . partners [ bond ]) < ( a . target_partners [ bond ] * self . params . calibration . partnership . buffer ): self . partnerable_agents [ bond ] . add ( a )","title":"update_partnerability()"},{"location":"api/population/#population-reading-writing","text":"Released in v1.1.0 Populations can be saved to file so that they can be analysed in detail or re-used in a future run. run_titan.py allows this using the --savepop [path] option to save the population to the path, and the --poppath [path] option loads the population at the path. The population is saved after creation, but before the model has run.","title":"Population Reading &amp; Writing"},{"location":"api/population/#saving-the-population","text":"The population is represented as a series of csv files that save the attributes for the core entities (agents, relationships at this time). The population can be saved with only core attributes (e.g. race, sex_type, hiv) or with intervention attributes (e.g. prep, vaccinated) as well. intervention attributes are less likely to work as intended across versions of the model.","title":"Saving the Population"},{"location":"api/population/#titan.population_io.write","text":"Write a non-empty Population to file. Parameters: Name Type Description Default pop Population a non-empty agent population required dir str path to directory where files should be written required compress bool whether to compress and archive the csv True Returns: Type Description str path, or archive name if compress is true Source code in titan/population_io.py def write ( pop : Population , dir : str , compress : bool = True ) -> str : \"\"\" Write a non-empty Population to file. args: pop: a non-empty agent population dir: path to directory where files should be written compress: whether to compress and archive the csv returns: path, or archive name if compress is true \"\"\" assert len ( pop . relationships ) > 0 , \"Can't write empty population\" utils . set_up_logging ( pop . params ) # open agent file agent_file = os . path . join ( dir , f \" { pop . id } _agents.csv\" ) a = next ( iter ( pop . all_agents )) # get all attributes agent_attrs = [ k for k in a . __dict__ . keys () if k not in agent_exclude_attrs ] write_class_file ( agent_file , pop . all_agents , agent_attrs ) extra_files = [] # write agent extras (features, exposures) to their own files def write_extra_class ( extra_attrs , extra_type ): for extra in extra_attrs : extra_obj = getattr ( a , extra ) extra_attrs = list ( extra_obj . __dict__ . keys ()) extra_file = os . path . join ( dir , f \" { pop . id } _ { extra_type } _ { extra } .csv\" ) extra_files . append ( extra_file ) write_extra_class_file ( extra_file , pop . all_agents , extra , extra_attrs ) write_extra_class ( agent_feature_attrs , \"feat\" ) write_extra_class ( agent_exposure_attrs , \"exposure\" ) # open relationship file rel_file = os . path . join ( dir , f \" { pop . id } _relationships.csv\" ) r = next ( iter ( pop . relationships )) rel_attrs = list ( r . __dict__ . keys ()) write_class_file ( rel_file , pop . relationships , rel_attrs ) if compress : archive_name = make_archive ( os . path . join ( dir , f \" { pop . id } _pop\" ), \"gztar\" , root_dir = dir , base_dir = \".\" ) os . remove ( agent_file ) os . remove ( rel_file ) for f in extra_files : os . remove ( f ) return archive_name else : return dir","title":"write()"},{"location":"api/population/#reading-inusing-a-saved-population","text":"A population can be created from the files saved, however, there is no validation done to ensure the params used when running on this population make sense/match what was originally used when creating it. Some things may validly change (e.g. interventions, reports needed, seeds), but others may result in strange behavior if changed (e.g. race distribution, what classes are in use).","title":"Reading in/using a Saved Population"},{"location":"api/population/#titan.population_io.read","text":"Read a population from file and return a Population instance Parameters: Name Type Description Default params ObjMap the parameters used for creating this popultation required path str path where [id]_agents.csv and [id]_relationships.csv are or tar.gz file containing population required Returns: Type Description Population the re-constituted population Source code in titan/population_io.py def read ( params : ObjMap , path : str ) -> Population : \"\"\" Read a population from file and return a Population instance args: params: the parameters used for creating this popultation path: path where [id]_agents.csv and [id]_relationships.csv are or tar.gz file containing population returns: the re-constituted population \"\"\" if os . path . isfile ( path ): dir = mkdtemp () unpack_archive ( path , dir ) path = dir agent_file = glob . glob ( os . path . join ( path , \"*_agents.csv\" ))[ 0 ] rel_file = glob . glob ( os . path . join ( path , \"*_relationships.csv\" ))[ 0 ] feat_files = glob . glob ( os . path . join ( path , \"*_feat_*.csv\" )) exposure_files = glob . glob ( os . path . join ( path , \"*_exposure_*.csv\" )) assert os . path . isfile ( agent_file ), f \"can't find agents.csv in { dir } \" assert os . path . isfile ( rel_file ), f \"can't find relationships.csv in { dir } \" _ , agent_filename = os . path . split ( agent_file ) id = agent_filename [: 8 ] # create feature dict agent_extras : Dict [ str , Dict ] = {} def update_agent_extras ( files , extra_type ): pattern = re . compile ( f \"^.*_ { extra_type } _(.*) \\\\ .csv$\" ) for file in files : m = pattern . match ( file ) if m is not None : extra = m . group ( 1 ) agent_extras [ extra ] = {} with open ( file , newline = \"\" ) as f : reader = csv . DictReader ( f ) for row in reader : agent_extras [ extra ][ int ( row [ \"agent\" ])] = row update_agent_extras ( feat_files , \"feat\" ) update_agent_extras ( exposure_files , \"exposure\" ) # don't create any agents on init params . model . num_pop = 0 pop = Population ( params , id = id ) # re-create all agents and add to population with open ( agent_file , newline = \"\" ) as f : reader = csv . DictReader ( f ) for row in reader : a = create_agent ( row , params . classes . bond_types . keys (), pop . geography . locations , agent_extras , ) pop . add_agent ( a ) # update num_pop to actual population params . model . num_pop = pop . all_agents . num_members () # re-create all relationships and add to population with open ( rel_file , newline = \"\" ) as f : reader = csv . DictReader ( f ) for row in reader : r = create_relationship ( row , pop ) pop . add_relationship ( r ) pop . update_agent_components () return pop","title":"read()"},{"location":"api/relationship/","text":"Class for agent relationships. __init__ ( self , agent1 , agent2 , duration , bond_type , id = None ) special Constructor for a Relationship Parameters: Name Type Description Default agent1 Agent first agent required agent2 Agent second agent required duration int target duration of relationship required bond_type str type of bond for the relationship [params.classes.bond_types] required id Optional[int] unique identifier None Source code in titan/agent.py def __init__ ( self , agent1 : Agent , agent2 : Agent , duration : int , bond_type : str , id : Optional [ int ] = None , ): \"\"\" Constructor for a Relationship args: agent1: first agent agent2: second agent duration: target duration of relationship bond_type: type of bond for the relationship [params.classes.bond_types] id: unique identifier \"\"\" # make sure these agents can be in a relationship assert agent1 != agent2 , \"Cannot create relationship with same agent\" for rel in agent1 . relationships : assert agent2 != rel . get_partner ( agent1 ), \"Agents already partnered!\" # self.id is unique ID number used to track each person agent. self . agent1 = agent1 self . agent2 = agent2 if id is not None : self . id = id else : self . id = self . next_rel_id self . update_id_counter ( self . id ) # Relationship properties self . duration = duration self . total_duration = duration self . bond_type = bond_type self . bond () bond ( self ) Bond two agents. Adds the relationship to each agent's relationships set, then adds each partner to the others' partner list. Source code in titan/agent.py def bond ( self ) -> None : \"\"\" Bond two agents. Adds the relationship to each agent's `relationships` set, then adds each partner to the others' partner list. \"\"\" # Append relationship to relationships list for each agent self . agent1 . relationships . add ( self ) self . agent2 . relationships . add ( self ) # Pair agent with partner and partner with agent self . agent1 . partners [ self . bond_type ] . add ( self . agent2 ) self . agent2 . partners [ self . bond_type ] . add ( self . agent1 ) get_number_of_sex_acts ( self , rand_gen ) Number of sex acts in the relationship during the time step. Parameters: Name Type Description Default rand_gen np random number generator (e.g. self.run_random in model) required Returns: Type Description int number of sex acts Source code in titan/agent.py def get_number_of_sex_acts ( self , rand_gen ) -> int : \"\"\" Number of sex acts in the relationship during the time step. args: rand_gen: np random number generator (e.g. self.run_random in model) returns: number of sex acts \"\"\" agent = safe_random_choice ([ self . agent1 , self . agent2 ], rand_gen ) freq_params = agent . location . params . partnership . sex . frequency [ self . bond_type ] if freq_params . type == \"bins\" : i = get_independent_bin ( rand_gen , freq_params . bins ) return safe_random_int ( freq_params . bins [ i ] . min , freq_params . bins [ i ] . max , rand_gen ) elif freq_params . type == \"distribution\" : return round ( safe_dist ( freq_params . distribution , rand_gen )) else : raise Exception ( \"Sex acts must be defined as bin or distribution\" ) get_partner ( self , agent ) Given an agent in the relationship, return the other agent Parameters: Name Type Description Default agent Agent one of the agents in the relationship required Returns: Type Description Agent the agent's partner Source code in titan/agent.py def get_partner ( self , agent : \"Agent\" ) -> \"Agent\" : \"\"\" Given an agent in the relationship, return the other agent args: agent: one of the agents in the relationship returns: the agent's partner \"\"\" if agent == self . agent1 : return self . agent2 elif agent == self . agent2 : return self . agent1 else : raise ValueError ( \"Agent must be in this relationship\" ) progress ( self , force = False ) Progress a relationship to the next time step (decrementing remaining target duration), or end a relationship if the duration is 0 or if force is set to True Parameters: Name Type Description Default force bool whether to force the relationship to end False Source code in titan/agent.py def progress ( self , force : bool = False ) -> bool : \"\"\" Progress a relationship to the next time step (decrementing remaining target duration), or end a relationship if the duration is 0 or if `force` is set to `True` args: force: whether to force the relationship to end \"\"\" if self . duration <= 0 or force : self . unbond () return True else : self . duration -= 1 return False unbond ( self ) Unbond two agents. Removes relationship from relationship sets. Removes partners in each others' partner list. Source code in titan/agent.py def unbond ( self ): \"\"\" Unbond two agents. Removes relationship from relationship sets. Removes partners in each others' partner list. \"\"\" # Remove relationship to relationships list for each agent self . agent1 . relationships . remove ( self ) self . agent2 . relationships . remove ( self ) # Unpair agent with partner and partner with agent self . agent1 . partners [ self . bond_type ] . remove ( self . agent2 ) self . agent2 . partners [ self . bond_type ] . remove ( self . agent1 )","title":"Relationship"},{"location":"api/relationship/#titan.agent.Relationship.__init__","text":"Constructor for a Relationship Parameters: Name Type Description Default agent1 Agent first agent required agent2 Agent second agent required duration int target duration of relationship required bond_type str type of bond for the relationship [params.classes.bond_types] required id Optional[int] unique identifier None Source code in titan/agent.py def __init__ ( self , agent1 : Agent , agent2 : Agent , duration : int , bond_type : str , id : Optional [ int ] = None , ): \"\"\" Constructor for a Relationship args: agent1: first agent agent2: second agent duration: target duration of relationship bond_type: type of bond for the relationship [params.classes.bond_types] id: unique identifier \"\"\" # make sure these agents can be in a relationship assert agent1 != agent2 , \"Cannot create relationship with same agent\" for rel in agent1 . relationships : assert agent2 != rel . get_partner ( agent1 ), \"Agents already partnered!\" # self.id is unique ID number used to track each person agent. self . agent1 = agent1 self . agent2 = agent2 if id is not None : self . id = id else : self . id = self . next_rel_id self . update_id_counter ( self . id ) # Relationship properties self . duration = duration self . total_duration = duration self . bond_type = bond_type self . bond ()","title":"__init__()"},{"location":"api/relationship/#titan.agent.Relationship.bond","text":"Bond two agents. Adds the relationship to each agent's relationships set, then adds each partner to the others' partner list. Source code in titan/agent.py def bond ( self ) -> None : \"\"\" Bond two agents. Adds the relationship to each agent's `relationships` set, then adds each partner to the others' partner list. \"\"\" # Append relationship to relationships list for each agent self . agent1 . relationships . add ( self ) self . agent2 . relationships . add ( self ) # Pair agent with partner and partner with agent self . agent1 . partners [ self . bond_type ] . add ( self . agent2 ) self . agent2 . partners [ self . bond_type ] . add ( self . agent1 )","title":"bond()"},{"location":"api/relationship/#titan.agent.Relationship.get_number_of_sex_acts","text":"Number of sex acts in the relationship during the time step. Parameters: Name Type Description Default rand_gen np random number generator (e.g. self.run_random in model) required Returns: Type Description int number of sex acts Source code in titan/agent.py def get_number_of_sex_acts ( self , rand_gen ) -> int : \"\"\" Number of sex acts in the relationship during the time step. args: rand_gen: np random number generator (e.g. self.run_random in model) returns: number of sex acts \"\"\" agent = safe_random_choice ([ self . agent1 , self . agent2 ], rand_gen ) freq_params = agent . location . params . partnership . sex . frequency [ self . bond_type ] if freq_params . type == \"bins\" : i = get_independent_bin ( rand_gen , freq_params . bins ) return safe_random_int ( freq_params . bins [ i ] . min , freq_params . bins [ i ] . max , rand_gen ) elif freq_params . type == \"distribution\" : return round ( safe_dist ( freq_params . distribution , rand_gen )) else : raise Exception ( \"Sex acts must be defined as bin or distribution\" )","title":"get_number_of_sex_acts()"},{"location":"api/relationship/#titan.agent.Relationship.get_partner","text":"Given an agent in the relationship, return the other agent Parameters: Name Type Description Default agent Agent one of the agents in the relationship required Returns: Type Description Agent the agent's partner Source code in titan/agent.py def get_partner ( self , agent : \"Agent\" ) -> \"Agent\" : \"\"\" Given an agent in the relationship, return the other agent args: agent: one of the agents in the relationship returns: the agent's partner \"\"\" if agent == self . agent1 : return self . agent2 elif agent == self . agent2 : return self . agent1 else : raise ValueError ( \"Agent must be in this relationship\" )","title":"get_partner()"},{"location":"api/relationship/#titan.agent.Relationship.progress","text":"Progress a relationship to the next time step (decrementing remaining target duration), or end a relationship if the duration is 0 or if force is set to True Parameters: Name Type Description Default force bool whether to force the relationship to end False Source code in titan/agent.py def progress ( self , force : bool = False ) -> bool : \"\"\" Progress a relationship to the next time step (decrementing remaining target duration), or end a relationship if the duration is 0 or if `force` is set to `True` args: force: whether to force the relationship to end \"\"\" if self . duration <= 0 or force : self . unbond () return True else : self . duration -= 1 return False","title":"progress()"},{"location":"api/relationship/#titan.agent.Relationship.unbond","text":"Unbond two agents. Removes relationship from relationship sets. Removes partners in each others' partner list. Source code in titan/agent.py def unbond ( self ): \"\"\" Unbond two agents. Removes relationship from relationship sets. Removes partners in each others' partner list. \"\"\" # Remove relationship to relationships list for each agent self . agent1 . relationships . remove ( self ) self . agent2 . relationships . remove ( self ) # Unpair agent with partner and partner with agent self . agent1 . partners [ self . bond_type ] . remove ( self . agent2 ) self . agent2 . partners [ self . bond_type ] . remove ( self . agent1 )","title":"unbond()"},{"location":"api/reporting/","text":"Reporting add_agent_to_stats ( stats_item , key ) Update the stats dictionary counts for the key given the agent's attributes Parameters: Name Type Description Default stats_item Dict[str, int] the leaf node of a nested dictionary of attributes to counts required key str the type of count to increment required Source code in titan/output.py def add_agent_to_stats ( stats_item : Dict [ str , int ], key : str ): \"\"\" Update the stats dictionary counts for the key given the agent's attributes args: stats_item: the leaf node of a nested dictionary of attributes to counts key: the type of count to increment \"\"\" stats_item [ key ] += 1 basicReport ( run_id , t , runseed , popseed , stats , params , outdir ) Standard report writer for basic agent statistics, columns include: \"agents\": number of agents in the population \"deaths\": number of agents who died this time period \"deaths_hiv\": number of agents with HIV who died this time period Additionally, any feature enabled may have additional stats that are tracked. See the feature's stats attribute and docs for details. Source code in titan/output.py def basicReport ( run_id : str , t : int , runseed : int , popseed : int , stats : Dict [ str , Any ], params : ObjMap , outdir : str , ): \"\"\" Standard report writer for basic agent statistics, columns include: * \"agents\": number of agents in the population * \"deaths\": number of agents who died this time period * \"deaths_hiv\": number of agents with HIV who died this time period Additionally, any feature enabled may have additional stats that are tracked. See the feature's `stats` attribute and docs for details. \"\"\" write_report ( \"basicReport.txt\" , run_id , t , runseed , popseed , stats , params , outdir ) get_agg_val ( stats , attrs , key ) Get the value of a key in stats given the attribute values Parameters: Name Type Description Default stats Dict a nested dictionary of attributes to count required attrs List a list of attribute values to find the count for required key str the type of count to get the value of required Returns: Type Description int the count of key for the given attributes Source code in titan/output.py def get_agg_val ( stats : Dict , attrs : List , key : str ) -> int : \"\"\" Get the value of a key in stats given the attribute values args: stats: a nested dictionary of attributes to count attrs: a list of attribute values to find the count for key: the type of count to get the value of returns: the count of key for the given attributes \"\"\" stats_item = stats for attr in attrs : stats_item = stats_item [ attr ] return stats_item [ key ] get_aggregates ( params ) Get iterator over all attribute combinations for output classes Parameters: Name Type Description Default params ObjMap model parameters required Returns: Type Description Iterator iterator over attribute combinations Source code in titan/output.py def get_aggregates ( params : ObjMap ) -> Iterator : \"\"\" Get iterator over all attribute combinations for output classes args: params: model parameters returns: iterator over attribute combinations \"\"\" return itertools . product ( * [ list ( k for k in params . classes [ clss ]) for clss in params . outputs . classes ] ) get_stats ( all_agents , deaths , params , exposures , features , time ) Get the current statistics for a model based on the population, and tracking agent sets from the model. Parameters: Name Type Description Default all_agents ag.AgentSet all of the agents in the population required new_hiv.dx agents who are newly diagnosed with hiv this timestep required deaths List[ag.Agent] agents who died this timestep required params ObjMap model parameters required Returns: Type Description Dict nested dictionary of agent attributes to counts of various items Source code in titan/output.py def get_stats ( all_agents : \"ag.AgentSet\" , deaths : List [ \"ag.Agent\" ], params : ObjMap , exposures , features , time : int , ) -> Dict : \"\"\" Get the current statistics for a model based on the population, and tracking agent sets from the model. args: all_agents: all of the agents in the population new_hiv.dx: agents who are newly diagnosed with hiv this timestep deaths: agents who died this timestep params: model parameters returns: nested dictionary of agent attributes to counts of various items \"\"\" reportables = exposures + features stats = setup_aggregates ( params , reportables , params . outputs . classes ) # attribute names (non-plural) attrs = [ clss [: - 1 ] for clss in params . outputs . classes ] for a in all_agents : stats_item = get_stats_item ( stats , attrs , a ) add_agent_to_stats ( stats_item , \"agents\" ) for reportable in reportables : agent_feature = getattr ( a , reportable . name ) agent_feature . set_stats ( stats_item , time ) for a in deaths : stats_item = get_stats_item ( stats , attrs , a ) add_agent_to_stats ( stats_item , \"deaths\" ) if a . hiv . active : # type: ignore[attr-defined] add_agent_to_stats ( stats_item , \"deaths_hiv\" ) return stats get_stats_item ( stats , attrs , agent ) Get the leaf node of the stats dictionary for the given attributes and agent. Parameters: Name Type Description Default stats Dict[str, Any] a nested dictionary of attributes to count required attrs List[str] a list of attribute values to find the count for required agent ag.Agent The agent to get the leaf node for required Returns: Type Description a stats_item dictionary of keys to counts Source code in titan/output.py def get_stats_item ( stats : Dict [ str , Any ], attrs : List [ str ], agent : \"ag.Agent\" ): \"\"\" Get the leaf node of the stats dictionary for the given attributes and agent. args: stats: a nested dictionary of attributes to count attrs: a list of attribute values to find the count for agent: The agent to get the leaf node for returns: a stats_item dictionary of keys to counts \"\"\" stats_item = stats for attr in attrs : stats_item = stats_item [ str ( getattr ( agent , attr ))] return stats_item print_components ( run_id , t , runseed , popseed , components , outdir ) Write stats describing the components (sub-graphs) in a graph to file Parameters: Name Type Description Default run_id str unique identifer for this run of the model required t int current timestep required runseed int integer used to seed the model's random number generator required popseed int integer used to seed the population's random number generator required components List a list of graph components required outdir str path where the file should be saved required races the races in the population required Source code in titan/output.py def print_components ( run_id : str , t : int , runseed : int , popseed : int , components : List , outdir : str , ): \"\"\" Write stats describing the components (sub-graphs) in a graph to file args: run_id: unique identifer for this run of the model t: current timestep runseed: integer used to seed the model's random number generator popseed: integer used to seed the population's random number generator components: a list of graph components outdir: path where the file should be saved races: the races in the population \"\"\" f = open ( os . path . join ( outdir , f \" { run_id } _componentReport_ALL.txt\" ), \"a\" ) # if this is a new file, write the header info if f . tell () == 0 : f . write ( \"run_id \\t runseed \\t popseed \\t t \\t component\" \" \\t density \\t EffectiveSize \\t deg_cent \\n \" ) for ( id , comp ) in enumerate ( components ): num_nodes = comp . number_of_nodes () average_size = effective_size ( comp ) / num_nodes comp_density = nx . density ( comp ) deg_cent = mean ( list ( nx . degree_centrality ( comp ) . values ())) f . write ( f \" { run_id } \\t { runseed } \\t { popseed } \\t { t } \\t { id } \\t \" f \" \\t { comp_density : .4f } \" f \" \\t { average_size : .4f } \\t { deg_cent } \\n \" ) f . close () setup_aggregates ( params , reportables , classes ) Recursively create a nested dictionary of attribute values to items to count. Attributes are classes defined in params, the items counted are: \"agents\" \"deaths\" \"deaths_hiv\" Additionally, any feature enabled may have additional stats that are tracked. See the feature's stats attribute. Parameters: Name Type Description Default params ObjMap model parameters required classes List[str] which classes to aggregate by [params.outputs.classes] required Returns: Type Description Dict dictionary of class values to counts Source code in titan/output.py def setup_aggregates ( params : ObjMap , reportables , classes : List [ str ]) -> Dict : \"\"\" Recursively create a nested dictionary of attribute values to items to count. Attributes are classes defined in params, the items counted are: * \"agents\" * \"deaths\" * \"deaths_hiv\" Additionally, any feature enabled may have additional stats that are tracked. See the feature's `stats` attribute. args: params: model parameters classes: which classes to aggregate by [params.outputs.classes] returns: dictionary of class values to counts \"\"\" if classes == []: base_stats = { \"agents\" : 0 , \"deaths\" : 0 , \"deaths_hiv\" : 0 , } for reportable in reportables : base_stats . update ({ stat : 0 for stat in reportable . stats }) return base_stats stats = {} clss , * rem_clss = classes # head, tail keys = [ k for k in params . classes [ clss ]] for key in keys : stats [ key ] = setup_aggregates ( params , reportables , rem_clss ) return stats write_graph_edgelist ( graph , path , id , time ) Writes a pipe-delimited edge list to the file <id>_Edgelist_t<time>.txt Parameters: Name Type Description Default path str directory where the file should be saved required id identifier for the network, typically the model's id required time timestep the edgelist is being written at required Source code in titan/output.py def write_graph_edgelist ( graph , path : str , id , time ): \"\"\" Writes a pipe-delimited edge list to the file `<id>_Edgelist_t<time>.txt` args: path: directory where the file should be saved id: identifier for the network, typically the model's `id` time: timestep the edgelist is being written at \"\"\" file_path = os . path . join ( path , f \" { id } _Edgelist_t { time } .txt\" ) # Write edgelist with bond type nx . write_edgelist ( graph , file_path , delimiter = \"|\" , data = [ \"type\" ]) write_network_stats ( graph , path , id , time ) Writes network statistics to the file <id>_NetworkStats_t<time>.txt Parameters: Name Type Description Default path str directory where the file should be saved required id identifier for the network, typically the model's id required time timestep the edgelist is being written at required Source code in titan/output.py def write_network_stats ( graph , path : str , id , time ): \"\"\" Writes network statistics to the file `<id>_NetworkStats_t<time>.txt` args: path: directory where the file should be saved id: identifier for the network, typically the model's `id` time: timestep the edgelist is being written at \"\"\" file_path = os . path . join ( path , f \" { id } _NetworkStats_t { time } .txt\" ) components = utils . connected_components ( graph ) outfile = open ( file_path , \"w\" ) outfile . write ( nx . info ( graph )) cent_dict = nx . degree_centrality ( graph ) outfile . write ( \" \\n Number of connected components: {} \\n \" . format ( nx . number_connected_components ( graph ) ) ) tot_nodes = 0 for c in components : tot_nodes += c . number_of_nodes () outfile . write ( \"Average component size: {} \\n \" . format ( tot_nodes * 1.0 / nx . number_connected_components ( graph ) ) ) outfile . write ( \"Maximum component size: {} \\n \" . format ( nx . number_of_nodes ( components [ 0 ])) ) outfile . write ( \"Degree Histogram: {} \\n \" . format ( nx . degree_histogram ( graph ))) outfile . write ( \"Graph density: {} \\n \" . format ( nx . density ( graph ))) outfile . write ( \"Average node degree centrality: {} \\n \" . format ( sum ( cent_dict . values ()) / len ( list ( cent_dict . values ())) ) ) outfile . write ( \"Average node clustering: {} \\n \" . format ( nx . average_clustering ( graph ))) outfile . close () write_report ( file_name , run_id , t , runseed , popseed , stats , params , outdir ) Core function for writing reports, writes header if file is new, then data based on the params and name_map Parameters: Name Type Description Default file_name str Name of the file to write, including the extension (e.g. MyReport.txt ) required run_id str unique identifier for this model required t int current timestep required runseed int integer used to seed the random number generator for the model required popseed int integer used to seed the random number generator for the population required stats Dict nested dictionary of agent attributes to counts required params ObjMap model parameters required outdir str path of where to save this file required Source code in titan/output.py def write_report ( file_name : str , run_id : str , t : int , runseed : int , popseed : int , stats : Dict , params : ObjMap , outdir : str , ): \"\"\" Core function for writing reports, writes header if file is new, then data based on the `params` and `name_map` args: file_name: Name of the file to write, including the extension (e.g. `MyReport.txt`) run_id: unique identifier for this model t: current timestep runseed: integer used to seed the random number generator for the model popseed: integer used to seed the random number generator for the population stats: nested dictionary of agent attributes to counts params: model parameters outdir: path of where to save this file \"\"\" def get_stat_names ( stats , attrs ): stat_ref = stats for i in range ( len ( attrs )): stat_ref = stat_ref [ list ( stat_ref . keys ())[ 0 ]] return stat_ref f = open ( os . path . join ( outdir , file_name ), \"a\" ) attrs = [ clss [: - 1 ] for clss in params . outputs . classes ] stat_names = get_stat_names ( stats , attrs ) if f . tell () == 0 : f . write ( \"run_id \\t rseed \\t pseed \\t t \\t \" ) # start header # attributes in stats f . write ( \" \\t \" . join ( attrs )) # report specific fields for name in stat_names : f . write ( f \" \\t { name } \" ) f . write ( \" \\n \" ) for agg in get_aggregates ( params ): # don't write row if no agents are in it if get_agg_val ( stats , agg , \"agents\" ) > 0 : f . write ( f \" { run_id } \\t { runseed } \\t { popseed } \\t { t } \\t \" ) f . write ( \" \\t \" . join ( agg )) # write attribute values for name in stat_names : f . write ( f \" \\t { ( get_agg_val ( stats , agg , name )) } \" ) f . write ( \" \\n \" ) f . close ()","title":"Reporting"},{"location":"api/reporting/#reporting","text":"","title":"Reporting"},{"location":"api/reporting/#titan.output.add_agent_to_stats","text":"Update the stats dictionary counts for the key given the agent's attributes Parameters: Name Type Description Default stats_item Dict[str, int] the leaf node of a nested dictionary of attributes to counts required key str the type of count to increment required Source code in titan/output.py def add_agent_to_stats ( stats_item : Dict [ str , int ], key : str ): \"\"\" Update the stats dictionary counts for the key given the agent's attributes args: stats_item: the leaf node of a nested dictionary of attributes to counts key: the type of count to increment \"\"\" stats_item [ key ] += 1","title":"add_agent_to_stats()"},{"location":"api/reporting/#titan.output.basicReport","text":"Standard report writer for basic agent statistics, columns include: \"agents\": number of agents in the population \"deaths\": number of agents who died this time period \"deaths_hiv\": number of agents with HIV who died this time period Additionally, any feature enabled may have additional stats that are tracked. See the feature's stats attribute and docs for details. Source code in titan/output.py def basicReport ( run_id : str , t : int , runseed : int , popseed : int , stats : Dict [ str , Any ], params : ObjMap , outdir : str , ): \"\"\" Standard report writer for basic agent statistics, columns include: * \"agents\": number of agents in the population * \"deaths\": number of agents who died this time period * \"deaths_hiv\": number of agents with HIV who died this time period Additionally, any feature enabled may have additional stats that are tracked. See the feature's `stats` attribute and docs for details. \"\"\" write_report ( \"basicReport.txt\" , run_id , t , runseed , popseed , stats , params , outdir )","title":"basicReport()"},{"location":"api/reporting/#titan.output.get_agg_val","text":"Get the value of a key in stats given the attribute values Parameters: Name Type Description Default stats Dict a nested dictionary of attributes to count required attrs List a list of attribute values to find the count for required key str the type of count to get the value of required Returns: Type Description int the count of key for the given attributes Source code in titan/output.py def get_agg_val ( stats : Dict , attrs : List , key : str ) -> int : \"\"\" Get the value of a key in stats given the attribute values args: stats: a nested dictionary of attributes to count attrs: a list of attribute values to find the count for key: the type of count to get the value of returns: the count of key for the given attributes \"\"\" stats_item = stats for attr in attrs : stats_item = stats_item [ attr ] return stats_item [ key ]","title":"get_agg_val()"},{"location":"api/reporting/#titan.output.get_aggregates","text":"Get iterator over all attribute combinations for output classes Parameters: Name Type Description Default params ObjMap model parameters required Returns: Type Description Iterator iterator over attribute combinations Source code in titan/output.py def get_aggregates ( params : ObjMap ) -> Iterator : \"\"\" Get iterator over all attribute combinations for output classes args: params: model parameters returns: iterator over attribute combinations \"\"\" return itertools . product ( * [ list ( k for k in params . classes [ clss ]) for clss in params . outputs . classes ] )","title":"get_aggregates()"},{"location":"api/reporting/#titan.output.get_stats","text":"Get the current statistics for a model based on the population, and tracking agent sets from the model. Parameters: Name Type Description Default all_agents ag.AgentSet all of the agents in the population required new_hiv.dx agents who are newly diagnosed with hiv this timestep required deaths List[ag.Agent] agents who died this timestep required params ObjMap model parameters required Returns: Type Description Dict nested dictionary of agent attributes to counts of various items Source code in titan/output.py def get_stats ( all_agents : \"ag.AgentSet\" , deaths : List [ \"ag.Agent\" ], params : ObjMap , exposures , features , time : int , ) -> Dict : \"\"\" Get the current statistics for a model based on the population, and tracking agent sets from the model. args: all_agents: all of the agents in the population new_hiv.dx: agents who are newly diagnosed with hiv this timestep deaths: agents who died this timestep params: model parameters returns: nested dictionary of agent attributes to counts of various items \"\"\" reportables = exposures + features stats = setup_aggregates ( params , reportables , params . outputs . classes ) # attribute names (non-plural) attrs = [ clss [: - 1 ] for clss in params . outputs . classes ] for a in all_agents : stats_item = get_stats_item ( stats , attrs , a ) add_agent_to_stats ( stats_item , \"agents\" ) for reportable in reportables : agent_feature = getattr ( a , reportable . name ) agent_feature . set_stats ( stats_item , time ) for a in deaths : stats_item = get_stats_item ( stats , attrs , a ) add_agent_to_stats ( stats_item , \"deaths\" ) if a . hiv . active : # type: ignore[attr-defined] add_agent_to_stats ( stats_item , \"deaths_hiv\" ) return stats","title":"get_stats()"},{"location":"api/reporting/#titan.output.get_stats_item","text":"Get the leaf node of the stats dictionary for the given attributes and agent. Parameters: Name Type Description Default stats Dict[str, Any] a nested dictionary of attributes to count required attrs List[str] a list of attribute values to find the count for required agent ag.Agent The agent to get the leaf node for required Returns: Type Description a stats_item dictionary of keys to counts Source code in titan/output.py def get_stats_item ( stats : Dict [ str , Any ], attrs : List [ str ], agent : \"ag.Agent\" ): \"\"\" Get the leaf node of the stats dictionary for the given attributes and agent. args: stats: a nested dictionary of attributes to count attrs: a list of attribute values to find the count for agent: The agent to get the leaf node for returns: a stats_item dictionary of keys to counts \"\"\" stats_item = stats for attr in attrs : stats_item = stats_item [ str ( getattr ( agent , attr ))] return stats_item","title":"get_stats_item()"},{"location":"api/reporting/#titan.output.print_components","text":"Write stats describing the components (sub-graphs) in a graph to file Parameters: Name Type Description Default run_id str unique identifer for this run of the model required t int current timestep required runseed int integer used to seed the model's random number generator required popseed int integer used to seed the population's random number generator required components List a list of graph components required outdir str path where the file should be saved required races the races in the population required Source code in titan/output.py def print_components ( run_id : str , t : int , runseed : int , popseed : int , components : List , outdir : str , ): \"\"\" Write stats describing the components (sub-graphs) in a graph to file args: run_id: unique identifer for this run of the model t: current timestep runseed: integer used to seed the model's random number generator popseed: integer used to seed the population's random number generator components: a list of graph components outdir: path where the file should be saved races: the races in the population \"\"\" f = open ( os . path . join ( outdir , f \" { run_id } _componentReport_ALL.txt\" ), \"a\" ) # if this is a new file, write the header info if f . tell () == 0 : f . write ( \"run_id \\t runseed \\t popseed \\t t \\t component\" \" \\t density \\t EffectiveSize \\t deg_cent \\n \" ) for ( id , comp ) in enumerate ( components ): num_nodes = comp . number_of_nodes () average_size = effective_size ( comp ) / num_nodes comp_density = nx . density ( comp ) deg_cent = mean ( list ( nx . degree_centrality ( comp ) . values ())) f . write ( f \" { run_id } \\t { runseed } \\t { popseed } \\t { t } \\t { id } \\t \" f \" \\t { comp_density : .4f } \" f \" \\t { average_size : .4f } \\t { deg_cent } \\n \" ) f . close ()","title":"print_components()"},{"location":"api/reporting/#titan.output.setup_aggregates","text":"Recursively create a nested dictionary of attribute values to items to count. Attributes are classes defined in params, the items counted are: \"agents\" \"deaths\" \"deaths_hiv\" Additionally, any feature enabled may have additional stats that are tracked. See the feature's stats attribute. Parameters: Name Type Description Default params ObjMap model parameters required classes List[str] which classes to aggregate by [params.outputs.classes] required Returns: Type Description Dict dictionary of class values to counts Source code in titan/output.py def setup_aggregates ( params : ObjMap , reportables , classes : List [ str ]) -> Dict : \"\"\" Recursively create a nested dictionary of attribute values to items to count. Attributes are classes defined in params, the items counted are: * \"agents\" * \"deaths\" * \"deaths_hiv\" Additionally, any feature enabled may have additional stats that are tracked. See the feature's `stats` attribute. args: params: model parameters classes: which classes to aggregate by [params.outputs.classes] returns: dictionary of class values to counts \"\"\" if classes == []: base_stats = { \"agents\" : 0 , \"deaths\" : 0 , \"deaths_hiv\" : 0 , } for reportable in reportables : base_stats . update ({ stat : 0 for stat in reportable . stats }) return base_stats stats = {} clss , * rem_clss = classes # head, tail keys = [ k for k in params . classes [ clss ]] for key in keys : stats [ key ] = setup_aggregates ( params , reportables , rem_clss ) return stats","title":"setup_aggregates()"},{"location":"api/reporting/#titan.output.write_graph_edgelist","text":"Writes a pipe-delimited edge list to the file <id>_Edgelist_t<time>.txt Parameters: Name Type Description Default path str directory where the file should be saved required id identifier for the network, typically the model's id required time timestep the edgelist is being written at required Source code in titan/output.py def write_graph_edgelist ( graph , path : str , id , time ): \"\"\" Writes a pipe-delimited edge list to the file `<id>_Edgelist_t<time>.txt` args: path: directory where the file should be saved id: identifier for the network, typically the model's `id` time: timestep the edgelist is being written at \"\"\" file_path = os . path . join ( path , f \" { id } _Edgelist_t { time } .txt\" ) # Write edgelist with bond type nx . write_edgelist ( graph , file_path , delimiter = \"|\" , data = [ \"type\" ])","title":"write_graph_edgelist()"},{"location":"api/reporting/#titan.output.write_network_stats","text":"Writes network statistics to the file <id>_NetworkStats_t<time>.txt Parameters: Name Type Description Default path str directory where the file should be saved required id identifier for the network, typically the model's id required time timestep the edgelist is being written at required Source code in titan/output.py def write_network_stats ( graph , path : str , id , time ): \"\"\" Writes network statistics to the file `<id>_NetworkStats_t<time>.txt` args: path: directory where the file should be saved id: identifier for the network, typically the model's `id` time: timestep the edgelist is being written at \"\"\" file_path = os . path . join ( path , f \" { id } _NetworkStats_t { time } .txt\" ) components = utils . connected_components ( graph ) outfile = open ( file_path , \"w\" ) outfile . write ( nx . info ( graph )) cent_dict = nx . degree_centrality ( graph ) outfile . write ( \" \\n Number of connected components: {} \\n \" . format ( nx . number_connected_components ( graph ) ) ) tot_nodes = 0 for c in components : tot_nodes += c . number_of_nodes () outfile . write ( \"Average component size: {} \\n \" . format ( tot_nodes * 1.0 / nx . number_connected_components ( graph ) ) ) outfile . write ( \"Maximum component size: {} \\n \" . format ( nx . number_of_nodes ( components [ 0 ])) ) outfile . write ( \"Degree Histogram: {} \\n \" . format ( nx . degree_histogram ( graph ))) outfile . write ( \"Graph density: {} \\n \" . format ( nx . density ( graph ))) outfile . write ( \"Average node degree centrality: {} \\n \" . format ( sum ( cent_dict . values ()) / len ( list ( cent_dict . values ())) ) ) outfile . write ( \"Average node clustering: {} \\n \" . format ( nx . average_clustering ( graph ))) outfile . close ()","title":"write_network_stats()"},{"location":"api/reporting/#titan.output.write_report","text":"Core function for writing reports, writes header if file is new, then data based on the params and name_map Parameters: Name Type Description Default file_name str Name of the file to write, including the extension (e.g. MyReport.txt ) required run_id str unique identifier for this model required t int current timestep required runseed int integer used to seed the random number generator for the model required popseed int integer used to seed the random number generator for the population required stats Dict nested dictionary of agent attributes to counts required params ObjMap model parameters required outdir str path of where to save this file required Source code in titan/output.py def write_report ( file_name : str , run_id : str , t : int , runseed : int , popseed : int , stats : Dict , params : ObjMap , outdir : str , ): \"\"\" Core function for writing reports, writes header if file is new, then data based on the `params` and `name_map` args: file_name: Name of the file to write, including the extension (e.g. `MyReport.txt`) run_id: unique identifier for this model t: current timestep runseed: integer used to seed the random number generator for the model popseed: integer used to seed the random number generator for the population stats: nested dictionary of agent attributes to counts params: model parameters outdir: path of where to save this file \"\"\" def get_stat_names ( stats , attrs ): stat_ref = stats for i in range ( len ( attrs )): stat_ref = stat_ref [ list ( stat_ref . keys ())[ 0 ]] return stat_ref f = open ( os . path . join ( outdir , file_name ), \"a\" ) attrs = [ clss [: - 1 ] for clss in params . outputs . classes ] stat_names = get_stat_names ( stats , attrs ) if f . tell () == 0 : f . write ( \"run_id \\t rseed \\t pseed \\t t \\t \" ) # start header # attributes in stats f . write ( \" \\t \" . join ( attrs )) # report specific fields for name in stat_names : f . write ( f \" \\t { name } \" ) f . write ( \" \\n \" ) for agg in get_aggregates ( params ): # don't write row if no agents are in it if get_agg_val ( stats , agg , \"agents\" ) > 0 : f . write ( f \" { run_id } \\t { runseed } \\t { popseed } \\t { t } \\t \" ) f . write ( \" \\t \" . join ( agg )) # write attribute values for name in stat_names : f . write ( f \" \\t { ( get_agg_val ( stats , agg , name )) } \" ) f . write ( \" \\n \" ) f . close ()","title":"write_report()"},{"location":"api/utilities/","text":"General Utilities binom_0 ( n , p ) Mirrors scipy binom.pmf as used in code Source code in titan/utils.py def binom_0 ( n : int , p : float ): \"\"\" Mirrors scipy binom.pmf as used in code \"\"\" return ( 1 - p ) ** n connected_components ( graph ) Get connected components in graph Parameters: Name Type Description Default graph the model's underlying graph required Returns: Type Description list of connected components Source code in titan/utils.py def connected_components ( graph ): \"\"\" Get connected components in graph args: graph: the model's underlying graph returns: list of connected components \"\"\" return sorted ( list ( graph . subgraph ( c ) for c in nx . connected_components ( graph )), key = len , reverse = True , ) get_check_rand_int ( seed ) Check the value passed of a seed, make sure it's an int, if 0, get a random seed Parameters: Name Type Description Default seed int integer to check or replace with a seed required Returns: Type Description int validated seed Source code in titan/utils.py def get_check_rand_int ( seed : int ) -> int : \"\"\" Check the value passed of a seed, make sure it's an int, if 0, get a random seed args: seed: integer to check or replace with a seed returns: validated seed \"\"\" if type ( seed ) is not int or seed < 0 : raise ValueError ( \"Random seed must be positive integer\" ) elif seed == 0 : return random . randint ( 1 , 1000000 ) else : return seed get_cumulative_bin ( rand_gen , bin_def ) Get the bin key given cumulative bins. A probability is selected at random, then each bin's prob is compared to it, the first bin that has a cumulative prob (e.g. for bin 2, the prob of bin 1 plus the prob of bin 2) less than or equal to that probability is returned. Parameters: Name Type Description Default rand_gen random number generator required bin_def ObjMap ObjMap containing the bins required Returns: Type Description int integer key of the matched bin (or last bin if no matches) Source code in titan/utils.py def get_cumulative_bin ( rand_gen , bin_def : ObjMap ) -> int : \"\"\" Get the bin key given cumulative bins. A probability is selected at random, then each bin's `prob` is compared to it, the first bin that has a cumulative `prob` (e.g. for bin 2, the prob of bin 1 plus the prob of bin 2) less than or equal to that probability is returned. args: rand_gen: random number generator bin_def: ObjMap containing the bins returns: integer key of the matched bin (or last bin if no matches) \"\"\" rand_val = rand_gen . random () p = 0.0 for bin , fields in bin_def . items (): p += fields . prob if rand_val <= p : break return bin get_independent_bin ( rand_gen , bin_def ) Get the bin key given independent bins. A probability is selected at random, then each bin's prob is compared to it, the first bin that has a prob less than or equal to that probability is returned. Parameters: Name Type Description Default rand_gen A random number generator required bin_def ObjMap The ObjMap containing the bins required Returns: Type Description int The integer key of the matched bin (or last bin if no matches) Source code in titan/utils.py def get_independent_bin ( rand_gen , bin_def : ObjMap ) -> int : \"\"\" Get the bin key given independent bins. A probability is selected at random, then each bin's `prob` is compared to it, the first bin that has a `prob` less than or equal to that probability is returned. args: rand_gen: A random number generator bin_def: The ObjMap containing the bins returns: The integer key of the matched bin (or last bin if no matches) \"\"\" rand_val = rand_gen . random () for bin , fields in bin_def . items (): if rand_val <= fields . prob : break return bin get_param_from_path ( params , param_path , delimiter ) Given a params object and a delimited path, get the leaf of the params tree and the last key to access it Source code in titan/utils.py def get_param_from_path ( params : ObjMap , param_path : str , delimiter : str ): \"\"\" Given a params object and a delimited path, get the leaf of the params tree and the last key to access it \"\"\" path = param_path . split ( delimiter ) path_params = params for p in path [: - 1 ]: try : path_params = path_params [ p ] except KeyError : path_params = path_params [ int ( p )] return path_params , path [ - 1 ] grid_file_to_edge_yml ( file_path , outfile_path , diagonal_neighbors = False ) Read a csv describing the layout of locations and write the results to a yml file describing the location edges, which can then be used in the params [location.edges]. Sample csv: location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_2, location_2,location_2, Would generate the edges: * location_1, location_3 * location_1, location_2 * location_2, location_3 * location_3, location_4 If diagonal_neighbors were True, the edge [location_2, location_4] would also be returned. Parameters: Name Type Description Default file_path str path to a csv file which contains a layout for the locations in the model. required outfile_path str path where the resulting yml file should be saved required diagonal_neighbors bool whether diagonally adjacent cells should be considered neighbors [default false] False Source code in titan/utils.py def grid_file_to_edge_yml ( file_path : str , outfile_path : str , diagonal_neighbors : bool = False ) -> None : \"\"\" Read a csv describing the layout of locations and write the results to a yml file describing the location edges, which can then be used in the params [location.edges]. Sample csv: ``` location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_2, location_2,location_2, ``` Would generate the edges: * location_1, location_3 * location_1, location_2 * location_2, location_3 * location_3, location_4 If `diagonal_neighbors` were True, the edge [location_2, location_4] would also be returned. args: file_path: path to a csv file which contains a layout for the locations in the model. outfile_path: path where the resulting yml file should be saved diagonal_neighbors: whether diagonally adjacent cells should be considered neighbors [default false] \"\"\" edges = grid_file_to_edges ( file_path , diagonal_neighbors = diagonal_neighbors ) with open ( outfile_path , \"w\" ) as f : yaml . dump ({ \"edges\" : edges }, f ) grid_file_to_edges ( file_path , diagonal_neighbors = False ) Read a csv describing the layout of locations and return a dictionary describing the location edges, which can then be used in the params [location.edges]. Sample csv: location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_2, location_2,location_2, Would generate the edges: * location_1, location_3 * location_1, location_2 * location_2, location_3 * location_3, location_4 If diagonal_neighbors were True, the edge [location_2, location_4] would also be returned. Parameters: Name Type Description Default file_path str path to a csv file which contains a layout for the locations in the model. required diagonal_neighbors bool whether diagonally adjacent cells should be considered neighbors [default false] False Returns: Type Description Dict A dictionary with generated edge names to locations Source code in titan/utils.py def grid_file_to_edges ( file_path : str , diagonal_neighbors : bool = False ) -> Dict : \"\"\" Read a csv describing the layout of locations and return a dictionary describing the location edges, which can then be used in the params [location.edges]. Sample csv: ``` location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_2, location_2,location_2, ``` Would generate the edges: * location_1, location_3 * location_1, location_2 * location_2, location_3 * location_3, location_4 If `diagonal_neighbors` were True, the edge [location_2, location_4] would also be returned. args: file_path: path to a csv file which contains a layout for the locations in the model. diagonal_neighbors: whether diagonally adjacent cells should be considered neighbors [default false] returns: A dictionary with generated edge names to locations \"\"\" # read in the grid grid = [] with open ( file_path , newline = \"\" ) as f : reader = csv . reader ( f ) for row in reader : grid . append ( row ) # generate edge pairs edges : Set [ Tuple [ str , str ]] = set () for i in range ( len ( grid ) - 1 ): for j in range ( len ( grid [ 0 ]) - 1 ): loc = grid [ i ][ j ] if loc == \"\" : continue add_edge ( edges , loc , grid [ i + 1 ][ j ]) add_edge ( edges , loc , grid [ i ][ j + 1 ]) if diagonal_neighbors : add_edge ( edges , loc , grid [ i + 1 ][ j + 1 ]) if i >= 1 : add_edge ( edges , loc , grid [ i - 1 ][ j + 1 ]) if j >= 1 : add_edge ( edges , loc , grid [ i + 1 ][ j - 1 ]) res = {} for ( i , edge ) in enumerate ( edges ): res [ f \"edge_ { i + 1 } \" ] = { \"location_1\" : edge [ 0 ], \"location_2\" : edge [ 1 ]} return res memo ( f ) Decorator to memoize a function (caches results given args, only use if deterministic) Source code in titan/utils.py def memo ( f ): \"\"\" Decorator to memoize a function (caches results given args, only use if deterministic) \"\"\" cache = {} @wraps ( f ) def wrap ( * arg ): if arg not in cache : cache [ arg ] = f ( * arg ) return cache [ arg ] return wrap override_param ( params , param_path , value , delimiter = '|' ) Given the params and a parameter path in the format prep|cap, change the current value to new value Source code in titan/utils.py def override_param ( params : ObjMap , param_path : str , value , delimiter = \"|\" ): \"\"\" Given the params and a parameter path in the format prep|cap, change the current value to new value \"\"\" override_item , last_key = get_param_from_path ( params , param_path , delimiter ) try : old_val = override_item [ last_key ] except KeyError : last_key = int ( last_key ) old_val = override_item [ last_key ] logging . info ( f \"overriding - { param_path } : { old_val } => { value } \" ) override_item [ last_key ] = value poisson ( mu , np_rand ) Mirrors scipy poisson.rvs function as used in code Source code in titan/utils.py def poisson ( mu : float , np_rand ): \"\"\" Mirrors scipy poisson.rvs function as used in code \"\"\" return np_rand . poisson ( mu ) safe_dist ( dist_info , rand_gen ) Draw a value from a distribution as defined in dist_info . Parameters: Name Type Description Default dist_info ObjMap a definition of a distribution to use [params.classes.distributions] required rand_gen random number generator required Returns: Type Description Union[int, float] a value drawn from the distribution Source code in titan/utils.py def safe_dist ( dist_info : ObjMap , rand_gen ) -> Union [ int , float ]: \"\"\" Draw a value from a distribution as defined in `dist_info`. args: dist_info: a definition of a distribution to use [params.classes.distributions] rand_gen: random number generator returns: a value drawn from the distribution \"\"\" # gather arguments args = [] for d in dist_info . vars . values (): args . append ( parse_var ( d . value , d . value_type )) dist = get_dist ( rand_gen , dist_info . dist_type ) value = dist ( * args ) if hasattr ( value , \"__iter__\" ): # check if value is any type of sequence return value [ 0 ] else : return value safe_divide ( numerator , denominator ) Divide two numbers, but default 0 if denominator is 0, otherwise divide as normal. Parameters: Name Type Description Default numerator int number being divided required denominator int number doing the dividing required Returns: Type Description float resulting number Source code in titan/utils.py def safe_divide ( numerator : int , denominator : int ) -> float : \"\"\" Divide two numbers, but default 0 if denominator is 0, otherwise divide as normal. args: numerator: number being divided denominator: number doing the dividing returns: resulting number \"\"\" if denominator == 0 : return 0.0 else : return 1.0 * numerator / denominator safe_random_choice ( seq , rand_gen , weights = None ) Return None or a random choice from a collection of items Parameters: Name Type Description Default seq collection to select a random item from required rand_gen random number generator required weights an optional collection of weights to use instead of a uniform distribution None Returns: Type Description an item, or None if the collection is empty Source code in titan/utils.py def safe_random_choice ( seq , rand_gen , weights = None ): \"\"\" Return None or a random choice from a collection of items args: seq: collection to select a random item from rand_gen: random number generator weights: an optional collection of weights to use instead of a uniform distribution returns: an item, or `None` if the collection is empty \"\"\" if not seq : return None if isinstance ( seq , set ): seq = tuple ( seq ) # don't call out to random choices if we don't need to (for performance) if len ( seq ) == 1 : return seq [ 0 ] elif len ( seq ) == 2 and weights is None : return seq [ 0 ] if rand_gen . random () <= 0.5 else seq [ 1 ] choices = rand_gen . choices ( seq , weights = weights ) return choices [ 0 ] safe_random_int ( start , stop , rand_gen ) Return an integer between [start, stop) Parameters: Name Type Description Default start int start value required stop int stop value required rand_gen random number generator required Returns: Type Description int an item, or None if the collection is empty Source code in titan/utils.py def safe_random_int ( start : int , stop : int , rand_gen ) -> int : \"\"\" Return an integer between [start, stop) args: start: start value stop: stop value rand_gen: random number generator returns: an item, or `None` if the collection is empty \"\"\" return floor ( rand_gen . random () * ( stop - start ) + start ) safe_shuffle ( seq , rand_gen ) Return None or a shuffled sequence Parameters: Name Type Description Default seq Collection[~T] collection to shuffle required rand_gen random number generator required Returns: Type Description Iterable[~T] shuffled sequence, or None if empty Source code in titan/utils.py def safe_shuffle ( seq : Collection [ T ], rand_gen ) -> Iterable [ T ]: \"\"\" Return None or a shuffled sequence args: seq: collection to shuffle rand_gen: random number generator returns: shuffled sequence, or `None` if empty \"\"\" if seq : if isinstance ( seq , set ): seq = list ( seq ) rand_gen . shuffle ( seq ) return seq else : return [] scale_param ( params , param_path , scalar , delimiter = '|' ) Given the params and a parameter path in the format prep|cap, scale the current value by the scalar Source code in titan/utils.py def scale_param ( params : ObjMap , param_path : str , scalar : float , delimiter = \"|\" ): \"\"\" Given the params and a parameter path in the format prep|cap, scale the current value by the scalar \"\"\" scaling_item , last_key = get_param_from_path ( params , param_path , delimiter ) old_val = scaling_item [ last_key ] logging . info ( f \"scaling - { param_path } : { old_val } => { old_val * scalar } \" ) scaling_item [ last_key ] = old_val * scalar total_probability ( p , num_acts ) Given a per act probability and a number of acts, return the total probability. Parameters: Name Type Description Default p float the per act probability required num_acts int the number of acts required Returns: Type Description float the total probability Source code in titan/utils.py def total_probability ( p : float , num_acts : int ) -> float : \"\"\" Given a per act probability and a number of acts, return the total probability. args: p: the per act probability num_acts: the number of acts returns: the total probability \"\"\" if num_acts == 1 : return p elif num_acts >= 1 : return 1.0 - binom_0 ( num_acts , p ) else : return 0.0 Params ObjMap A dictionary-like class which allows accessing members either using standard dictionary notation or dots. Note the hash function is hard-coded - beware. __hash__ ( self ) special Return hash(self). Source code in titan/parse_params.py def __hash__ ( self ): return 1234567890 check_params ( params ) Consistency checks for param populations Source code in titan/parse_params.py def check_params ( params : ObjMap ): \"\"\" Consistency checks for param populations \"\"\" race_pop = 0 for race in params . classes . races : r_dems = params . demographics [ race ] race_pop += r_dems . ppl sex_type_pop = 0 for st , st_dems in r_dems . sex_type . items (): if st in list ( params . classes . sex_types . keys ()): sex_type_pop += st_dems . ppl drug_type_pop = 0 for dt , dt_dems in st_dems . drug_type . items (): if dt in list ( params . classes . drug_types ): drug_type_pop += dt_dems . ppl assert math . isclose ( drug_type_pop , 1 , abs_tol = 0.001 ), f \"ppl of { race } 's { st } 's drug_types must add to 1. Currently adding to { drug_type_pop } \" assert math . isclose ( sex_type_pop , 1 , abs_tol = 0.001 ), f \"ppl of { race } 's sex_types must add to 1. Currently adding to { sex_type_pop } \" assert math . isclose ( race_pop , 1 , abs_tol = 0.001 ), \"ppl of races must add to 1\" loc_pop = 0 for location in params . classes . locations . values (): loc_pop += location . ppl assert math . isclose ( loc_pop , 1 , abs_tol = 0.001 ), \"ppl of locations must add to 1\" for param , assort in params . assort_mix . items (): assort_value = 0 for ptnr_value in assort . partner_values . values (): assort_value += ptnr_value assert math . isclose ( assort_value , 1 , abs_tol = 0.001 ), f \"assort values must add to 1, not { assort_value } in { param } \" create_params ( setting_name , param_path , outdir , error_on_unused = False ) Entry function - given the path to the setting, params, output directory and whether or not to use the base setting. Parse and create a params (ObjMap) object. Parameters: Name Type Description Default setting_name Optional[str] path to a settings file or directory or None required param_path str path to parameter file or directory required outdir str path to directory where computed params will be saved required error_on_unused bool throw a hard error if there are unused parameters, otherwise warnings are only printed False Returns: Type Description ObjMap computed/validated model paramters with defaults filled in where needed Source code in titan/parse_params.py def create_params ( setting_name : Optional [ str ], param_path : str , outdir : str , error_on_unused : bool = False , ) -> ObjMap : \"\"\" Entry function - given the path to the setting, params, output directory and whether or not to use the base setting. Parse and create a params (ObjMap) object. args: setting_name: path to a settings file or directory or `None` param_path: path to parameter file or directory outdir: path to directory where computed params will be saved error_on_unused: throw a hard error if there are unused parameters, otherwise warnings are only printed returns: computed/validated model paramters with defaults filled in where needed \"\"\" # find defs, where we are in the code for settings and base filename = getsourcefile ( create_params ) # what is the sourcefile for this function if filename is not None : parent = Path ( filename ) . resolve () . parent else : raise Exception ( \"can't find where I am in the code?\" ) param_defs = os . path . join ( parent , \"params\" ) param_paths = [] # merge setting and params if setting_name is not None : # check if it's a known setting or pass it through as a path if setting_name in os . listdir ( os . path . join ( parent , \"settings\" )): param_paths . append ( os . path . join ( parent , \"settings\" , setting_name )) else : param_paths . append ( setting_name ) param_paths . append ( param_path ) parsed = paraml . create_params ( param_defs , * param_paths , out_path = os . path . join ( outdir , \"params.yml\" ), error_on_unused = error_on_unused , ) parsed = ObjMap ( parsed ) check_params ( parsed ) # copy migration file if enabled if parsed . location . migration . enabled : shutil . copy ( parsed . location . migration . probs_file , os . path . join ( outdir , \"migration_probs.csv\" ), ) return parsed Probability Distributions pert ( np_random , low , peak , high , temperature ) A pert distribution, inspired by tensorflow arguments must be so that: low < peak < high temperature > 0 The support is [low, high] . The peak must fit in that interval: low < peak < high . The temperature is a positive parameter that controls the shape of the distribution. Higher values yield a sharper peak. Parameters: Name Type Description Default np_random random number generator (used to get beta) required low distribution low value required peak modal point in distribution required high distribution high value required temperature scaling factor required Source code in titan/distributions.py def pert ( np_random , low , peak , high , temperature ): \"\"\" A pert distribution, inspired by [tensorflow](https://github.com/tensorflow/probability/blob/c833ee5cd9f60f3257366b25447b9e50210b0590/tensorflow_probability/python/distributions/pert.py#L137) arguments must be so that: * low < peak < high * temperature > 0 The support is `[low, high]`. The `peak` must fit in that interval: `low < peak < high`. The `temperature` is a positive parameter that controls the shape of the distribution. Higher values yield a sharper peak. args: np_random: random number generator (used to get beta) low: distribution low value peak: modal point in distribution high: distribution high value temperature: scaling factor \"\"\" assert low < peak < high assert temperature > 0 scale = high - low alpha = 1.0 + temperature * ( peak - low ) / scale beta = 1.0 + temperature * ( high - peak ) / scale return low + scale * np_random . beta ( alpha , beta ) set_value ( np_random , value ) A distribution that always returns the value passed Parameters: Name Type Description Default np_random random number generator (to conform to distribution interface) required value value to return required Source code in titan/distributions.py def set_value ( np_random , value ): \"\"\" A distribution that always returns the value passed args: np_random: random number generator (to conform to distribution interface) value: value to return \"\"\" return value weibull_modified ( np_random , shape , scale ) Modified version of numpy's (single parameter) weibull distribution to use the 2-parameter weibull. Parameters: Name Type Description Default np_random random number generator required shape weibull shape parameter required scale weibull scale parameter required Source code in titan/distributions.py def weibull_modified ( np_random , shape , scale ): \"\"\" Modified version of numpy's (single parameter) weibull distribution to use the 2-parameter weibull. args: np_random: random number generator shape: weibull shape parameter scale: weibull scale parameter \"\"\" random_number = np_random . random () return scale * ( - log ( 1 - random_number )) ** ( 1 / shape ) Complex Probabilities get_death_rate ( hiv , aids , drug_type , sex_type , haart_adh , race , location , steps_per_year ) Find the death rate of an agent given a set of attributes. Parameters: Name Type Description Default hiv bool whether the agent is HIV+ required aids bool whether the agent has AIDS required drug_type str whether the PWID base death rate should be used or the base one required haart_adh bool whether an agent is haart adherent required race str the race of the agent required location Location agent's location required steps_per_year int the number of model steps in a year required Returns: Type Description float the probability of an agent with these characteristics dying in a given time step Source code in titan/probabilities.py @utils . memo def get_death_rate ( hiv : bool , aids : bool , drug_type : str , sex_type : str , haart_adh : bool , race : str , location : Location , steps_per_year : int , ) -> float : \"\"\" Find the death rate of an agent given a set of attributes. args: hiv: whether the agent is HIV+ aids: whether the agent has AIDS drug_type: whether the PWID base death rate should be used or the base one haart_adh: whether an agent is haart adherent race: the race of the agent location: agent's location steps_per_year: the number of model steps in a year returns: the probability of an agent with these characteristics dying in a given time step \"\"\" param = location . params . demographics death_param = param [ race ] . sex_type [ sex_type ] . drug_type [ drug_type ] . death_rate p = death_param . base if aids : p *= death_param . aids elif hiv : if haart_adh : p *= death_param . haart_adherent else : p *= death_param . hiv # putting it into per 1 person-month from per 1000 person years return p / ( steps_per_year * 1000.0 )","title":"Utility Functions"},{"location":"api/utilities/#general-utilities","text":"","title":"General Utilities"},{"location":"api/utilities/#titan.utils.binom_0","text":"Mirrors scipy binom.pmf as used in code Source code in titan/utils.py def binom_0 ( n : int , p : float ): \"\"\" Mirrors scipy binom.pmf as used in code \"\"\" return ( 1 - p ) ** n","title":"binom_0()"},{"location":"api/utilities/#titan.utils.connected_components","text":"Get connected components in graph Parameters: Name Type Description Default graph the model's underlying graph required Returns: Type Description list of connected components Source code in titan/utils.py def connected_components ( graph ): \"\"\" Get connected components in graph args: graph: the model's underlying graph returns: list of connected components \"\"\" return sorted ( list ( graph . subgraph ( c ) for c in nx . connected_components ( graph )), key = len , reverse = True , )","title":"connected_components()"},{"location":"api/utilities/#titan.utils.get_check_rand_int","text":"Check the value passed of a seed, make sure it's an int, if 0, get a random seed Parameters: Name Type Description Default seed int integer to check or replace with a seed required Returns: Type Description int validated seed Source code in titan/utils.py def get_check_rand_int ( seed : int ) -> int : \"\"\" Check the value passed of a seed, make sure it's an int, if 0, get a random seed args: seed: integer to check or replace with a seed returns: validated seed \"\"\" if type ( seed ) is not int or seed < 0 : raise ValueError ( \"Random seed must be positive integer\" ) elif seed == 0 : return random . randint ( 1 , 1000000 ) else : return seed","title":"get_check_rand_int()"},{"location":"api/utilities/#titan.utils.get_cumulative_bin","text":"Get the bin key given cumulative bins. A probability is selected at random, then each bin's prob is compared to it, the first bin that has a cumulative prob (e.g. for bin 2, the prob of bin 1 plus the prob of bin 2) less than or equal to that probability is returned. Parameters: Name Type Description Default rand_gen random number generator required bin_def ObjMap ObjMap containing the bins required Returns: Type Description int integer key of the matched bin (or last bin if no matches) Source code in titan/utils.py def get_cumulative_bin ( rand_gen , bin_def : ObjMap ) -> int : \"\"\" Get the bin key given cumulative bins. A probability is selected at random, then each bin's `prob` is compared to it, the first bin that has a cumulative `prob` (e.g. for bin 2, the prob of bin 1 plus the prob of bin 2) less than or equal to that probability is returned. args: rand_gen: random number generator bin_def: ObjMap containing the bins returns: integer key of the matched bin (or last bin if no matches) \"\"\" rand_val = rand_gen . random () p = 0.0 for bin , fields in bin_def . items (): p += fields . prob if rand_val <= p : break return bin","title":"get_cumulative_bin()"},{"location":"api/utilities/#titan.utils.get_independent_bin","text":"Get the bin key given independent bins. A probability is selected at random, then each bin's prob is compared to it, the first bin that has a prob less than or equal to that probability is returned. Parameters: Name Type Description Default rand_gen A random number generator required bin_def ObjMap The ObjMap containing the bins required Returns: Type Description int The integer key of the matched bin (or last bin if no matches) Source code in titan/utils.py def get_independent_bin ( rand_gen , bin_def : ObjMap ) -> int : \"\"\" Get the bin key given independent bins. A probability is selected at random, then each bin's `prob` is compared to it, the first bin that has a `prob` less than or equal to that probability is returned. args: rand_gen: A random number generator bin_def: The ObjMap containing the bins returns: The integer key of the matched bin (or last bin if no matches) \"\"\" rand_val = rand_gen . random () for bin , fields in bin_def . items (): if rand_val <= fields . prob : break return bin","title":"get_independent_bin()"},{"location":"api/utilities/#titan.utils.get_param_from_path","text":"Given a params object and a delimited path, get the leaf of the params tree and the last key to access it Source code in titan/utils.py def get_param_from_path ( params : ObjMap , param_path : str , delimiter : str ): \"\"\" Given a params object and a delimited path, get the leaf of the params tree and the last key to access it \"\"\" path = param_path . split ( delimiter ) path_params = params for p in path [: - 1 ]: try : path_params = path_params [ p ] except KeyError : path_params = path_params [ int ( p )] return path_params , path [ - 1 ]","title":"get_param_from_path()"},{"location":"api/utilities/#titan.utils.grid_file_to_edge_yml","text":"Read a csv describing the layout of locations and write the results to a yml file describing the location edges, which can then be used in the params [location.edges]. Sample csv: location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_2, location_2,location_2, Would generate the edges: * location_1, location_3 * location_1, location_2 * location_2, location_3 * location_3, location_4 If diagonal_neighbors were True, the edge [location_2, location_4] would also be returned. Parameters: Name Type Description Default file_path str path to a csv file which contains a layout for the locations in the model. required outfile_path str path where the resulting yml file should be saved required diagonal_neighbors bool whether diagonally adjacent cells should be considered neighbors [default false] False Source code in titan/utils.py def grid_file_to_edge_yml ( file_path : str , outfile_path : str , diagonal_neighbors : bool = False ) -> None : \"\"\" Read a csv describing the layout of locations and write the results to a yml file describing the location edges, which can then be used in the params [location.edges]. Sample csv: ``` location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_2, location_2,location_2, ``` Would generate the edges: * location_1, location_3 * location_1, location_2 * location_2, location_3 * location_3, location_4 If `diagonal_neighbors` were True, the edge [location_2, location_4] would also be returned. args: file_path: path to a csv file which contains a layout for the locations in the model. outfile_path: path where the resulting yml file should be saved diagonal_neighbors: whether diagonally adjacent cells should be considered neighbors [default false] \"\"\" edges = grid_file_to_edges ( file_path , diagonal_neighbors = diagonal_neighbors ) with open ( outfile_path , \"w\" ) as f : yaml . dump ({ \"edges\" : edges }, f )","title":"grid_file_to_edge_yml()"},{"location":"api/utilities/#titan.utils.grid_file_to_edges","text":"Read a csv describing the layout of locations and return a dictionary describing the location edges, which can then be used in the params [location.edges]. Sample csv: location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_2, location_2,location_2, Would generate the edges: * location_1, location_3 * location_1, location_2 * location_2, location_3 * location_3, location_4 If diagonal_neighbors were True, the edge [location_2, location_4] would also be returned. Parameters: Name Type Description Default file_path str path to a csv file which contains a layout for the locations in the model. required diagonal_neighbors bool whether diagonally adjacent cells should be considered neighbors [default false] False Returns: Type Description Dict A dictionary with generated edge names to locations Source code in titan/utils.py def grid_file_to_edges ( file_path : str , diagonal_neighbors : bool = False ) -> Dict : \"\"\" Read a csv describing the layout of locations and return a dictionary describing the location edges, which can then be used in the params [location.edges]. Sample csv: ``` location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_3,location_4 location_1,location_2, location_2,location_2, ``` Would generate the edges: * location_1, location_3 * location_1, location_2 * location_2, location_3 * location_3, location_4 If `diagonal_neighbors` were True, the edge [location_2, location_4] would also be returned. args: file_path: path to a csv file which contains a layout for the locations in the model. diagonal_neighbors: whether diagonally adjacent cells should be considered neighbors [default false] returns: A dictionary with generated edge names to locations \"\"\" # read in the grid grid = [] with open ( file_path , newline = \"\" ) as f : reader = csv . reader ( f ) for row in reader : grid . append ( row ) # generate edge pairs edges : Set [ Tuple [ str , str ]] = set () for i in range ( len ( grid ) - 1 ): for j in range ( len ( grid [ 0 ]) - 1 ): loc = grid [ i ][ j ] if loc == \"\" : continue add_edge ( edges , loc , grid [ i + 1 ][ j ]) add_edge ( edges , loc , grid [ i ][ j + 1 ]) if diagonal_neighbors : add_edge ( edges , loc , grid [ i + 1 ][ j + 1 ]) if i >= 1 : add_edge ( edges , loc , grid [ i - 1 ][ j + 1 ]) if j >= 1 : add_edge ( edges , loc , grid [ i + 1 ][ j - 1 ]) res = {} for ( i , edge ) in enumerate ( edges ): res [ f \"edge_ { i + 1 } \" ] = { \"location_1\" : edge [ 0 ], \"location_2\" : edge [ 1 ]} return res","title":"grid_file_to_edges()"},{"location":"api/utilities/#titan.utils.memo","text":"Decorator to memoize a function (caches results given args, only use if deterministic) Source code in titan/utils.py def memo ( f ): \"\"\" Decorator to memoize a function (caches results given args, only use if deterministic) \"\"\" cache = {} @wraps ( f ) def wrap ( * arg ): if arg not in cache : cache [ arg ] = f ( * arg ) return cache [ arg ] return wrap","title":"memo()"},{"location":"api/utilities/#titan.utils.override_param","text":"Given the params and a parameter path in the format prep|cap, change the current value to new value Source code in titan/utils.py def override_param ( params : ObjMap , param_path : str , value , delimiter = \"|\" ): \"\"\" Given the params and a parameter path in the format prep|cap, change the current value to new value \"\"\" override_item , last_key = get_param_from_path ( params , param_path , delimiter ) try : old_val = override_item [ last_key ] except KeyError : last_key = int ( last_key ) old_val = override_item [ last_key ] logging . info ( f \"overriding - { param_path } : { old_val } => { value } \" ) override_item [ last_key ] = value","title":"override_param()"},{"location":"api/utilities/#titan.utils.poisson","text":"Mirrors scipy poisson.rvs function as used in code Source code in titan/utils.py def poisson ( mu : float , np_rand ): \"\"\" Mirrors scipy poisson.rvs function as used in code \"\"\" return np_rand . poisson ( mu )","title":"poisson()"},{"location":"api/utilities/#titan.utils.safe_dist","text":"Draw a value from a distribution as defined in dist_info . Parameters: Name Type Description Default dist_info ObjMap a definition of a distribution to use [params.classes.distributions] required rand_gen random number generator required Returns: Type Description Union[int, float] a value drawn from the distribution Source code in titan/utils.py def safe_dist ( dist_info : ObjMap , rand_gen ) -> Union [ int , float ]: \"\"\" Draw a value from a distribution as defined in `dist_info`. args: dist_info: a definition of a distribution to use [params.classes.distributions] rand_gen: random number generator returns: a value drawn from the distribution \"\"\" # gather arguments args = [] for d in dist_info . vars . values (): args . append ( parse_var ( d . value , d . value_type )) dist = get_dist ( rand_gen , dist_info . dist_type ) value = dist ( * args ) if hasattr ( value , \"__iter__\" ): # check if value is any type of sequence return value [ 0 ] else : return value","title":"safe_dist()"},{"location":"api/utilities/#titan.utils.safe_divide","text":"Divide two numbers, but default 0 if denominator is 0, otherwise divide as normal. Parameters: Name Type Description Default numerator int number being divided required denominator int number doing the dividing required Returns: Type Description float resulting number Source code in titan/utils.py def safe_divide ( numerator : int , denominator : int ) -> float : \"\"\" Divide two numbers, but default 0 if denominator is 0, otherwise divide as normal. args: numerator: number being divided denominator: number doing the dividing returns: resulting number \"\"\" if denominator == 0 : return 0.0 else : return 1.0 * numerator / denominator","title":"safe_divide()"},{"location":"api/utilities/#titan.utils.safe_random_choice","text":"Return None or a random choice from a collection of items Parameters: Name Type Description Default seq collection to select a random item from required rand_gen random number generator required weights an optional collection of weights to use instead of a uniform distribution None Returns: Type Description an item, or None if the collection is empty Source code in titan/utils.py def safe_random_choice ( seq , rand_gen , weights = None ): \"\"\" Return None or a random choice from a collection of items args: seq: collection to select a random item from rand_gen: random number generator weights: an optional collection of weights to use instead of a uniform distribution returns: an item, or `None` if the collection is empty \"\"\" if not seq : return None if isinstance ( seq , set ): seq = tuple ( seq ) # don't call out to random choices if we don't need to (for performance) if len ( seq ) == 1 : return seq [ 0 ] elif len ( seq ) == 2 and weights is None : return seq [ 0 ] if rand_gen . random () <= 0.5 else seq [ 1 ] choices = rand_gen . choices ( seq , weights = weights ) return choices [ 0 ]","title":"safe_random_choice()"},{"location":"api/utilities/#titan.utils.safe_random_int","text":"Return an integer between [start, stop) Parameters: Name Type Description Default start int start value required stop int stop value required rand_gen random number generator required Returns: Type Description int an item, or None if the collection is empty Source code in titan/utils.py def safe_random_int ( start : int , stop : int , rand_gen ) -> int : \"\"\" Return an integer between [start, stop) args: start: start value stop: stop value rand_gen: random number generator returns: an item, or `None` if the collection is empty \"\"\" return floor ( rand_gen . random () * ( stop - start ) + start )","title":"safe_random_int()"},{"location":"api/utilities/#titan.utils.safe_shuffle","text":"Return None or a shuffled sequence Parameters: Name Type Description Default seq Collection[~T] collection to shuffle required rand_gen random number generator required Returns: Type Description Iterable[~T] shuffled sequence, or None if empty Source code in titan/utils.py def safe_shuffle ( seq : Collection [ T ], rand_gen ) -> Iterable [ T ]: \"\"\" Return None or a shuffled sequence args: seq: collection to shuffle rand_gen: random number generator returns: shuffled sequence, or `None` if empty \"\"\" if seq : if isinstance ( seq , set ): seq = list ( seq ) rand_gen . shuffle ( seq ) return seq else : return []","title":"safe_shuffle()"},{"location":"api/utilities/#titan.utils.scale_param","text":"Given the params and a parameter path in the format prep|cap, scale the current value by the scalar Source code in titan/utils.py def scale_param ( params : ObjMap , param_path : str , scalar : float , delimiter = \"|\" ): \"\"\" Given the params and a parameter path in the format prep|cap, scale the current value by the scalar \"\"\" scaling_item , last_key = get_param_from_path ( params , param_path , delimiter ) old_val = scaling_item [ last_key ] logging . info ( f \"scaling - { param_path } : { old_val } => { old_val * scalar } \" ) scaling_item [ last_key ] = old_val * scalar","title":"scale_param()"},{"location":"api/utilities/#titan.utils.total_probability","text":"Given a per act probability and a number of acts, return the total probability. Parameters: Name Type Description Default p float the per act probability required num_acts int the number of acts required Returns: Type Description float the total probability Source code in titan/utils.py def total_probability ( p : float , num_acts : int ) -> float : \"\"\" Given a per act probability and a number of acts, return the total probability. args: p: the per act probability num_acts: the number of acts returns: the total probability \"\"\" if num_acts == 1 : return p elif num_acts >= 1 : return 1.0 - binom_0 ( num_acts , p ) else : return 0.0","title":"total_probability()"},{"location":"api/utilities/#params","text":"","title":"Params"},{"location":"api/utilities/#titan.parse_params.ObjMap","text":"A dictionary-like class which allows accessing members either using standard dictionary notation or dots. Note the hash function is hard-coded - beware.","title":"ObjMap"},{"location":"api/utilities/#titan.parse_params.ObjMap.__hash__","text":"Return hash(self). Source code in titan/parse_params.py def __hash__ ( self ): return 1234567890","title":"__hash__()"},{"location":"api/utilities/#titan.parse_params.check_params","text":"Consistency checks for param populations Source code in titan/parse_params.py def check_params ( params : ObjMap ): \"\"\" Consistency checks for param populations \"\"\" race_pop = 0 for race in params . classes . races : r_dems = params . demographics [ race ] race_pop += r_dems . ppl sex_type_pop = 0 for st , st_dems in r_dems . sex_type . items (): if st in list ( params . classes . sex_types . keys ()): sex_type_pop += st_dems . ppl drug_type_pop = 0 for dt , dt_dems in st_dems . drug_type . items (): if dt in list ( params . classes . drug_types ): drug_type_pop += dt_dems . ppl assert math . isclose ( drug_type_pop , 1 , abs_tol = 0.001 ), f \"ppl of { race } 's { st } 's drug_types must add to 1. Currently adding to { drug_type_pop } \" assert math . isclose ( sex_type_pop , 1 , abs_tol = 0.001 ), f \"ppl of { race } 's sex_types must add to 1. Currently adding to { sex_type_pop } \" assert math . isclose ( race_pop , 1 , abs_tol = 0.001 ), \"ppl of races must add to 1\" loc_pop = 0 for location in params . classes . locations . values (): loc_pop += location . ppl assert math . isclose ( loc_pop , 1 , abs_tol = 0.001 ), \"ppl of locations must add to 1\" for param , assort in params . assort_mix . items (): assort_value = 0 for ptnr_value in assort . partner_values . values (): assort_value += ptnr_value assert math . isclose ( assort_value , 1 , abs_tol = 0.001 ), f \"assort values must add to 1, not { assort_value } in { param } \"","title":"check_params()"},{"location":"api/utilities/#titan.parse_params.create_params","text":"Entry function - given the path to the setting, params, output directory and whether or not to use the base setting. Parse and create a params (ObjMap) object. Parameters: Name Type Description Default setting_name Optional[str] path to a settings file or directory or None required param_path str path to parameter file or directory required outdir str path to directory where computed params will be saved required error_on_unused bool throw a hard error if there are unused parameters, otherwise warnings are only printed False Returns: Type Description ObjMap computed/validated model paramters with defaults filled in where needed Source code in titan/parse_params.py def create_params ( setting_name : Optional [ str ], param_path : str , outdir : str , error_on_unused : bool = False , ) -> ObjMap : \"\"\" Entry function - given the path to the setting, params, output directory and whether or not to use the base setting. Parse and create a params (ObjMap) object. args: setting_name: path to a settings file or directory or `None` param_path: path to parameter file or directory outdir: path to directory where computed params will be saved error_on_unused: throw a hard error if there are unused parameters, otherwise warnings are only printed returns: computed/validated model paramters with defaults filled in where needed \"\"\" # find defs, where we are in the code for settings and base filename = getsourcefile ( create_params ) # what is the sourcefile for this function if filename is not None : parent = Path ( filename ) . resolve () . parent else : raise Exception ( \"can't find where I am in the code?\" ) param_defs = os . path . join ( parent , \"params\" ) param_paths = [] # merge setting and params if setting_name is not None : # check if it's a known setting or pass it through as a path if setting_name in os . listdir ( os . path . join ( parent , \"settings\" )): param_paths . append ( os . path . join ( parent , \"settings\" , setting_name )) else : param_paths . append ( setting_name ) param_paths . append ( param_path ) parsed = paraml . create_params ( param_defs , * param_paths , out_path = os . path . join ( outdir , \"params.yml\" ), error_on_unused = error_on_unused , ) parsed = ObjMap ( parsed ) check_params ( parsed ) # copy migration file if enabled if parsed . location . migration . enabled : shutil . copy ( parsed . location . migration . probs_file , os . path . join ( outdir , \"migration_probs.csv\" ), ) return parsed","title":"create_params()"},{"location":"api/utilities/#probability-distributions","text":"","title":"Probability Distributions"},{"location":"api/utilities/#titan.distributions.pert","text":"A pert distribution, inspired by tensorflow arguments must be so that: low < peak < high temperature > 0 The support is [low, high] . The peak must fit in that interval: low < peak < high . The temperature is a positive parameter that controls the shape of the distribution. Higher values yield a sharper peak. Parameters: Name Type Description Default np_random random number generator (used to get beta) required low distribution low value required peak modal point in distribution required high distribution high value required temperature scaling factor required Source code in titan/distributions.py def pert ( np_random , low , peak , high , temperature ): \"\"\" A pert distribution, inspired by [tensorflow](https://github.com/tensorflow/probability/blob/c833ee5cd9f60f3257366b25447b9e50210b0590/tensorflow_probability/python/distributions/pert.py#L137) arguments must be so that: * low < peak < high * temperature > 0 The support is `[low, high]`. The `peak` must fit in that interval: `low < peak < high`. The `temperature` is a positive parameter that controls the shape of the distribution. Higher values yield a sharper peak. args: np_random: random number generator (used to get beta) low: distribution low value peak: modal point in distribution high: distribution high value temperature: scaling factor \"\"\" assert low < peak < high assert temperature > 0 scale = high - low alpha = 1.0 + temperature * ( peak - low ) / scale beta = 1.0 + temperature * ( high - peak ) / scale return low + scale * np_random . beta ( alpha , beta )","title":"pert()"},{"location":"api/utilities/#titan.distributions.set_value","text":"A distribution that always returns the value passed Parameters: Name Type Description Default np_random random number generator (to conform to distribution interface) required value value to return required Source code in titan/distributions.py def set_value ( np_random , value ): \"\"\" A distribution that always returns the value passed args: np_random: random number generator (to conform to distribution interface) value: value to return \"\"\" return value","title":"set_value()"},{"location":"api/utilities/#titan.distributions.weibull_modified","text":"Modified version of numpy's (single parameter) weibull distribution to use the 2-parameter weibull. Parameters: Name Type Description Default np_random random number generator required shape weibull shape parameter required scale weibull scale parameter required Source code in titan/distributions.py def weibull_modified ( np_random , shape , scale ): \"\"\" Modified version of numpy's (single parameter) weibull distribution to use the 2-parameter weibull. args: np_random: random number generator shape: weibull shape parameter scale: weibull scale parameter \"\"\" random_number = np_random . random () return scale * ( - log ( 1 - random_number )) ** ( 1 / shape )","title":"weibull_modified()"},{"location":"api/utilities/#complex-probabilities","text":"","title":"Complex Probabilities"},{"location":"api/utilities/#titan.probabilities.get_death_rate","text":"Find the death rate of an agent given a set of attributes. Parameters: Name Type Description Default hiv bool whether the agent is HIV+ required aids bool whether the agent has AIDS required drug_type str whether the PWID base death rate should be used or the base one required haart_adh bool whether an agent is haart adherent required race str the race of the agent required location Location agent's location required steps_per_year int the number of model steps in a year required Returns: Type Description float the probability of an agent with these characteristics dying in a given time step Source code in titan/probabilities.py @utils . memo def get_death_rate ( hiv : bool , aids : bool , drug_type : str , sex_type : str , haart_adh : bool , race : str , location : Location , steps_per_year : int , ) -> float : \"\"\" Find the death rate of an agent given a set of attributes. args: hiv: whether the agent is HIV+ aids: whether the agent has AIDS drug_type: whether the PWID base death rate should be used or the base one haart_adh: whether an agent is haart adherent race: the race of the agent location: agent's location steps_per_year: the number of model steps in a year returns: the probability of an agent with these characteristics dying in a given time step \"\"\" param = location . params . demographics death_param = param [ race ] . sex_type [ sex_type ] . drug_type [ drug_type ] . death_rate p = death_param . base if aids : p *= death_param . aids elif hiv : if haart_adh : p *= death_param . haart_adherent else : p *= death_param . hiv # putting it into per 1 person-month from per 1000 person years return p / ( steps_per_year * 1000.0 )","title":"get_death_rate()"},{"location":"api/exposures/","text":"Agent Exposures Exposures (transmissible items such as HIV and knowledge) from params.exposures are implemented in standalone files that implement the interface from exposures.BaseExposure . This allows for all of the logic related to an exposure to be consolidated in one place and additionally makes incorporating a new exposure into the model as simple as possible. To add a new exposure: Add the param to param.exposures Add a file to exposures/ which creates a class that is a sub-class of BaseExposure Implement the methods of BaseExposure which are needed for this exposure Not all methods are needed for all exposures (see below for details on the methods) Re-export the exposure from exposures/__init__.py Add tests in tests/exposures/ Add it to the docs in docs/api/exposures/ and to the nav in mkdocs.yml The TITAN , Population , and Agent classes all use sub-classes of BaseFeature to initialize the object/call methods as appropriate. BaseExposure name : str Name of exposure in the params file. Also used to name the attribute in Agent stats : List [ str ] List of names of stats that come from this exposure (e.g. hiv.dx) add_agent ( agent ) classmethod Add an agent to the class (not instance). This can be useful if tracking population level statistics or groups, such as counts or newly active agents. This method is not called from anywhere in the model, but creates a cohesive api with remove_agent , which is called from Population.remove_agent . Parameters: Name Type Description Default agent agent.Agent the agent to add to the class attributes required Source code in titan/exposures/base_exposure.py @classmethod def add_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Add an agent to the class (not instance). This can be useful if tracking population level statistics or groups, such as counts or newly active agents. This method is not called from anywhere in the model, but creates a cohesive api with `remove_agent`, which is called from `Population.remove_agent`. args: agent: the agent to add to the class attributes \"\"\" pass convert ( self , model ) Convert the agent to the exposure (i.e. become active). Parameters: Name Type Description Default model model.TITAN The running model required Source code in titan/exposures/base_exposure.py def convert ( self , model : \"model.TITAN\" ): \"\"\" Convert the agent to the exposure (i.e. become active). args: model: The running model \"\"\" pass diagnose ( self , model ) Diagnose the agent with the exposure (if applicable). Parameters: Name Type Description Default model model.TITAN The running model required Source code in titan/exposures/base_exposure.py def diagnose ( self , model : \"model.TITAN\" ): \"\"\" Diagnose the agent with the exposure (if applicable). args: model: The running model \"\"\" pass expose ( model , interaction , rel , num_acts ) staticmethod Expose a relationship to the exposure for a number of acts for a specific interaction type. Typically, this determines if the exposure can cause conversion/change in one of the agents, then if so, determines the probability of that and then converts the succeptible agent. Parameters: Name Type Description Default model model.TITAN The running model required interaction str The type of interaction (e.g. sex, injection) required rel agent.Relationship The relationship where the interaction is occuring required num_acts int The number of acts of that interaction required Source code in titan/exposures/base_exposure.py @staticmethod def expose ( model : \"model.TITAN\" , interaction : str , rel : \"agent.Relationship\" , num_acts : int , ): \"\"\" Expose a relationship to the exposure for a number of acts for a specific interaction type. Typically, this determines if the exposure can cause conversion/change in one of the agents, then if so, determines the probability of that and then converts the succeptible agent. args: model: The running model interaction: The type of interaction (e.g. sex, injection) rel: The relationship where the interaction is occuring num_acts: The number of acts of that interaction \"\"\" pass get_transmission_probability ( self , model , interaction , partner , num_acts ) Determines the probability of a transmission event from agent to partner based on interaction type. This is not called from anywhere else in the model, but is recommended as a way to structure the exposure method into getting the transmission probability, then doing the conversion. Parameters: Name Type Description Default model model.TITAN The running model required interaction str The type of interaction (e.g. sex , injection ) required partner agent.Agent The agent's partner required num_acts int The number of acts where exposure occured required Returns: Type Description float probability of transmission from agent to partner Source code in titan/exposures/base_exposure.py def get_transmission_probability ( self , model : \"model.TITAN\" , interaction : str , partner : \"agent.Agent\" , num_acts : int , ) -> float : \"\"\" Determines the probability of a transmission event from agent to partner based on interaction type. This is not called from anywhere else in the model, but is recommended as a way to structure the exposure method into getting the transmission probability, then doing the conversion. args: model: The running model interaction : The type of interaction (e.g. `sex`, `injection`) partner: The agent's partner num_acts: The number of acts where exposure occured returns: probability of transmission from agent to partner \"\"\" return 0.0 init_agent ( self , pop , time ) Initialize the agent for this exposure during population initialization ( Population.create_agent ). Called only on exposures that are enabled per the params. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/exposures/base_exposure.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this exposure during population initialization (`Population.create_agent`). Called only on exposures that are enabled per the params. args: pop: the population this agent is a part of time: the current time step \"\"\" pass init_class ( params ) classmethod Initialize any class level attributes (such as setting counters to zero). Called on every active exposure on population initialization. Parameters: Name Type Description Default params parameters for this population required Source code in titan/exposures/base_exposure.py @classmethod def init_class ( cls , params ): \"\"\" Initialize any class level attributes (such as setting counters to zero). Called on every active exposure on population initialization. args: params: parameters for this population \"\"\" pass remove_agent ( agent ) classmethod Remove an agent from the class (not instance). This can be useful if tracking population level statistics or groups, such as counts. This method is called from Population.remove_agent , but may also need to be called within the feature if an agent transitions from active == True to active == False . Parameters: Name Type Description Default agent agent.Agent the agent to remove from the class attributes required Source code in titan/exposures/base_exposure.py @classmethod def remove_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Remove an agent from the class (not instance). This can be useful if tracking population level statistics or groups, such as counts. This method is called from `Population.remove_agent`, but may also need to be called within the feature if an agent transitions from `active == True` to `active == False`. args: agent: the agent to remove from the class attributes \"\"\" pass set_stats ( self , stats , time ) Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled exposure in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/exposures/base_exposure.py def set_stats ( self , stats : Dict [ str , int ], time : int ): \"\"\" Update the `stats` dictionary passed for this agent. Called from `output.get_stats` for each enabled exposure in the model. The stats to be updated must be declared in the class attribute `stats` to make sure the dictionary has the expected keys/counter value initialized. args: stats: the dictionary to update with this agent's feature statistics time: the time step of the model when the stats are set \"\"\" pass update_agent ( self , model ) Update the agent for this exposure for a time step. Called once per time step in TITAN.update_all_agents . Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/exposures/base_exposure.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this exposure for a time step. Called once per time step in `TITAN.update_all_agents`. args: model: the instance of TITAN currently being run \"\"\" pass","title":"Overview"},{"location":"api/exposures/#agent-exposures","text":"Exposures (transmissible items such as HIV and knowledge) from params.exposures are implemented in standalone files that implement the interface from exposures.BaseExposure . This allows for all of the logic related to an exposure to be consolidated in one place and additionally makes incorporating a new exposure into the model as simple as possible. To add a new exposure: Add the param to param.exposures Add a file to exposures/ which creates a class that is a sub-class of BaseExposure Implement the methods of BaseExposure which are needed for this exposure Not all methods are needed for all exposures (see below for details on the methods) Re-export the exposure from exposures/__init__.py Add tests in tests/exposures/ Add it to the docs in docs/api/exposures/ and to the nav in mkdocs.yml The TITAN , Population , and Agent classes all use sub-classes of BaseFeature to initialize the object/call methods as appropriate.","title":"Agent Exposures"},{"location":"api/exposures/#titan.exposures.base_exposure.BaseExposure","text":"","title":"BaseExposure"},{"location":"api/exposures/#titan.exposures.base_exposure.BaseExposure.name","text":"Name of exposure in the params file. Also used to name the attribute in Agent","title":"name"},{"location":"api/exposures/#titan.exposures.base_exposure.BaseExposure.stats","text":"List of names of stats that come from this exposure (e.g. hiv.dx)","title":"stats"},{"location":"api/exposures/#titan.exposures.base_exposure.BaseExposure.add_agent","text":"Add an agent to the class (not instance). This can be useful if tracking population level statistics or groups, such as counts or newly active agents. This method is not called from anywhere in the model, but creates a cohesive api with remove_agent , which is called from Population.remove_agent . Parameters: Name Type Description Default agent agent.Agent the agent to add to the class attributes required Source code in titan/exposures/base_exposure.py @classmethod def add_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Add an agent to the class (not instance). This can be useful if tracking population level statistics or groups, such as counts or newly active agents. This method is not called from anywhere in the model, but creates a cohesive api with `remove_agent`, which is called from `Population.remove_agent`. args: agent: the agent to add to the class attributes \"\"\" pass","title":"add_agent()"},{"location":"api/exposures/#titan.exposures.base_exposure.BaseExposure.convert","text":"Convert the agent to the exposure (i.e. become active). Parameters: Name Type Description Default model model.TITAN The running model required Source code in titan/exposures/base_exposure.py def convert ( self , model : \"model.TITAN\" ): \"\"\" Convert the agent to the exposure (i.e. become active). args: model: The running model \"\"\" pass","title":"convert()"},{"location":"api/exposures/#titan.exposures.base_exposure.BaseExposure.diagnose","text":"Diagnose the agent with the exposure (if applicable). Parameters: Name Type Description Default model model.TITAN The running model required Source code in titan/exposures/base_exposure.py def diagnose ( self , model : \"model.TITAN\" ): \"\"\" Diagnose the agent with the exposure (if applicable). args: model: The running model \"\"\" pass","title":"diagnose()"},{"location":"api/exposures/#titan.exposures.base_exposure.BaseExposure.expose","text":"Expose a relationship to the exposure for a number of acts for a specific interaction type. Typically, this determines if the exposure can cause conversion/change in one of the agents, then if so, determines the probability of that and then converts the succeptible agent. Parameters: Name Type Description Default model model.TITAN The running model required interaction str The type of interaction (e.g. sex, injection) required rel agent.Relationship The relationship where the interaction is occuring required num_acts int The number of acts of that interaction required Source code in titan/exposures/base_exposure.py @staticmethod def expose ( model : \"model.TITAN\" , interaction : str , rel : \"agent.Relationship\" , num_acts : int , ): \"\"\" Expose a relationship to the exposure for a number of acts for a specific interaction type. Typically, this determines if the exposure can cause conversion/change in one of the agents, then if so, determines the probability of that and then converts the succeptible agent. args: model: The running model interaction: The type of interaction (e.g. sex, injection) rel: The relationship where the interaction is occuring num_acts: The number of acts of that interaction \"\"\" pass","title":"expose()"},{"location":"api/exposures/#titan.exposures.base_exposure.BaseExposure.get_transmission_probability","text":"Determines the probability of a transmission event from agent to partner based on interaction type. This is not called from anywhere else in the model, but is recommended as a way to structure the exposure method into getting the transmission probability, then doing the conversion. Parameters: Name Type Description Default model model.TITAN The running model required interaction str The type of interaction (e.g. sex , injection ) required partner agent.Agent The agent's partner required num_acts int The number of acts where exposure occured required Returns: Type Description float probability of transmission from agent to partner Source code in titan/exposures/base_exposure.py def get_transmission_probability ( self , model : \"model.TITAN\" , interaction : str , partner : \"agent.Agent\" , num_acts : int , ) -> float : \"\"\" Determines the probability of a transmission event from agent to partner based on interaction type. This is not called from anywhere else in the model, but is recommended as a way to structure the exposure method into getting the transmission probability, then doing the conversion. args: model: The running model interaction : The type of interaction (e.g. `sex`, `injection`) partner: The agent's partner num_acts: The number of acts where exposure occured returns: probability of transmission from agent to partner \"\"\" return 0.0","title":"get_transmission_probability()"},{"location":"api/exposures/#titan.exposures.base_exposure.BaseExposure.init_agent","text":"Initialize the agent for this exposure during population initialization ( Population.create_agent ). Called only on exposures that are enabled per the params. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/exposures/base_exposure.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this exposure during population initialization (`Population.create_agent`). Called only on exposures that are enabled per the params. args: pop: the population this agent is a part of time: the current time step \"\"\" pass","title":"init_agent()"},{"location":"api/exposures/#titan.exposures.base_exposure.BaseExposure.init_class","text":"Initialize any class level attributes (such as setting counters to zero). Called on every active exposure on population initialization. Parameters: Name Type Description Default params parameters for this population required Source code in titan/exposures/base_exposure.py @classmethod def init_class ( cls , params ): \"\"\" Initialize any class level attributes (such as setting counters to zero). Called on every active exposure on population initialization. args: params: parameters for this population \"\"\" pass","title":"init_class()"},{"location":"api/exposures/#titan.exposures.base_exposure.BaseExposure.remove_agent","text":"Remove an agent from the class (not instance). This can be useful if tracking population level statistics or groups, such as counts. This method is called from Population.remove_agent , but may also need to be called within the feature if an agent transitions from active == True to active == False . Parameters: Name Type Description Default agent agent.Agent the agent to remove from the class attributes required Source code in titan/exposures/base_exposure.py @classmethod def remove_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Remove an agent from the class (not instance). This can be useful if tracking population level statistics or groups, such as counts. This method is called from `Population.remove_agent`, but may also need to be called within the feature if an agent transitions from `active == True` to `active == False`. args: agent: the agent to remove from the class attributes \"\"\" pass","title":"remove_agent()"},{"location":"api/exposures/#titan.exposures.base_exposure.BaseExposure.set_stats","text":"Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled exposure in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/exposures/base_exposure.py def set_stats ( self , stats : Dict [ str , int ], time : int ): \"\"\" Update the `stats` dictionary passed for this agent. Called from `output.get_stats` for each enabled exposure in the model. The stats to be updated must be declared in the class attribute `stats` to make sure the dictionary has the expected keys/counter value initialized. args: stats: the dictionary to update with this agent's feature statistics time: the time step of the model when the stats are set \"\"\" pass","title":"set_stats()"},{"location":"api/exposures/#titan.exposures.base_exposure.BaseExposure.update_agent","text":"Update the agent for this exposure for a time step. Called once per time step in TITAN.update_all_agents . Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/exposures/base_exposure.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this exposure for a time step. Called once per time step in `TITAN.update_all_agents`. args: model: the instance of TITAN currently being run \"\"\" pass","title":"update_agent()"},{"location":"api/exposures/hiv/","text":"agents : Set [ titan . agent . Agent ] Agents with active hiv dx_counts : Dict [ str , Dict [ str , int ]] Counts of diagnosed agents by race and sex_type name : str Name of exposure in the params file. Also used to name the attribute in Agent stats : List [ str ] HIV collects the following stats: hiv - number of agents with active hiv hiv_dx - number of agents with diagnosed hiv hiv_aids - number of agents with aids hiv_new - number of agents converted to hiv this timestep hiv_dx_new - number of agents with diagnosed with hiv this timestep add_agent ( agent ) classmethod Add an agent to the class (not instance). This can be useful if tracking population level statistics or groups, such as counts or newly active agents. Add the agent to the agents set and if the agent is diagnosed, updated the dx_counts Parameters: Name Type Description Default agent agent.Agent the agent to add to the class attributes required Source code in titan/exposures/hiv.py @classmethod def add_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Add an agent to the class (not instance). This can be useful if tracking population level statistics or groups, such as counts or newly active agents. Add the agent to the `agents` set and if the agent is diagnosed, updated the `dx_counts` args: agent: the agent to add to the class attributes \"\"\" cls . agents . add ( agent ) if agent . hiv . dx : # type: ignore[attr-defined] cls . dx_counts [ agent . race ][ agent . sex_type ] += 1 convert ( self , model ) Agent becomes HIV agent. Update all appropriate attributes, sets and dictionaries. Parameters: Name Type Description Default model model.TITAN The model being run required Source code in titan/exposures/hiv.py def convert ( self , model : \"model.TITAN\" ): \"\"\" Agent becomes HIV agent. Update all appropriate attributes, sets and dictionaries. args: model: The model being run \"\"\" if not self . active : self . active = True self . time = model . time self . agent . vaccine . active = False # type: ignore[attr-defined] self . add_agent ( self . agent ) if self . agent . prep . active : # type: ignore[attr-defined] self . agent . prep . progress ( model , force = True ) # type: ignore[attr-defined] diagnose ( self , model ) Mark the agent as diagnosed. Parameters: Name Type Description Default model model.TITAN the running model required Source code in titan/exposures/hiv.py def diagnose ( self , model : \"model.TITAN\" ): \"\"\" Mark the agent as diagnosed. args: model: the running model \"\"\" self . dx = True self . dx_time = model . time self . add_agent ( self . agent ) expose ( model , interaction , rel , num_acts ) staticmethod Expose a relationship to the exposure for a number of acts of a specific interaction type. Typically, this is determining if the exposure can cause conversion/change in one of the agents, then if so determining the probability of that and then converting the succeptible agent. For hiv, one agent must be active and the other not for an exposure to cause conversion. Parameters: Name Type Description Default model model.TITAN The running model required interaction str The type of interaction (e.g. sex, injection) required rel agent.Relationship The relationship where the interaction is occuring required num_acts int The number of acts of that interaction required Source code in titan/exposures/hiv.py @staticmethod def expose ( model : \"model.TITAN\" , interaction : str , rel : \"agent.Relationship\" , num_acts : int , ): \"\"\" Expose a relationship to the exposure for a number of acts of a specific interaction type. Typically, this is determining if the exposure can cause conversion/change in one of the agents, then if so determining the probability of that and then converting the succeptible agent. For hiv, one agent must be active and the other not for an exposure to cause conversion. args: model: The running model interaction: The type of interaction (e.g. sex, injection) rel: The relationship where the interaction is occuring num_acts: The number of acts of that interaction \"\"\" # Agent 1 is HIV+, Agent 2 is not, Agent 2 is succept if rel . agent1 . hiv . active and not rel . agent2 . hiv . active : # type: ignore[attr-defined] agent = rel . agent1 partner = rel . agent2 # If Agent 2 is HIV and Agent 1 is not, Agent 1 is succept elif not rel . agent1 . hiv . active and rel . agent2 . hiv . active : # type: ignore[attr-defined] agent = rel . agent2 partner = rel . agent1 else : # neither agent is HIV or both are return p = agent . hiv . get_transmission_probability ( # type: ignore[attr-defined] model , interaction , partner , num_acts ) if model . run_random . random () < p : # if agent HIV+ partner becomes HIV+ partner . hiv . convert ( model ) # type: ignore[attr-defined] get_acute_status ( self , time ) Get acute status of agent at time Parameters: Name Type Description Default time int The current time step required Returns: Type Description bool whether an agent is acute Source code in titan/exposures/hiv.py def get_acute_status ( self , time : int ) -> bool : \"\"\" Get acute status of agent at time args: time: The current time step returns: whether an agent is acute \"\"\" if self . active and self . time is not None : hiv_duration = time - self . time if self . agent . location . params . hiv . acute . duration >= hiv_duration >= 0 : return True return False get_transmission_probability ( self , model , interaction , partner , num_acts ) Determines the probability of an hiv transmission event from agent to partner based on interaction type and numer of acts. For sex acts, transmission probability is a function of the acquisition probability of the HIV- agent's sex role and the HIV+ agent's haart adherence, acute status, and dx risk reduction Parameters: Name Type Description Default model model.TITAN The running model required interaction str \"injection\" or \"sex\" required partner agent.Agent HIV- Agent required num_acts int The number of exposure interactions the agents had this time step required Returns: Type Description float probability of transmission from agent to partner Source code in titan/exposures/hiv.py def get_transmission_probability ( self , model : \"model.TITAN\" , interaction : str , partner : \"agent.Agent\" , num_acts : int , ) -> float : \"\"\" Determines the probability of an hiv transmission event from agent to partner based on interaction type and numer of acts. For sex acts, transmission probability is a function of the acquisition probability of the HIV- agent's sex role and the HIV+ agent's haart adherence, acute status, and dx risk reduction args: model: The running model interaction : \"injection\" or \"sex\" partner: HIV- Agent num_acts: The number of exposure interactions the agents had this time step returns: probability of transmission from agent to partner \"\"\" # if this isn't an interaction where hiv can transmit, return 0% prob if interaction not in ( \"injection\" , \"sex\" ): return 0.0 # Logic for if needle or sex type interaction p : float # get baseline probabilities if interaction == \"injection\" : p = model . params . partnership . injection . transmission . base elif interaction == \"sex\" : agent_sex_role = self . agent . sex_role partner_sex_role = partner . sex_role # get partner's sex role during acts if partner_sex_role == \"versatile\" : # versatile partner takes # \"opposite\" position of agent if agent_sex_role == \"insertive\" : partner_sex_role = \"receptive\" elif agent_sex_role == \"receptive\" : partner_sex_role = \"insertive\" else : partner_sex_role = \"versatile\" # if both versatile, can switch # between receptive and insertive by act # get probability of sex acquisition given HIV- partner's position p = partner . location . params . partnership . sex . acquisition [ partner . sex_type ][ partner_sex_role ] # feature specific risk adjustment for feature in model . features : agent_feature = getattr ( self . agent , feature . name ) p *= agent_feature . get_transmission_risk_multiplier ( self . time , interaction ) partner_feature = getattr ( partner , feature . name ) p *= partner_feature . get_acquisition_risk_multiplier ( self . time , interaction ) # Scaling parameter for acute HIV infections if self . get_acute_status ( model . time ): p *= self . agent . location . params . hiv . acute . infectivity # Scaling parameter for positively identified HIV agents if self . dx : p *= 1 - self . agent . location . params . hiv . dx . risk_reduction [ interaction ] # Racial calibration parameter to attain proper race incidence disparity p *= partner . location . params . demographics [ partner . race ] . hiv . transmission # Scaling parameter for per act transmission. p *= model . calibration . acquisition return utils . total_probability ( p , num_acts ) init_agent ( self , pop , time ) Initialize the agent for this exposure during population initialization ( Population.create_agent ). Called on only exposures that are enabled per the params. Based on demographic params for the agent, stochastically determine if hiv is active, and if active, at what past time point was the agent converted, if the agent is diagnosed, and if the agent has aids. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/exposures/hiv.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this exposure during population initialization (`Population.create_agent`). Called on only exposures that are enabled per the params. Based on demographic params for the agent, stochastically determine if hiv is active, and if active, at what past time point was the agent converted, if the agent is diagnosed, and if the agent has aids. args: pop: the population this agent is a part of time: the current time step \"\"\" agent_params = ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . drug_type [ self . agent . drug_type ] ) # HIV if ( pop . pop_random . random () < agent_params . hiv . init and time >= pop . params . hiv . start_time ): self . active = True # if HIV, when did the agent convert? Random sample self . time = utils . safe_random_int ( time - self . agent . location . params . hiv . max_init_time , time , pop . pop_random , ) if pop . pop_random . random () < agent_params . hiv . aids . init : self . aids = True if pop . pop_random . random () < agent_params . hiv . dx . init : self . dx = True # agent was diagnosed at a random time between conversion and now self . dx_time = utils . safe_random_int ( self . time , time , pop . pop_random ) # add agent to class self . add_agent ( self . agent ) init_class ( params ) classmethod Initialize any diagnosis counts and the agents set. Parameters: Name Type Description Default params parameters for this population required Source code in titan/exposures/hiv.py @classmethod def init_class ( cls , params ): \"\"\" Initialize any diagnosis counts and the agents set. args: params: parameters for this population \"\"\" cls . dx_counts = { race : { so : 0 for so in params . classes . sex_types } for race in params . classes . races } cls . agents = set () progress_to_aids ( self , model ) Model the progression of HIV agents to AIDS agents Parameters: Name Type Description Default model model.TITAN the running model required Source code in titan/exposures/hiv.py def progress_to_aids ( self , model : \"model.TITAN\" ): \"\"\" Model the progression of HIV agents to AIDS agents args: model: the running model \"\"\" aids_prob = self . agent . location . params . hiv . aids . prob p = self . agent . haart . aids_scale () # type: ignore[attr-defined] if model . run_random . random () < p * aids_prob : self . aids = True remove_agent ( agent ) classmethod Remove an agent from the class (not instance). This can be useful if tracking population level statistics or groups, such as counts. Remove the agent from the agents set and decrement the dx_counts if the agent was diagnosed. Parameters: Name Type Description Default agent agent.Agent the agent to remove from the class attributes required Source code in titan/exposures/hiv.py @classmethod def remove_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Remove an agent from the class (not instance). This can be useful if tracking population level statistics or groups, such as counts. Remove the agent from the `agents` set and decrement the `dx_counts` if the agent was diagnosed. args: agent: the agent to remove from the class attributes \"\"\" cls . agents . remove ( agent ) if agent . hiv . dx : # type: ignore[attr-defined] cls . dx_counts [ agent . race ][ agent . sex_type ] -= 1 set_stats ( self , stats , time ) Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled exposure in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/exposures/hiv.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . active : stats [ \"hiv\" ] += 1 if self . time == time : stats [ \"hiv_new\" ] += 1 if self . aids : stats [ \"hiv_aids\" ] += 1 if self . dx : stats [ \"hiv_dx\" ] += 1 if self . dx_time == time : stats [ \"hiv_dx_new\" ] += 1 update_agent ( self , model ) Update the agent for this exposure for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only exposures that are enabled per the params. If the agent is hiv+ and the model time is past the hiv start_time, determine if the agent becomes diagnosed if not yet diagnosed, and if the agent has progressed to aids. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/exposures/hiv.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this exposure for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only exposures that are enabled per the params. If the agent is hiv+ and the model time is past the hiv start_time, determine if the agent becomes diagnosed if not yet diagnosed, and if the agent has progressed to aids. args: model: the instance of TITAN currently being run \"\"\" if self . active and model . time >= model . params . hiv . start_time : if not self . dx : test_prob = ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . drug_type [ self . agent . drug_type ] . hiv . dx . prob ) # Rescale based on calibration param test_prob *= model . calibration . test_frequency if model . run_random . random () < test_prob : self . diagnose ( model ) self . progress_to_aids ( model )","title":"HIV"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.agents","text":"Agents with active hiv","title":"agents"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.dx_counts","text":"Counts of diagnosed agents by race and sex_type","title":"dx_counts"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.name","text":"Name of exposure in the params file. Also used to name the attribute in Agent","title":"name"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.stats","text":"HIV collects the following stats: hiv - number of agents with active hiv hiv_dx - number of agents with diagnosed hiv hiv_aids - number of agents with aids hiv_new - number of agents converted to hiv this timestep hiv_dx_new - number of agents with diagnosed with hiv this timestep","title":"stats"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.add_agent","text":"Add an agent to the class (not instance). This can be useful if tracking population level statistics or groups, such as counts or newly active agents. Add the agent to the agents set and if the agent is diagnosed, updated the dx_counts Parameters: Name Type Description Default agent agent.Agent the agent to add to the class attributes required Source code in titan/exposures/hiv.py @classmethod def add_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Add an agent to the class (not instance). This can be useful if tracking population level statistics or groups, such as counts or newly active agents. Add the agent to the `agents` set and if the agent is diagnosed, updated the `dx_counts` args: agent: the agent to add to the class attributes \"\"\" cls . agents . add ( agent ) if agent . hiv . dx : # type: ignore[attr-defined] cls . dx_counts [ agent . race ][ agent . sex_type ] += 1","title":"add_agent()"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.convert","text":"Agent becomes HIV agent. Update all appropriate attributes, sets and dictionaries. Parameters: Name Type Description Default model model.TITAN The model being run required Source code in titan/exposures/hiv.py def convert ( self , model : \"model.TITAN\" ): \"\"\" Agent becomes HIV agent. Update all appropriate attributes, sets and dictionaries. args: model: The model being run \"\"\" if not self . active : self . active = True self . time = model . time self . agent . vaccine . active = False # type: ignore[attr-defined] self . add_agent ( self . agent ) if self . agent . prep . active : # type: ignore[attr-defined] self . agent . prep . progress ( model , force = True ) # type: ignore[attr-defined]","title":"convert()"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.diagnose","text":"Mark the agent as diagnosed. Parameters: Name Type Description Default model model.TITAN the running model required Source code in titan/exposures/hiv.py def diagnose ( self , model : \"model.TITAN\" ): \"\"\" Mark the agent as diagnosed. args: model: the running model \"\"\" self . dx = True self . dx_time = model . time self . add_agent ( self . agent )","title":"diagnose()"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.expose","text":"Expose a relationship to the exposure for a number of acts of a specific interaction type. Typically, this is determining if the exposure can cause conversion/change in one of the agents, then if so determining the probability of that and then converting the succeptible agent. For hiv, one agent must be active and the other not for an exposure to cause conversion. Parameters: Name Type Description Default model model.TITAN The running model required interaction str The type of interaction (e.g. sex, injection) required rel agent.Relationship The relationship where the interaction is occuring required num_acts int The number of acts of that interaction required Source code in titan/exposures/hiv.py @staticmethod def expose ( model : \"model.TITAN\" , interaction : str , rel : \"agent.Relationship\" , num_acts : int , ): \"\"\" Expose a relationship to the exposure for a number of acts of a specific interaction type. Typically, this is determining if the exposure can cause conversion/change in one of the agents, then if so determining the probability of that and then converting the succeptible agent. For hiv, one agent must be active and the other not for an exposure to cause conversion. args: model: The running model interaction: The type of interaction (e.g. sex, injection) rel: The relationship where the interaction is occuring num_acts: The number of acts of that interaction \"\"\" # Agent 1 is HIV+, Agent 2 is not, Agent 2 is succept if rel . agent1 . hiv . active and not rel . agent2 . hiv . active : # type: ignore[attr-defined] agent = rel . agent1 partner = rel . agent2 # If Agent 2 is HIV and Agent 1 is not, Agent 1 is succept elif not rel . agent1 . hiv . active and rel . agent2 . hiv . active : # type: ignore[attr-defined] agent = rel . agent2 partner = rel . agent1 else : # neither agent is HIV or both are return p = agent . hiv . get_transmission_probability ( # type: ignore[attr-defined] model , interaction , partner , num_acts ) if model . run_random . random () < p : # if agent HIV+ partner becomes HIV+ partner . hiv . convert ( model ) # type: ignore[attr-defined]","title":"expose()"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.get_acute_status","text":"Get acute status of agent at time Parameters: Name Type Description Default time int The current time step required Returns: Type Description bool whether an agent is acute Source code in titan/exposures/hiv.py def get_acute_status ( self , time : int ) -> bool : \"\"\" Get acute status of agent at time args: time: The current time step returns: whether an agent is acute \"\"\" if self . active and self . time is not None : hiv_duration = time - self . time if self . agent . location . params . hiv . acute . duration >= hiv_duration >= 0 : return True return False","title":"get_acute_status()"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.get_transmission_probability","text":"Determines the probability of an hiv transmission event from agent to partner based on interaction type and numer of acts. For sex acts, transmission probability is a function of the acquisition probability of the HIV- agent's sex role and the HIV+ agent's haart adherence, acute status, and dx risk reduction Parameters: Name Type Description Default model model.TITAN The running model required interaction str \"injection\" or \"sex\" required partner agent.Agent HIV- Agent required num_acts int The number of exposure interactions the agents had this time step required Returns: Type Description float probability of transmission from agent to partner Source code in titan/exposures/hiv.py def get_transmission_probability ( self , model : \"model.TITAN\" , interaction : str , partner : \"agent.Agent\" , num_acts : int , ) -> float : \"\"\" Determines the probability of an hiv transmission event from agent to partner based on interaction type and numer of acts. For sex acts, transmission probability is a function of the acquisition probability of the HIV- agent's sex role and the HIV+ agent's haart adherence, acute status, and dx risk reduction args: model: The running model interaction : \"injection\" or \"sex\" partner: HIV- Agent num_acts: The number of exposure interactions the agents had this time step returns: probability of transmission from agent to partner \"\"\" # if this isn't an interaction where hiv can transmit, return 0% prob if interaction not in ( \"injection\" , \"sex\" ): return 0.0 # Logic for if needle or sex type interaction p : float # get baseline probabilities if interaction == \"injection\" : p = model . params . partnership . injection . transmission . base elif interaction == \"sex\" : agent_sex_role = self . agent . sex_role partner_sex_role = partner . sex_role # get partner's sex role during acts if partner_sex_role == \"versatile\" : # versatile partner takes # \"opposite\" position of agent if agent_sex_role == \"insertive\" : partner_sex_role = \"receptive\" elif agent_sex_role == \"receptive\" : partner_sex_role = \"insertive\" else : partner_sex_role = \"versatile\" # if both versatile, can switch # between receptive and insertive by act # get probability of sex acquisition given HIV- partner's position p = partner . location . params . partnership . sex . acquisition [ partner . sex_type ][ partner_sex_role ] # feature specific risk adjustment for feature in model . features : agent_feature = getattr ( self . agent , feature . name ) p *= agent_feature . get_transmission_risk_multiplier ( self . time , interaction ) partner_feature = getattr ( partner , feature . name ) p *= partner_feature . get_acquisition_risk_multiplier ( self . time , interaction ) # Scaling parameter for acute HIV infections if self . get_acute_status ( model . time ): p *= self . agent . location . params . hiv . acute . infectivity # Scaling parameter for positively identified HIV agents if self . dx : p *= 1 - self . agent . location . params . hiv . dx . risk_reduction [ interaction ] # Racial calibration parameter to attain proper race incidence disparity p *= partner . location . params . demographics [ partner . race ] . hiv . transmission # Scaling parameter for per act transmission. p *= model . calibration . acquisition return utils . total_probability ( p , num_acts )","title":"get_transmission_probability()"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.init_agent","text":"Initialize the agent for this exposure during population initialization ( Population.create_agent ). Called on only exposures that are enabled per the params. Based on demographic params for the agent, stochastically determine if hiv is active, and if active, at what past time point was the agent converted, if the agent is diagnosed, and if the agent has aids. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/exposures/hiv.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this exposure during population initialization (`Population.create_agent`). Called on only exposures that are enabled per the params. Based on demographic params for the agent, stochastically determine if hiv is active, and if active, at what past time point was the agent converted, if the agent is diagnosed, and if the agent has aids. args: pop: the population this agent is a part of time: the current time step \"\"\" agent_params = ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . drug_type [ self . agent . drug_type ] ) # HIV if ( pop . pop_random . random () < agent_params . hiv . init and time >= pop . params . hiv . start_time ): self . active = True # if HIV, when did the agent convert? Random sample self . time = utils . safe_random_int ( time - self . agent . location . params . hiv . max_init_time , time , pop . pop_random , ) if pop . pop_random . random () < agent_params . hiv . aids . init : self . aids = True if pop . pop_random . random () < agent_params . hiv . dx . init : self . dx = True # agent was diagnosed at a random time between conversion and now self . dx_time = utils . safe_random_int ( self . time , time , pop . pop_random ) # add agent to class self . add_agent ( self . agent )","title":"init_agent()"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.init_class","text":"Initialize any diagnosis counts and the agents set. Parameters: Name Type Description Default params parameters for this population required Source code in titan/exposures/hiv.py @classmethod def init_class ( cls , params ): \"\"\" Initialize any diagnosis counts and the agents set. args: params: parameters for this population \"\"\" cls . dx_counts = { race : { so : 0 for so in params . classes . sex_types } for race in params . classes . races } cls . agents = set ()","title":"init_class()"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.progress_to_aids","text":"Model the progression of HIV agents to AIDS agents Parameters: Name Type Description Default model model.TITAN the running model required Source code in titan/exposures/hiv.py def progress_to_aids ( self , model : \"model.TITAN\" ): \"\"\" Model the progression of HIV agents to AIDS agents args: model: the running model \"\"\" aids_prob = self . agent . location . params . hiv . aids . prob p = self . agent . haart . aids_scale () # type: ignore[attr-defined] if model . run_random . random () < p * aids_prob : self . aids = True","title":"progress_to_aids()"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.remove_agent","text":"Remove an agent from the class (not instance). This can be useful if tracking population level statistics or groups, such as counts. Remove the agent from the agents set and decrement the dx_counts if the agent was diagnosed. Parameters: Name Type Description Default agent agent.Agent the agent to remove from the class attributes required Source code in titan/exposures/hiv.py @classmethod def remove_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Remove an agent from the class (not instance). This can be useful if tracking population level statistics or groups, such as counts. Remove the agent from the `agents` set and decrement the `dx_counts` if the agent was diagnosed. args: agent: the agent to remove from the class attributes \"\"\" cls . agents . remove ( agent ) if agent . hiv . dx : # type: ignore[attr-defined] cls . dx_counts [ agent . race ][ agent . sex_type ] -= 1","title":"remove_agent()"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.set_stats","text":"Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled exposure in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/exposures/hiv.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . active : stats [ \"hiv\" ] += 1 if self . time == time : stats [ \"hiv_new\" ] += 1 if self . aids : stats [ \"hiv_aids\" ] += 1 if self . dx : stats [ \"hiv_dx\" ] += 1 if self . dx_time == time : stats [ \"hiv_dx_new\" ] += 1","title":"set_stats()"},{"location":"api/exposures/hiv/#titan.exposures.hiv.HIV.update_agent","text":"Update the agent for this exposure for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only exposures that are enabled per the params. If the agent is hiv+ and the model time is past the hiv start_time, determine if the agent becomes diagnosed if not yet diagnosed, and if the agent has progressed to aids. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/exposures/hiv.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this exposure for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only exposures that are enabled per the params. If the agent is hiv+ and the model time is past the hiv start_time, determine if the agent becomes diagnosed if not yet diagnosed, and if the agent has progressed to aids. args: model: the instance of TITAN currently being run \"\"\" if self . active and model . time >= model . params . hiv . start_time : if not self . dx : test_prob = ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . drug_type [ self . agent . drug_type ] . hiv . dx . prob ) # Rescale based on calibration param test_prob *= model . calibration . test_frequency if model . run_random . random () < test_prob : self . diagnose ( model ) self . progress_to_aids ( model )","title":"update_agent()"},{"location":"api/exposures/knowledge/","text":"name : str Name of exposure in the params file. Also used to name the attribute in Agent stats : List [ str ] Knowledge collects the following stats: knowledge_aware - number of agents with active knowledge convert ( self , model ) Make an agent aware, stochastically make knowledge aware if their opinion meets the threshold. Parameters: Name Type Description Default model model.TITAN The running model required Source code in titan/exposures/knowledge.py def convert ( self , model : \"model.TITAN\" ): \"\"\" Make an agent aware, stochastically make knowledge aware if their opinion meets the threshold. args: model: The running model \"\"\" params = self . agent . location . params . knowledge self . active = True # type: ignore[attr-defined] if ( self . opinion > params . opinion . threshold # type: ignore[attr-defined] and model . run_random . random () < params . feature . prob ): agent_attr = getattr ( self . agent , params . feature . name ) agent_attr . initiate ( model , force = True ) expose ( model , interaction , rel , num_acts ) staticmethod Expose a relationship to the exposure for a number of acts for a specific interaction type. Typically, this determines if the exposure can cause conversion/change in one of the agents, then if so, determines the probability of that and then converts the succeptible agent. If transmission stochastically occurs, either convert the unaware agent, or if both agents aware, have the higher influence agent influce their partner. Parameters: Name Type Description Default model model.TITAN The running model required interaction str The type of interaction (e.g. sex, injection) required rel ag.Relationship The relationship where the interaction is occuring required num_acts int The number of acts of that interaction required Source code in titan/exposures/knowledge.py @staticmethod def expose ( model : \"model.TITAN\" , interaction : str , rel : \"ag.Relationship\" , num_acts : int , ): \"\"\" Expose a relationship to the exposure for a number of acts for a specific interaction type. Typically, this determines if the exposure can cause conversion/change in one of the agents, then if so, determines the probability of that and then converts the succeptible agent. If transmission stochastically occurs, either convert the unaware agent, or if both agents aware, have the higher influence agent influce their partner. args: model: The running model interaction: The type of interaction (e.g. sex, injection) rel: The relationship where the interaction is occuring num_acts: The number of acts of that interaction \"\"\" assert ( model . params . model . network . enable ), \"Network must be enabled for knowledge exposure\" # agent/partner ordering is irrelevant at this point for knowledge transmission p = rel . agent1 . knowledge . get_transmission_probability ( # type: ignore[attr-defined] model , interaction , rel . agent2 , num_acts ) if model . run_random . random () < p : agent1_aware = rel . agent1 . knowledge . active # type: ignore[attr-defined] agent2_aware = rel . agent2 . knowledge . active # type: ignore[attr-defined] if agent1_aware and agent2_aware : influence ( model , rel ) elif agent1_aware : rel . agent2 . knowledge . convert ( model ) # type: ignore[attr-defined] elif agent2_aware : rel . agent1 . knowledge . convert ( model ) # type: ignore[attr-defined] get_transmission_probability ( self , model , interaction , partner , num_acts ) Get the probability of knowledge/opinion transmission in this relationship Parameters: Name Type Description Default model model.TITAN The running model required interaction str The interaction type (e.g. pca ) required partner ag.Agent The agent's partner required num_acts int The number of interactions the agents had required Returns: Type Description float the probability of knowledge/opinion transmission Source code in titan/exposures/knowledge.py def get_transmission_probability ( self , model : \"model.TITAN\" , interaction : str , partner : \"ag.Agent\" , num_acts : int , ) -> float : \"\"\" Get the probability of knowledge/opinion transmission in this relationship args: model: The running model interaction: The interaction type (e.g. `pca`) partner: The agent's partner num_acts: The number of interactions the agents had returns: the probability of knowledge/opinion transmission \"\"\" if not interaction == \"pca\" : return 0.0 if self . active and partner . knowledge . active : # type: ignore[attr-defined] p = model . params . knowledge . opinion . prob else : p = model . params . knowledge . prob return utils . total_probability ( p , num_acts ) init_agent ( self , pop , time ) Initialize the agent for this exposure during population initialization ( Population.create_agent ). Called only on exposures that are enabled per the params. Stochastically make agent aware, if aware, set the opinion from the params. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/exposures/knowledge.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this exposure during population initialization (`Population.create_agent`). Called only on exposures that are enabled per the params. Stochastically make agent aware, if aware, set the opinion from the params. args: pop: the population this agent is a part of time: the current time step \"\"\" knowledge_params = self . agent . location . params . knowledge if pop . pop_random . random () < knowledge_params . init : self . active = True # Initialize all agents with some opinion, may or may not be active self . opinion = utils . get_cumulative_bin ( pop . pop_random , knowledge_params . opinion . init ) set_stats ( self , stats , time ) Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled exposure in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/exposures/knowledge.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . active : stats [ \"knowledge_aware\" ] += 1 update_agent ( self , model ) Update the agent for this exposure for a time step. Called once per time step in TITAN.update_all_agents . If the knowledge start_time has happened, stochastically convert agents. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/exposures/knowledge.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this exposure for a time step. Called once per time step in `TITAN.update_all_agents`. If the knowledge start_time has happened, stochastically convert agents. args: model: the instance of TITAN currently being run \"\"\" knowledge_params = self . agent . location . params . knowledge if ( model . time >= knowledge_params . start_time and not self . active and model . run_random . random () < knowledge_params . prob ): self . convert ( model )","title":"Knowledge"},{"location":"api/exposures/knowledge/#titan.exposures.knowledge.Knowledge.name","text":"Name of exposure in the params file. Also used to name the attribute in Agent","title":"name"},{"location":"api/exposures/knowledge/#titan.exposures.knowledge.Knowledge.stats","text":"Knowledge collects the following stats: knowledge_aware - number of agents with active knowledge","title":"stats"},{"location":"api/exposures/knowledge/#titan.exposures.knowledge.Knowledge.convert","text":"Make an agent aware, stochastically make knowledge aware if their opinion meets the threshold. Parameters: Name Type Description Default model model.TITAN The running model required Source code in titan/exposures/knowledge.py def convert ( self , model : \"model.TITAN\" ): \"\"\" Make an agent aware, stochastically make knowledge aware if their opinion meets the threshold. args: model: The running model \"\"\" params = self . agent . location . params . knowledge self . active = True # type: ignore[attr-defined] if ( self . opinion > params . opinion . threshold # type: ignore[attr-defined] and model . run_random . random () < params . feature . prob ): agent_attr = getattr ( self . agent , params . feature . name ) agent_attr . initiate ( model , force = True )","title":"convert()"},{"location":"api/exposures/knowledge/#titan.exposures.knowledge.Knowledge.expose","text":"Expose a relationship to the exposure for a number of acts for a specific interaction type. Typically, this determines if the exposure can cause conversion/change in one of the agents, then if so, determines the probability of that and then converts the succeptible agent. If transmission stochastically occurs, either convert the unaware agent, or if both agents aware, have the higher influence agent influce their partner. Parameters: Name Type Description Default model model.TITAN The running model required interaction str The type of interaction (e.g. sex, injection) required rel ag.Relationship The relationship where the interaction is occuring required num_acts int The number of acts of that interaction required Source code in titan/exposures/knowledge.py @staticmethod def expose ( model : \"model.TITAN\" , interaction : str , rel : \"ag.Relationship\" , num_acts : int , ): \"\"\" Expose a relationship to the exposure for a number of acts for a specific interaction type. Typically, this determines if the exposure can cause conversion/change in one of the agents, then if so, determines the probability of that and then converts the succeptible agent. If transmission stochastically occurs, either convert the unaware agent, or if both agents aware, have the higher influence agent influce their partner. args: model: The running model interaction: The type of interaction (e.g. sex, injection) rel: The relationship where the interaction is occuring num_acts: The number of acts of that interaction \"\"\" assert ( model . params . model . network . enable ), \"Network must be enabled for knowledge exposure\" # agent/partner ordering is irrelevant at this point for knowledge transmission p = rel . agent1 . knowledge . get_transmission_probability ( # type: ignore[attr-defined] model , interaction , rel . agent2 , num_acts ) if model . run_random . random () < p : agent1_aware = rel . agent1 . knowledge . active # type: ignore[attr-defined] agent2_aware = rel . agent2 . knowledge . active # type: ignore[attr-defined] if agent1_aware and agent2_aware : influence ( model , rel ) elif agent1_aware : rel . agent2 . knowledge . convert ( model ) # type: ignore[attr-defined] elif agent2_aware : rel . agent1 . knowledge . convert ( model ) # type: ignore[attr-defined]","title":"expose()"},{"location":"api/exposures/knowledge/#titan.exposures.knowledge.Knowledge.get_transmission_probability","text":"Get the probability of knowledge/opinion transmission in this relationship Parameters: Name Type Description Default model model.TITAN The running model required interaction str The interaction type (e.g. pca ) required partner ag.Agent The agent's partner required num_acts int The number of interactions the agents had required Returns: Type Description float the probability of knowledge/opinion transmission Source code in titan/exposures/knowledge.py def get_transmission_probability ( self , model : \"model.TITAN\" , interaction : str , partner : \"ag.Agent\" , num_acts : int , ) -> float : \"\"\" Get the probability of knowledge/opinion transmission in this relationship args: model: The running model interaction: The interaction type (e.g. `pca`) partner: The agent's partner num_acts: The number of interactions the agents had returns: the probability of knowledge/opinion transmission \"\"\" if not interaction == \"pca\" : return 0.0 if self . active and partner . knowledge . active : # type: ignore[attr-defined] p = model . params . knowledge . opinion . prob else : p = model . params . knowledge . prob return utils . total_probability ( p , num_acts )","title":"get_transmission_probability()"},{"location":"api/exposures/knowledge/#titan.exposures.knowledge.Knowledge.init_agent","text":"Initialize the agent for this exposure during population initialization ( Population.create_agent ). Called only on exposures that are enabled per the params. Stochastically make agent aware, if aware, set the opinion from the params. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/exposures/knowledge.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this exposure during population initialization (`Population.create_agent`). Called only on exposures that are enabled per the params. Stochastically make agent aware, if aware, set the opinion from the params. args: pop: the population this agent is a part of time: the current time step \"\"\" knowledge_params = self . agent . location . params . knowledge if pop . pop_random . random () < knowledge_params . init : self . active = True # Initialize all agents with some opinion, may or may not be active self . opinion = utils . get_cumulative_bin ( pop . pop_random , knowledge_params . opinion . init )","title":"init_agent()"},{"location":"api/exposures/knowledge/#titan.exposures.knowledge.Knowledge.set_stats","text":"Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled exposure in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/exposures/knowledge.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . active : stats [ \"knowledge_aware\" ] += 1","title":"set_stats()"},{"location":"api/exposures/knowledge/#titan.exposures.knowledge.Knowledge.update_agent","text":"Update the agent for this exposure for a time step. Called once per time step in TITAN.update_all_agents . If the knowledge start_time has happened, stochastically convert agents. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/exposures/knowledge.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this exposure for a time step. Called once per time step in `TITAN.update_all_agents`. If the knowledge start_time has happened, stochastically convert agents. args: model: the instance of TITAN currently being run \"\"\" knowledge_params = self . agent . location . params . knowledge if ( model . time >= knowledge_params . start_time and not self . active and model . run_random . random () < knowledge_params . prob ): self . convert ( model )","title":"update_agent()"},{"location":"api/features/","text":"Agent Features Features from params.features that include an agent attribute (e.g. PrEP, incarceration) are implemented in standalone files that implement the interface from features.BaseFeature . This allows for all of the logic related to a feature to be consolidated in one place and additionally makes incorporating a new feature into the model as simple as possible. To add a new feature: Add the param to param.features Add a file to features/ which creates a class that is a sub-class of BaseFeature Implement the methods of BaseFeature which are needed for this feature Not all methods are needed for all features (see below for details on the methods) Re-export the feature from features/__init__.py Add tests in tests/features/ Add it to the docs in docs/api/features/ and to the nav in mkdocs.yml The TITAN , Population , and Agent classes all use sub-classes of BaseFeature to initialize the object/call methods as appropriate. BaseFeature Interface class for an agent-oriented feature of the TITAN model. It is intended to be inherited by feature classes to ensure that the expected methods/fields exist. The class takes advantage of both instance and class methods and attributes. The instance methods/attributes are used at the agent level, whereas the class methods/attributes are used at the population level. A class method can be called on an instance of an object, but it doesn't have access to that instance (e.g. agent.feature.add_agent has to be passed agent because it is a class method). name : str Name of feature in the params file. Also used to name the attribute in Agent stats : List [ str ] List of names of stats that come from this feature (e.g. numFeat) __init__ ( self , agent ) special Constructor for an instance of the feature. This is called from within Agent.__init__ and passes the agent to the feature to create a two way binding. All features must have the attributes of active and agent . By default active is false and agent is the passed agent. Called on all features whether or not param is enabled to make sure that references to other features within a feature do not cause errors (e.g. incar referring to prep, but prep isn't on). Parameters: Name Type Description Default agent agent.Agent The agent this feature instance is attached to. required Source code in titan/features/base_feature.py def __init__ ( self , agent : \"agent.Agent\" ): \"\"\" Constructor for an instance of the feature. This is called from within `Agent.__init__` and passes the agent to the feature to create a two way binding. All features must have the attributes of `active` and `agent`. By default `active` is false and `agent` is the passed agent. Called on all features whether or not param is enabled to make sure that references to other features within a feature do not cause errors (e.g. incar referring to prep, but prep isn't on). args: agent: The agent this feature instance is attached to. \"\"\" self . active = False self . agent = agent add_agent ( agent ) classmethod Add an agent to the class (not instance). This can be useful if tracking population level statistics or groups, such as counts or newly active agents. This method is not called from anywhere in the model, but creates a cohesive api with remove_agent , which is called from Population.remove_agent . Parameters: Name Type Description Default agent agent.Agent the agent to add to the class attributes required Source code in titan/features/base_feature.py @classmethod def add_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Add an agent to the class (not instance). This can be useful if tracking population level statistics or groups, such as counts or newly active agents. This method is not called from anywhere in the model, but creates a cohesive api with `remove_agent`, which is called from `Population.remove_agent`. args: agent: the agent to add to the class attributes \"\"\" pass get_acquisition_risk_multiplier ( self , time , interaction_type ) Get a multiplier for how this feature affects acquisition of HIV for the given interaction_type. By default, returns 1.0 Parameters: Name Type Description Default time int the current model time step required interaction_type str The type of interaction where the agent could acquire HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) required Source code in titan/features/base_feature.py def get_acquisition_risk_multiplier ( self , time : int , interaction_type : str ): \"\"\" Get a multiplier for how this feature affects acquisition of HIV for the given interaction_type. By default, returns 1.0 args: time: the current model time step interaction_type: The type of interaction where the agent could acquire HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) \"\"\" return 1.0 get_transmission_risk_multiplier ( self , time , interaction_type ) Get a multiplier for how this feature affects transmission of HIV for the given interaction_type. By default, returns 1.0 Parameters: Name Type Description Default time int the current model time step required interaction_type str The type of interaction where the agent could transmit HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) required Source code in titan/features/base_feature.py def get_transmission_risk_multiplier ( self , time : int , interaction_type : str ): \"\"\" Get a multiplier for how this feature affects transmission of HIV for the given interaction_type. By default, returns 1.0 args: time: the current model time step interaction_type: The type of interaction where the agent could transmit HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) \"\"\" return 1.0 init_agent ( self , pop , time ) Initialize the agent for this feature during population initialization ( Population.create_agent ). Called on only features that are enabled per the params. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/features/base_feature.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this feature during population initialization (`Population.create_agent`). Called on only features that are enabled per the params. args: pop: the population this agent is a part of time: the current time step \"\"\" pass init_class ( params ) classmethod Initialize any class level attributes (such as setting counters to zero). Called on every active feature on population initialization. Parameters: Name Type Description Default params parameters for this population required Source code in titan/features/base_feature.py @classmethod def init_class ( cls , params ): \"\"\" Initialize any class level attributes (such as setting counters to zero). Called on every active feature on population initialization. args: params: parameters for this population \"\"\" pass remove_agent ( agent ) classmethod Remove an agent from the class (not instance). This can be useful if tracking population level statistics or groups, such as counts. This method is called from Population.remove_agent , but may also need to be called within the feature if an agent transitions from active == True to active == False . Parameters: Name Type Description Default agent agent.Agent the agent to remove from the class attributes required Source code in titan/features/base_feature.py @classmethod def remove_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Remove an agent from the class (not instance). This can be useful if tracking population level statistics or groups, such as counts. This method is called from `Population.remove_agent`, but may also need to be called within the feature if an agent transitions from `active == True` to `active == False`. args: agent: the agent to remove from the class attributes \"\"\" pass set_stats ( self , stats , time ) Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled feature in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/features/base_feature.py def set_stats ( self , stats : Dict [ str , int ], time : int ): \"\"\" Update the `stats` dictionary passed for this agent. Called from `output.get_stats` for each enabled feature in the model. The stats to be updated must be declared in the class attribute `stats` to make sure the dictionary has the expected keys/counter value initialized. args: stats: the dictionary to update with this agent's feature statistics time: the time step of the model when the stats are set \"\"\" pass update_agent ( self , model ) Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/base_feature.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. args: model: the instance of TITAN currently being run \"\"\" pass update_pop ( model ) classmethod Update the feature for the entire population (class method). This is useful for initializing class level trackers that need to be reset each time step, or if enabling a feature for agents needs to be evaluated within the context of the full population (limited slots, or similar). This is called in TITAN.update_all_agents before agent-level updates are made. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/base_feature.py @classmethod def update_pop ( cls , model : \"model.TITAN\" ): \"\"\" Update the feature for the entire population (class method). This is useful for initializing class level trackers that need to be reset each time step, or if enabling a feature for agents needs to be evaluated within the context of the full population (limited slots, or similar). This is called in `TITAN.update_all_agents` before agent-level updates are made. args: model: the instance of TITAN currently being run \"\"\" pass","title":"Overview"},{"location":"api/features/#agent-features","text":"Features from params.features that include an agent attribute (e.g. PrEP, incarceration) are implemented in standalone files that implement the interface from features.BaseFeature . This allows for all of the logic related to a feature to be consolidated in one place and additionally makes incorporating a new feature into the model as simple as possible. To add a new feature: Add the param to param.features Add a file to features/ which creates a class that is a sub-class of BaseFeature Implement the methods of BaseFeature which are needed for this feature Not all methods are needed for all features (see below for details on the methods) Re-export the feature from features/__init__.py Add tests in tests/features/ Add it to the docs in docs/api/features/ and to the nav in mkdocs.yml The TITAN , Population , and Agent classes all use sub-classes of BaseFeature to initialize the object/call methods as appropriate.","title":"Agent Features"},{"location":"api/features/#titan.features.base_feature.BaseFeature","text":"Interface class for an agent-oriented feature of the TITAN model. It is intended to be inherited by feature classes to ensure that the expected methods/fields exist. The class takes advantage of both instance and class methods and attributes. The instance methods/attributes are used at the agent level, whereas the class methods/attributes are used at the population level. A class method can be called on an instance of an object, but it doesn't have access to that instance (e.g. agent.feature.add_agent has to be passed agent because it is a class method).","title":"BaseFeature"},{"location":"api/features/#titan.features.base_feature.BaseFeature.name","text":"Name of feature in the params file. Also used to name the attribute in Agent","title":"name"},{"location":"api/features/#titan.features.base_feature.BaseFeature.stats","text":"List of names of stats that come from this feature (e.g. numFeat)","title":"stats"},{"location":"api/features/#titan.features.base_feature.BaseFeature.__init__","text":"Constructor for an instance of the feature. This is called from within Agent.__init__ and passes the agent to the feature to create a two way binding. All features must have the attributes of active and agent . By default active is false and agent is the passed agent. Called on all features whether or not param is enabled to make sure that references to other features within a feature do not cause errors (e.g. incar referring to prep, but prep isn't on). Parameters: Name Type Description Default agent agent.Agent The agent this feature instance is attached to. required Source code in titan/features/base_feature.py def __init__ ( self , agent : \"agent.Agent\" ): \"\"\" Constructor for an instance of the feature. This is called from within `Agent.__init__` and passes the agent to the feature to create a two way binding. All features must have the attributes of `active` and `agent`. By default `active` is false and `agent` is the passed agent. Called on all features whether or not param is enabled to make sure that references to other features within a feature do not cause errors (e.g. incar referring to prep, but prep isn't on). args: agent: The agent this feature instance is attached to. \"\"\" self . active = False self . agent = agent","title":"__init__()"},{"location":"api/features/#titan.features.base_feature.BaseFeature.add_agent","text":"Add an agent to the class (not instance). This can be useful if tracking population level statistics or groups, such as counts or newly active agents. This method is not called from anywhere in the model, but creates a cohesive api with remove_agent , which is called from Population.remove_agent . Parameters: Name Type Description Default agent agent.Agent the agent to add to the class attributes required Source code in titan/features/base_feature.py @classmethod def add_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Add an agent to the class (not instance). This can be useful if tracking population level statistics or groups, such as counts or newly active agents. This method is not called from anywhere in the model, but creates a cohesive api with `remove_agent`, which is called from `Population.remove_agent`. args: agent: the agent to add to the class attributes \"\"\" pass","title":"add_agent()"},{"location":"api/features/#titan.features.base_feature.BaseFeature.get_acquisition_risk_multiplier","text":"Get a multiplier for how this feature affects acquisition of HIV for the given interaction_type. By default, returns 1.0 Parameters: Name Type Description Default time int the current model time step required interaction_type str The type of interaction where the agent could acquire HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) required Source code in titan/features/base_feature.py def get_acquisition_risk_multiplier ( self , time : int , interaction_type : str ): \"\"\" Get a multiplier for how this feature affects acquisition of HIV for the given interaction_type. By default, returns 1.0 args: time: the current model time step interaction_type: The type of interaction where the agent could acquire HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) \"\"\" return 1.0","title":"get_acquisition_risk_multiplier()"},{"location":"api/features/#titan.features.base_feature.BaseFeature.get_transmission_risk_multiplier","text":"Get a multiplier for how this feature affects transmission of HIV for the given interaction_type. By default, returns 1.0 Parameters: Name Type Description Default time int the current model time step required interaction_type str The type of interaction where the agent could transmit HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) required Source code in titan/features/base_feature.py def get_transmission_risk_multiplier ( self , time : int , interaction_type : str ): \"\"\" Get a multiplier for how this feature affects transmission of HIV for the given interaction_type. By default, returns 1.0 args: time: the current model time step interaction_type: The type of interaction where the agent could transmit HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) \"\"\" return 1.0","title":"get_transmission_risk_multiplier()"},{"location":"api/features/#titan.features.base_feature.BaseFeature.init_agent","text":"Initialize the agent for this feature during population initialization ( Population.create_agent ). Called on only features that are enabled per the params. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/features/base_feature.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this feature during population initialization (`Population.create_agent`). Called on only features that are enabled per the params. args: pop: the population this agent is a part of time: the current time step \"\"\" pass","title":"init_agent()"},{"location":"api/features/#titan.features.base_feature.BaseFeature.init_class","text":"Initialize any class level attributes (such as setting counters to zero). Called on every active feature on population initialization. Parameters: Name Type Description Default params parameters for this population required Source code in titan/features/base_feature.py @classmethod def init_class ( cls , params ): \"\"\" Initialize any class level attributes (such as setting counters to zero). Called on every active feature on population initialization. args: params: parameters for this population \"\"\" pass","title":"init_class()"},{"location":"api/features/#titan.features.base_feature.BaseFeature.remove_agent","text":"Remove an agent from the class (not instance). This can be useful if tracking population level statistics or groups, such as counts. This method is called from Population.remove_agent , but may also need to be called within the feature if an agent transitions from active == True to active == False . Parameters: Name Type Description Default agent agent.Agent the agent to remove from the class attributes required Source code in titan/features/base_feature.py @classmethod def remove_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Remove an agent from the class (not instance). This can be useful if tracking population level statistics or groups, such as counts. This method is called from `Population.remove_agent`, but may also need to be called within the feature if an agent transitions from `active == True` to `active == False`. args: agent: the agent to remove from the class attributes \"\"\" pass","title":"remove_agent()"},{"location":"api/features/#titan.features.base_feature.BaseFeature.set_stats","text":"Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled feature in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/features/base_feature.py def set_stats ( self , stats : Dict [ str , int ], time : int ): \"\"\" Update the `stats` dictionary passed for this agent. Called from `output.get_stats` for each enabled feature in the model. The stats to be updated must be declared in the class attribute `stats` to make sure the dictionary has the expected keys/counter value initialized. args: stats: the dictionary to update with this agent's feature statistics time: the time step of the model when the stats are set \"\"\" pass","title":"set_stats()"},{"location":"api/features/#titan.features.base_feature.BaseFeature.update_agent","text":"Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/base_feature.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. args: model: the instance of TITAN currently being run \"\"\" pass","title":"update_agent()"},{"location":"api/features/#titan.features.base_feature.BaseFeature.update_pop","text":"Update the feature for the entire population (class method). This is useful for initializing class level trackers that need to be reset each time step, or if enabling a feature for agents needs to be evaluated within the context of the full population (limited slots, or similar). This is called in TITAN.update_all_agents before agent-level updates are made. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/base_feature.py @classmethod def update_pop ( cls , model : \"model.TITAN\" ): \"\"\" Update the feature for the entire population (class method). This is useful for initializing class level trackers that need to be reset each time step, or if enabling a feature for agents needs to be evaluated within the context of the full population (limited slots, or similar). This is called in `TITAN.update_all_agents` before agent-level updates are made. args: model: the instance of TITAN currently being run \"\"\" pass","title":"update_pop()"},{"location":"api/features/external_exposure/","text":"name : str Name of feature in the params file. Also used to name the attribute in Agent init_agent ( self , pop , time ) Initialize the agent for this feature during population initialization ( Population.create_agent ). Called on only features that are enabled per the params. If an agent has defined sex_type, with a random probability from params, assign them to be an agent with external exposure. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/features/external_exposure.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this feature during population initialization (`Population.create_agent`). Called on only features that are enabled per the params. If an agent has defined sex_type, with a random probability from params, assign them to be an agent with external exposure. args: pop: the population this agent is a part of time: the current time step \"\"\" params = self . agent . location . params . external_exposure if self . agent . sex_type == params . sex_type : if pop . pop_random . random () < params . init : self . active = True update_agent ( self , model ) Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. If the agent has external exposure, with a probability from params, convert the agent. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/external_exposure.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. If the agent has external exposure, with a probability from params, convert the agent. args: model: the instance of TITAN currently being run \"\"\" params = self . agent . location . params . external_exposure if self . active and model . run_random . random () < params . convert_prob : agent_exposure = getattr ( self . agent , params . exposure ) agent_exposure . convert ( model )","title":"External Exposure"},{"location":"api/features/external_exposure/#titan.features.external_exposure.ExternalExposure.name","text":"Name of feature in the params file. Also used to name the attribute in Agent","title":"name"},{"location":"api/features/external_exposure/#titan.features.external_exposure.ExternalExposure.init_agent","text":"Initialize the agent for this feature during population initialization ( Population.create_agent ). Called on only features that are enabled per the params. If an agent has defined sex_type, with a random probability from params, assign them to be an agent with external exposure. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/features/external_exposure.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this feature during population initialization (`Population.create_agent`). Called on only features that are enabled per the params. If an agent has defined sex_type, with a random probability from params, assign them to be an agent with external exposure. args: pop: the population this agent is a part of time: the current time step \"\"\" params = self . agent . location . params . external_exposure if self . agent . sex_type == params . sex_type : if pop . pop_random . random () < params . init : self . active = True","title":"init_agent()"},{"location":"api/features/external_exposure/#titan.features.external_exposure.ExternalExposure.update_agent","text":"Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. If the agent has external exposure, with a probability from params, convert the agent. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/external_exposure.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. If the agent has external exposure, with a probability from params, convert the agent. args: model: the instance of TITAN currently being run \"\"\" params = self . agent . location . params . external_exposure if self . active and model . run_random . random () < params . convert_prob : agent_exposure = getattr ( self . agent , params . exposure ) agent_exposure . convert ( model )","title":"update_agent()"},{"location":"api/features/haart/","text":"Highly Active Antiretroviral Theray (HAART) is a treatment regimen. name : str Name of feature in the params file. Also used to name the attribute in Agent stats : List [ str ] HAART collects the following stats: haart - number of agents with active haart add_agent ( agent ) classmethod Add an agent to the class (not instance). Increments counts or haart agents by race and sex_type for the given agent. Parameters: Name Type Description Default agent agent.Agent the agent to add to the class attributes required Source code in titan/features/haart.py @classmethod def add_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Add an agent to the class (not instance). Increments `counts` or haart agents by race and sex_type for the given agent. args: agent: the agent to add to the class attributes \"\"\" cls . counts [ agent . race ][ agent . sex_type ] += 1 enroll ( self , model , haart_params ) Determine whether to enroll an agent in HAART. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required haart_params ObjMap the HAART demographic params for this agent required Source code in titan/features/haart.py def enroll ( self , model : \"model.TITAN\" , haart_params : ObjMap ): \"\"\" Determine whether to enroll an agent in HAART. args: model: the instance of TITAN currently being run haart_params: the HAART demographic params for this agent \"\"\" if self . agent . location . params . haart . use_cap : self . enroll_cap ( model , haart_params ) else : self . enroll_prob ( model , haart_params ) enroll_cap ( self , model , haart_params ) Determine whether to enroll an agent in HAART using the cap method. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required haart_params ObjMap the HAART demographic params for this agent required Source code in titan/features/haart.py def enroll_cap ( self , model : \"model.TITAN\" , haart_params : ObjMap ): \"\"\" Determine whether to enroll an agent in HAART using the cap method. args: model: the instance of TITAN currently being run haart_params: the HAART demographic params for this agent \"\"\" race = self . agent . race sex_type = self . agent . sex_type # if HAART is based on cap instead of prob, determine number of # HAART agents based on % of diagnosed agents num_dx_agents = self . agent . hiv . dx_counts [ race ][ sex_type ] # type: ignore[attr-defined] num_haart_agents = self . counts [ race ][ sex_type ] # take value from dictionary for cap if num_haart_agents < ( haart_params . cap * num_dx_agents ): self . initiate ( model . run_random , haart_params , \"prob\" ) enroll_prob ( self , model , haart_params ) Determine whether to enroll an agent in HAART using probability method. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required haart_params ObjMap the HAART demographic params for this agent required Source code in titan/features/haart.py def enroll_prob ( self , model : \"model.TITAN\" , haart_params : ObjMap ): \"\"\" Determine whether to enroll an agent in HAART using probability method. args: model: the instance of TITAN currently being run haart_params: the HAART demographic params for this agent \"\"\" if self . ever and self . agent . location . params . haart . use_reinit : if model . run_random . random () < haart_params . reinit . prob : self . initiate ( model . run_random , haart_params , \"prob\" ) else : # Find enroll probability based on time since diagnosis enroll_prob = 0.0 dx_duration = model . time - self . agent . hiv . dx_time # type: ignore[attr-defined] for i in haart_params . enroll . values (): if i . start <= dx_duration < i . stop : enroll_prob = i . prob * model . calibration . haart . coverage break if model . run_random . random () < ( enroll_prob ): self . initiate ( model . run_random , haart_params , \"prob\" ) get_transmission_risk_multiplier ( self , time , interaction_type ) Get a multiplier for how haart reduces hiv transmission risk based on interaction type and params. By default, returns 1.0 Parameters: Name Type Description Default time int the current model time step required interaction_type str The type of interaction where the agent could transmit HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) required Source code in titan/features/haart.py def get_transmission_risk_multiplier ( self , time : int , interaction_type : str ): \"\"\" Get a multiplier for how haart reduces hiv transmission risk based on interaction type and params. By default, returns 1.0 args: time: the current model time step interaction_type: The type of interaction where the agent could transmit HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) \"\"\" prob = 1.0 if self . active : params = self . agent . location . params adherence = \"adherent\" if self . adherent else \"non_adherent\" if interaction_type == \"injection\" : prob = params . partnership . injection . transmission . haart_scaling [ adherence ] elif interaction_type == \"sex\" : prob = params . partnership . sex . haart_scaling [ self . agent . sex_type ][ adherence ] # Tuning parameter for ART efficiency prob *= params . calibration . haart . transmission return prob init_agent ( self , pop , time ) Initialize the agent for this feature during population initialization ( Population.create_agent ). Called on only features that are enabled per the params. An Agent can only be initialized with HAART if they are HIV+ and diagnosed. They are randomly assigned to HAART with a probability based on demographics and then if assigned to haart, assigned an adherence based on those same demographic params. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/features/haart.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this feature during population initialization (`Population.create_agent`). Called on only features that are enabled per the params. An Agent can only be initialized with HAART if they are HIV+ and diagnosed. They are randomly assigned to HAART with a probability based on demographics and then if assigned to haart, assigned an adherence based on those same demographic params. args: pop: the population this agent is a part of time: the current time step \"\"\" haart_params = ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . drug_type [ self . agent . drug_type ] . haart ) if ( self . agent . hiv . dx # type: ignore[attr-defined] and pop . pop_random . random () < haart_params . init ): self . initiate ( pop . pop_random , haart_params , \"init\" ) init_class ( params ) classmethod Initialize the counts dictionary for the races and sex_types in the model. Parameters: Name Type Description Default params ObjMap the population params required Source code in titan/features/haart.py @classmethod def init_class ( cls , params : \"ObjMap\" ): \"\"\" Initialize the counts dictionary for the races and sex_types in the model. args: params: the population params \"\"\" cls . counts = { race : { sex_type : 0 for sex_type in params . classes . sex_types } for race in params . classes . races } initiate ( self , rand_gen , haart_params , init_or_prob ) Initiate an agent with HAART and add them to the population. Parameters: Name Type Description Default model the instance of TITAN currently being run required Source code in titan/features/haart.py def initiate ( self , rand_gen , haart_params : ObjMap , init_or_prob : str ): \"\"\" Initiate an agent with HAART and add them to the population. args: model: the instance of TITAN currently being run \"\"\" self . adherent = rand_gen . random () < haart_params . adherence [ init_or_prob ] # Add agent to HAART class set, update agent params self . active = True self . ever = True self . add_agent ( self . agent ) remove_agent ( agent ) classmethod Remove an agent from the class (not instance). Decrements counts or haart agents by race and sex_type for the given agent. Parameters: Name Type Description Default agent agent.Agent the agent to remove from the class attributes required Source code in titan/features/haart.py @classmethod def remove_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Remove an agent from the class (not instance). Decrements `counts` or haart agents by race and sex_type for the given agent. args: agent: the agent to remove from the class attributes \"\"\" cls . counts [ agent . race ][ agent . sex_type ] -= 1 set_stats ( self , stats , time ) Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled feature in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/features/haart.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . active : stats [ \"haart\" ] += 1 update_agent ( self , model ) Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. Account for HIV treatment through highly active antiretroviral therapy (HAART). HAART was implemented in 1996, hence, there is treatment only after 1996. HIV treatment assumes that the agent knows their HIV+ status ( dx is True). Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/haart.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. Account for HIV treatment through highly active antiretroviral therapy (HAART). HAART was implemented in 1996, hence, there is treatment only after 1996. HIV treatment assumes that the agent knows their HIV+ status (`dx` is True). args: model: the instance of TITAN currently being run \"\"\" if ( self . agent . hiv . dx # type: ignore[attr-defined] and model . time >= model . params . hiv . start_time # haart starts with hiv ): # Determine probability of HIV treatment haart_params = ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . drug_type [ self . agent . drug_type ] . haart ) # Go on HAART if not self . active : self . enroll ( model , haart_params ) # Update agents on HAART else : # Go off HAART if model . run_random . random () < haart_params . discontinue : self . active = False self . adherent = False self . remove_agent ( self . agent ) # Become non-adherent elif ( self . adherent and model . run_random . random () < haart_params . adherence . discontinue ): self . adherent = False # Become adherent elif ( not self . adherent and model . run_random . random () < haart_params . adherence . become ): self . adherent = True","title":"HAART"},{"location":"api/features/haart/#titan.features.haart.HAART.name","text":"Name of feature in the params file. Also used to name the attribute in Agent","title":"name"},{"location":"api/features/haart/#titan.features.haart.HAART.stats","text":"HAART collects the following stats: haart - number of agents with active haart","title":"stats"},{"location":"api/features/haart/#titan.features.haart.HAART.add_agent","text":"Add an agent to the class (not instance). Increments counts or haart agents by race and sex_type for the given agent. Parameters: Name Type Description Default agent agent.Agent the agent to add to the class attributes required Source code in titan/features/haart.py @classmethod def add_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Add an agent to the class (not instance). Increments `counts` or haart agents by race and sex_type for the given agent. args: agent: the agent to add to the class attributes \"\"\" cls . counts [ agent . race ][ agent . sex_type ] += 1","title":"add_agent()"},{"location":"api/features/haart/#titan.features.haart.HAART.enroll","text":"Determine whether to enroll an agent in HAART. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required haart_params ObjMap the HAART demographic params for this agent required Source code in titan/features/haart.py def enroll ( self , model : \"model.TITAN\" , haart_params : ObjMap ): \"\"\" Determine whether to enroll an agent in HAART. args: model: the instance of TITAN currently being run haart_params: the HAART demographic params for this agent \"\"\" if self . agent . location . params . haart . use_cap : self . enroll_cap ( model , haart_params ) else : self . enroll_prob ( model , haart_params )","title":"enroll()"},{"location":"api/features/haart/#titan.features.haart.HAART.enroll_cap","text":"Determine whether to enroll an agent in HAART using the cap method. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required haart_params ObjMap the HAART demographic params for this agent required Source code in titan/features/haart.py def enroll_cap ( self , model : \"model.TITAN\" , haart_params : ObjMap ): \"\"\" Determine whether to enroll an agent in HAART using the cap method. args: model: the instance of TITAN currently being run haart_params: the HAART demographic params for this agent \"\"\" race = self . agent . race sex_type = self . agent . sex_type # if HAART is based on cap instead of prob, determine number of # HAART agents based on % of diagnosed agents num_dx_agents = self . agent . hiv . dx_counts [ race ][ sex_type ] # type: ignore[attr-defined] num_haart_agents = self . counts [ race ][ sex_type ] # take value from dictionary for cap if num_haart_agents < ( haart_params . cap * num_dx_agents ): self . initiate ( model . run_random , haart_params , \"prob\" )","title":"enroll_cap()"},{"location":"api/features/haart/#titan.features.haart.HAART.enroll_prob","text":"Determine whether to enroll an agent in HAART using probability method. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required haart_params ObjMap the HAART demographic params for this agent required Source code in titan/features/haart.py def enroll_prob ( self , model : \"model.TITAN\" , haart_params : ObjMap ): \"\"\" Determine whether to enroll an agent in HAART using probability method. args: model: the instance of TITAN currently being run haart_params: the HAART demographic params for this agent \"\"\" if self . ever and self . agent . location . params . haart . use_reinit : if model . run_random . random () < haart_params . reinit . prob : self . initiate ( model . run_random , haart_params , \"prob\" ) else : # Find enroll probability based on time since diagnosis enroll_prob = 0.0 dx_duration = model . time - self . agent . hiv . dx_time # type: ignore[attr-defined] for i in haart_params . enroll . values (): if i . start <= dx_duration < i . stop : enroll_prob = i . prob * model . calibration . haart . coverage break if model . run_random . random () < ( enroll_prob ): self . initiate ( model . run_random , haart_params , \"prob\" )","title":"enroll_prob()"},{"location":"api/features/haart/#titan.features.haart.HAART.get_transmission_risk_multiplier","text":"Get a multiplier for how haart reduces hiv transmission risk based on interaction type and params. By default, returns 1.0 Parameters: Name Type Description Default time int the current model time step required interaction_type str The type of interaction where the agent could transmit HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) required Source code in titan/features/haart.py def get_transmission_risk_multiplier ( self , time : int , interaction_type : str ): \"\"\" Get a multiplier for how haart reduces hiv transmission risk based on interaction type and params. By default, returns 1.0 args: time: the current model time step interaction_type: The type of interaction where the agent could transmit HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) \"\"\" prob = 1.0 if self . active : params = self . agent . location . params adherence = \"adherent\" if self . adherent else \"non_adherent\" if interaction_type == \"injection\" : prob = params . partnership . injection . transmission . haart_scaling [ adherence ] elif interaction_type == \"sex\" : prob = params . partnership . sex . haart_scaling [ self . agent . sex_type ][ adherence ] # Tuning parameter for ART efficiency prob *= params . calibration . haart . transmission return prob","title":"get_transmission_risk_multiplier()"},{"location":"api/features/haart/#titan.features.haart.HAART.init_agent","text":"Initialize the agent for this feature during population initialization ( Population.create_agent ). Called on only features that are enabled per the params. An Agent can only be initialized with HAART if they are HIV+ and diagnosed. They are randomly assigned to HAART with a probability based on demographics and then if assigned to haart, assigned an adherence based on those same demographic params. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/features/haart.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this feature during population initialization (`Population.create_agent`). Called on only features that are enabled per the params. An Agent can only be initialized with HAART if they are HIV+ and diagnosed. They are randomly assigned to HAART with a probability based on demographics and then if assigned to haart, assigned an adherence based on those same demographic params. args: pop: the population this agent is a part of time: the current time step \"\"\" haart_params = ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . drug_type [ self . agent . drug_type ] . haart ) if ( self . agent . hiv . dx # type: ignore[attr-defined] and pop . pop_random . random () < haart_params . init ): self . initiate ( pop . pop_random , haart_params , \"init\" )","title":"init_agent()"},{"location":"api/features/haart/#titan.features.haart.HAART.init_class","text":"Initialize the counts dictionary for the races and sex_types in the model. Parameters: Name Type Description Default params ObjMap the population params required Source code in titan/features/haart.py @classmethod def init_class ( cls , params : \"ObjMap\" ): \"\"\" Initialize the counts dictionary for the races and sex_types in the model. args: params: the population params \"\"\" cls . counts = { race : { sex_type : 0 for sex_type in params . classes . sex_types } for race in params . classes . races }","title":"init_class()"},{"location":"api/features/haart/#titan.features.haart.HAART.initiate","text":"Initiate an agent with HAART and add them to the population. Parameters: Name Type Description Default model the instance of TITAN currently being run required Source code in titan/features/haart.py def initiate ( self , rand_gen , haart_params : ObjMap , init_or_prob : str ): \"\"\" Initiate an agent with HAART and add them to the population. args: model: the instance of TITAN currently being run \"\"\" self . adherent = rand_gen . random () < haart_params . adherence [ init_or_prob ] # Add agent to HAART class set, update agent params self . active = True self . ever = True self . add_agent ( self . agent )","title":"initiate()"},{"location":"api/features/haart/#titan.features.haart.HAART.remove_agent","text":"Remove an agent from the class (not instance). Decrements counts or haart agents by race and sex_type for the given agent. Parameters: Name Type Description Default agent agent.Agent the agent to remove from the class attributes required Source code in titan/features/haart.py @classmethod def remove_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Remove an agent from the class (not instance). Decrements `counts` or haart agents by race and sex_type for the given agent. args: agent: the agent to remove from the class attributes \"\"\" cls . counts [ agent . race ][ agent . sex_type ] -= 1","title":"remove_agent()"},{"location":"api/features/haart/#titan.features.haart.HAART.set_stats","text":"Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled feature in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/features/haart.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . active : stats [ \"haart\" ] += 1","title":"set_stats()"},{"location":"api/features/haart/#titan.features.haart.HAART.update_agent","text":"Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. Account for HIV treatment through highly active antiretroviral therapy (HAART). HAART was implemented in 1996, hence, there is treatment only after 1996. HIV treatment assumes that the agent knows their HIV+ status ( dx is True). Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/haart.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. Account for HIV treatment through highly active antiretroviral therapy (HAART). HAART was implemented in 1996, hence, there is treatment only after 1996. HIV treatment assumes that the agent knows their HIV+ status (`dx` is True). args: model: the instance of TITAN currently being run \"\"\" if ( self . agent . hiv . dx # type: ignore[attr-defined] and model . time >= model . params . hiv . start_time # haart starts with hiv ): # Determine probability of HIV treatment haart_params = ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . drug_type [ self . agent . drug_type ] . haart ) # Go on HAART if not self . active : self . enroll ( model , haart_params ) # Update agents on HAART else : # Go off HAART if model . run_random . random () < haart_params . discontinue : self . active = False self . adherent = False self . remove_agent ( self . agent ) # Become non-adherent elif ( self . adherent and model . run_random . random () < haart_params . adherence . discontinue ): self . adherent = False # Become adherent elif ( not self . adherent and model . run_random . random () < haart_params . adherence . become ): self . adherent = True","title":"update_agent()"},{"location":"api/features/high_risk/","text":"name : str Name of feature in the params file. Also used to name the attribute in Agent stats : List [ str ] High Risk collects the following stats: high_risk_new - number of agents that became active high risk this time step high_risk_new_hiv - number of agents that became active high risk this time step with HIV high_risk_new_aids - number of agents that became active high risk this time step with AIDS high_risk_new_dx - number of agents that became active high risk this time step with diagnosed HIV high_risk_new_haart - number of agents that became active high risk this time step with active HAART hiv_new_high_risk - number of agents that became active with HIV this time step who are high risk hiv_new_high_risk_ever - number of agents that became active with HIV this time step were ever high risk become_high_risk ( self , pop , time , duration = None ) Mark an agent as high risk and assign a duration to their high risk period Parameters: Name Type Description Default pop population.Population the model poopulation required time int the time step the agent is becoming high risk required duration int duration of the high risk period, defaults to param value if not passed [params.high_risk.sex_based] None Source code in titan/features/high_risk.py def become_high_risk ( self , pop : \"population.Population\" , time : int , duration : int = None ): \"\"\" Mark an agent as high risk and assign a duration to their high risk period args: pop: the model poopulation time: the time step the agent is becoming high risk duration: duration of the high risk period, defaults to param value if not passed [params.high_risk.sex_based] \"\"\" if not self . agent . location . params . features . high_risk : return None if not self . ever : self . time = time self . active = True self . ever = True if duration is not None : self . duration = duration else : self . duration = self . agent . location . params . high_risk . sex_based [ self . agent . sex_type ] . duration self . update_partner_numbers ( pop , self . agent . location . params . high_risk . partner_scale ) init_agent ( self , pop , time ) Initialize the agent for this feature during population initialization ( Population.create_agent ). Called on only features that are enabled per the params. Based on agent demographic params, randomly initialize agent as high risk. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/features/high_risk.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this feature during population initialization (`Population.create_agent`). Called on only features that are enabled per the params. Based on agent demographic params, randomly initialize agent as high risk. args: pop: the population this agent is a part of time: the current time step \"\"\" if ( pop . pop_random . random () < self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . high_risk . init ): self . become_high_risk ( pop , time ) set_stats ( self , stats , time ) Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled feature in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/features/high_risk.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . time == time : stats [ \"high_risk_new\" ] += 1 if self . agent . hiv . active : # type: ignore[attr-defined] stats [ \"high_risk_new_hiv\" ] += 1 if self . agent . hiv . aids : # type: ignore[attr-defined] stats [ \"high_risk_new_aids\" ] += 1 if self . agent . hiv . dx : # type: ignore[attr-defined] stats [ \"high_risk_new_dx\" ] += 1 if self . agent . haart . active : # type: ignore[attr-defined] stats [ \"high_risk_new_haart\" ] += 1 # newly hiv if self . agent . hiv . time == time : # type: ignore[attr-defined] if self . active : stats [ \"hiv_new_high_risk\" ] += 1 if self . ever : stats [ \"hiv_new_high_risk_ever\" ] += 1 update_agent ( self , model ) Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. Update high risk agents or remove them from high risk pool. An agent becomes high_risk through the incarceration feature Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/high_risk.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. Update high risk agents or remove them from high risk pool. An agent becomes high_risk through the incarceration feature args: model: the instance of TITAN currently being run \"\"\" if not self . active : # released last step, evaluate agent for high risk if self . agent . incar . release_time == model . time - 1 : # type: ignore[attr-defined] self . become_high_risk ( model . pop , model . time ) # incarcerated last step, evaluate agent's partners for high risk elif self . agent . incar . time == model . time - 1 : # type: ignore[attr-defined] # put partners in high risk for partner in self . agent . get_partners ( self . agent . location . params . high_risk . partnership_types ): if ( not partner . high_risk . active # type: ignore[attr-defined] and model . run_random . random () < partner . location . params . high_risk . prob ): partner . high_risk . become_high_risk ( model . pop , model . time ) # type: ignore[attr-defined] elif self . duration > 0 : self . duration -= 1 else : self . active = False self . update_partner_numbers ( model . pop , - 1 * self . agent . location . params . high_risk . partner_scale ) for bond in self . agent . location . params . high_risk . partnership_types : num_ended = 0 while ( len ( self . agent . partners [ bond ]) - num_ended ) > self . agent . target_partners [ bond ]: rel = utils . safe_random_choice ( self . agent . relationships , model . run_random ) if rel is not None : num_ended += 1 rel . duration = 0 # will end on next step update_partner_numbers ( self , pop , amount ) Update the agent's mean and target partner numbers by the amount passed. Update partnerability for the population. Parameters: Name Type Description Default pop population.Population the model population required amount int the positive or negatative amount to adjust the mean by required Source code in titan/features/high_risk.py def update_partner_numbers ( self , pop : \"population.Population\" , amount : int ): \"\"\" Update the agent's mean and target partner numbers by the amount passed. Update partnerability for the population. args: pop: the model population amount: the positive or negatative amount to adjust the mean by \"\"\" for bond in self . agent . location . params . high_risk . partnership_types : self . agent . mean_num_partners [ bond ] += amount # could be negative self . agent . target_partners [ bond ] = utils . poisson ( self . agent . mean_num_partners [ bond ], pop . np_random ) pop . update_partnerability ( self . agent )","title":"High Risk"},{"location":"api/features/high_risk/#titan.features.high_risk.HighRisk.name","text":"Name of feature in the params file. Also used to name the attribute in Agent","title":"name"},{"location":"api/features/high_risk/#titan.features.high_risk.HighRisk.stats","text":"High Risk collects the following stats: high_risk_new - number of agents that became active high risk this time step high_risk_new_hiv - number of agents that became active high risk this time step with HIV high_risk_new_aids - number of agents that became active high risk this time step with AIDS high_risk_new_dx - number of agents that became active high risk this time step with diagnosed HIV high_risk_new_haart - number of agents that became active high risk this time step with active HAART hiv_new_high_risk - number of agents that became active with HIV this time step who are high risk hiv_new_high_risk_ever - number of agents that became active with HIV this time step were ever high risk","title":"stats"},{"location":"api/features/high_risk/#titan.features.high_risk.HighRisk.become_high_risk","text":"Mark an agent as high risk and assign a duration to their high risk period Parameters: Name Type Description Default pop population.Population the model poopulation required time int the time step the agent is becoming high risk required duration int duration of the high risk period, defaults to param value if not passed [params.high_risk.sex_based] None Source code in titan/features/high_risk.py def become_high_risk ( self , pop : \"population.Population\" , time : int , duration : int = None ): \"\"\" Mark an agent as high risk and assign a duration to their high risk period args: pop: the model poopulation time: the time step the agent is becoming high risk duration: duration of the high risk period, defaults to param value if not passed [params.high_risk.sex_based] \"\"\" if not self . agent . location . params . features . high_risk : return None if not self . ever : self . time = time self . active = True self . ever = True if duration is not None : self . duration = duration else : self . duration = self . agent . location . params . high_risk . sex_based [ self . agent . sex_type ] . duration self . update_partner_numbers ( pop , self . agent . location . params . high_risk . partner_scale )","title":"become_high_risk()"},{"location":"api/features/high_risk/#titan.features.high_risk.HighRisk.init_agent","text":"Initialize the agent for this feature during population initialization ( Population.create_agent ). Called on only features that are enabled per the params. Based on agent demographic params, randomly initialize agent as high risk. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/features/high_risk.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this feature during population initialization (`Population.create_agent`). Called on only features that are enabled per the params. Based on agent demographic params, randomly initialize agent as high risk. args: pop: the population this agent is a part of time: the current time step \"\"\" if ( pop . pop_random . random () < self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . high_risk . init ): self . become_high_risk ( pop , time )","title":"init_agent()"},{"location":"api/features/high_risk/#titan.features.high_risk.HighRisk.set_stats","text":"Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled feature in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/features/high_risk.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . time == time : stats [ \"high_risk_new\" ] += 1 if self . agent . hiv . active : # type: ignore[attr-defined] stats [ \"high_risk_new_hiv\" ] += 1 if self . agent . hiv . aids : # type: ignore[attr-defined] stats [ \"high_risk_new_aids\" ] += 1 if self . agent . hiv . dx : # type: ignore[attr-defined] stats [ \"high_risk_new_dx\" ] += 1 if self . agent . haart . active : # type: ignore[attr-defined] stats [ \"high_risk_new_haart\" ] += 1 # newly hiv if self . agent . hiv . time == time : # type: ignore[attr-defined] if self . active : stats [ \"hiv_new_high_risk\" ] += 1 if self . ever : stats [ \"hiv_new_high_risk_ever\" ] += 1","title":"set_stats()"},{"location":"api/features/high_risk/#titan.features.high_risk.HighRisk.update_agent","text":"Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. Update high risk agents or remove them from high risk pool. An agent becomes high_risk through the incarceration feature Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/high_risk.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. Update high risk agents or remove them from high risk pool. An agent becomes high_risk through the incarceration feature args: model: the instance of TITAN currently being run \"\"\" if not self . active : # released last step, evaluate agent for high risk if self . agent . incar . release_time == model . time - 1 : # type: ignore[attr-defined] self . become_high_risk ( model . pop , model . time ) # incarcerated last step, evaluate agent's partners for high risk elif self . agent . incar . time == model . time - 1 : # type: ignore[attr-defined] # put partners in high risk for partner in self . agent . get_partners ( self . agent . location . params . high_risk . partnership_types ): if ( not partner . high_risk . active # type: ignore[attr-defined] and model . run_random . random () < partner . location . params . high_risk . prob ): partner . high_risk . become_high_risk ( model . pop , model . time ) # type: ignore[attr-defined] elif self . duration > 0 : self . duration -= 1 else : self . active = False self . update_partner_numbers ( model . pop , - 1 * self . agent . location . params . high_risk . partner_scale ) for bond in self . agent . location . params . high_risk . partnership_types : num_ended = 0 while ( len ( self . agent . partners [ bond ]) - num_ended ) > self . agent . target_partners [ bond ]: rel = utils . safe_random_choice ( self . agent . relationships , model . run_random ) if rel is not None : num_ended += 1 rel . duration = 0 # will end on next step","title":"update_agent()"},{"location":"api/features/high_risk/#titan.features.high_risk.HighRisk.update_partner_numbers","text":"Update the agent's mean and target partner numbers by the amount passed. Update partnerability for the population. Parameters: Name Type Description Default pop population.Population the model population required amount int the positive or negatative amount to adjust the mean by required Source code in titan/features/high_risk.py def update_partner_numbers ( self , pop : \"population.Population\" , amount : int ): \"\"\" Update the agent's mean and target partner numbers by the amount passed. Update partnerability for the population. args: pop: the model population amount: the positive or negatative amount to adjust the mean by \"\"\" for bond in self . agent . location . params . high_risk . partnership_types : self . agent . mean_num_partners [ bond ] += amount # could be negative self . agent . target_partners [ bond ] = utils . poisson ( self . agent . mean_num_partners [ bond ], pop . np_random ) pop . update_partnerability ( self . agent )","title":"update_partner_numbers()"},{"location":"api/features/incar/","text":"name : str Name of feature in the params file. Also used to name the attribute in Agent stats : List [ str ] Incar collects the following stats: incar - number of agents with active incar incar_hiv - number of agents with active incar and HIV new_release - number of agents released this timestep new_release_hiv - number of agents releasted this timestep with HIV init_agent ( self , pop , time ) Initialize the agent for this feature during population initialization ( Population.create_agent ). Called on only features that are enabled per the params. Run incarceration assignment on an agent. The duration of incarceration at initialization is different than the ongoing to reflect that agents with longer durations will be more highly represented in that population at any given point in time. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/features/incar.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this feature during population initialization (`Population.create_agent`). Called on only features that are enabled per the params. Run incarceration assignment on an agent. The duration of incarceration at initialization is different than the ongoing to reflect that agents with longer durations will be more highly represented in that population at any given point in time. args: pop: the population this agent is a part of time: the current time step \"\"\" incar_params = ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . incar ) jail_duration = incar_params . duration . init prob_incar = incar_params . init if pop . pop_random . random () < prob_incar : self . active = True bin = 1 current_p_value = jail_duration [ bin ] . prob p = pop . pop_random . random () while p > current_p_value : bin += 1 current_p_value += jail_duration [ bin ] . prob self . time = time self . release_time = time + pop . pop_random . randrange ( jail_duration [ bin ] . min , jail_duration [ bin ] . max ) set_stats ( self , stats , time ) Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled feature in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/features/incar.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . release_time == time : stats [ \"new_release\" ] += 1 if self . agent . hiv . active : # type: ignore[attr-defined] stats [ \"new_release_hiv\" ] += 1 if self . active : stats [ \"incar\" ] += 1 if self . agent . hiv . active : # type: ignore[attr-defined] stats [ \"incar_hiv\" ] += 1 update_agent ( self , model ) Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. Incarcerate an agent or update their incarceration variables Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/incar.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. Incarcerate an agent or update their incarceration variables args: model: the instance of TITAN currently being run \"\"\" hiv_bool = self . agent . hiv . active # type: ignore[attr-defined] if hiv_bool : hiv_multiplier = self . agent . location . params . incar . hiv . multiplier else : hiv_multiplier = 1.0 # agent is incarcerated if self . active : # Release agent if self . release_time == model . time : self . active = False # does agent stay on haart if hiv_bool : if self . agent . haart . active : # type: ignore[attr-defined] if ( model . run_random . random () <= self . agent . location . params . incar . haart . discontinue ): self . agent . haart . active = False # type: ignore[attr-defined] self . agent . haart . adherent = False # type: ignore[attr-defined] # should the agent become incarcerated? elif model . run_random . random () < ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . incar . prob * hiv_multiplier * model . calibration . incarceration ): incar_duration = ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . incar . duration . prob ) bin = utils . get_cumulative_bin ( model . run_random , incar_duration ) self . time = model . time self . release_time = model . time + utils . safe_random_int ( incar_duration [ bin ] . min , incar_duration [ bin ] . max , model . run_random ) self . active = True if hiv_bool : if not self . agent . hiv . dx : # type: ignore[attr-defined] if ( model . run_random . random () < self . agent . location . params . incar . hiv . dx ): self . agent . hiv . diagnose ( model ) # type: ignore[attr-defined] else : # Then tested and HIV, check to enroll in ART if ( model . run_random . random () < self . agent . location . params . incar . haart . prob ): self . agent . haart . adherent = model . run_random . random () < self . agent . location . params . incar . haart . adherence # type: ignore[attr-defined] # Add agent to HAART class set, update agent params self . agent . haart . active = True # type: ignore[attr-defined]","title":"Incarceration"},{"location":"api/features/incar/#titan.features.incar.Incar.name","text":"Name of feature in the params file. Also used to name the attribute in Agent","title":"name"},{"location":"api/features/incar/#titan.features.incar.Incar.stats","text":"Incar collects the following stats: incar - number of agents with active incar incar_hiv - number of agents with active incar and HIV new_release - number of agents released this timestep new_release_hiv - number of agents releasted this timestep with HIV","title":"stats"},{"location":"api/features/incar/#titan.features.incar.Incar.init_agent","text":"Initialize the agent for this feature during population initialization ( Population.create_agent ). Called on only features that are enabled per the params. Run incarceration assignment on an agent. The duration of incarceration at initialization is different than the ongoing to reflect that agents with longer durations will be more highly represented in that population at any given point in time. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/features/incar.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this feature during population initialization (`Population.create_agent`). Called on only features that are enabled per the params. Run incarceration assignment on an agent. The duration of incarceration at initialization is different than the ongoing to reflect that agents with longer durations will be more highly represented in that population at any given point in time. args: pop: the population this agent is a part of time: the current time step \"\"\" incar_params = ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . incar ) jail_duration = incar_params . duration . init prob_incar = incar_params . init if pop . pop_random . random () < prob_incar : self . active = True bin = 1 current_p_value = jail_duration [ bin ] . prob p = pop . pop_random . random () while p > current_p_value : bin += 1 current_p_value += jail_duration [ bin ] . prob self . time = time self . release_time = time + pop . pop_random . randrange ( jail_duration [ bin ] . min , jail_duration [ bin ] . max )","title":"init_agent()"},{"location":"api/features/incar/#titan.features.incar.Incar.set_stats","text":"Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled feature in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/features/incar.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . release_time == time : stats [ \"new_release\" ] += 1 if self . agent . hiv . active : # type: ignore[attr-defined] stats [ \"new_release_hiv\" ] += 1 if self . active : stats [ \"incar\" ] += 1 if self . agent . hiv . active : # type: ignore[attr-defined] stats [ \"incar_hiv\" ] += 1","title":"set_stats()"},{"location":"api/features/incar/#titan.features.incar.Incar.update_agent","text":"Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. Incarcerate an agent or update their incarceration variables Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/incar.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. Incarcerate an agent or update their incarceration variables args: model: the instance of TITAN currently being run \"\"\" hiv_bool = self . agent . hiv . active # type: ignore[attr-defined] if hiv_bool : hiv_multiplier = self . agent . location . params . incar . hiv . multiplier else : hiv_multiplier = 1.0 # agent is incarcerated if self . active : # Release agent if self . release_time == model . time : self . active = False # does agent stay on haart if hiv_bool : if self . agent . haart . active : # type: ignore[attr-defined] if ( model . run_random . random () <= self . agent . location . params . incar . haart . discontinue ): self . agent . haart . active = False # type: ignore[attr-defined] self . agent . haart . adherent = False # type: ignore[attr-defined] # should the agent become incarcerated? elif model . run_random . random () < ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . incar . prob * hiv_multiplier * model . calibration . incarceration ): incar_duration = ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . incar . duration . prob ) bin = utils . get_cumulative_bin ( model . run_random , incar_duration ) self . time = model . time self . release_time = model . time + utils . safe_random_int ( incar_duration [ bin ] . min , incar_duration [ bin ] . max , model . run_random ) self . active = True if hiv_bool : if not self . agent . hiv . dx : # type: ignore[attr-defined] if ( model . run_random . random () < self . agent . location . params . incar . hiv . dx ): self . agent . hiv . diagnose ( model ) # type: ignore[attr-defined] else : # Then tested and HIV, check to enroll in ART if ( model . run_random . random () < self . agent . location . params . incar . haart . prob ): self . agent . haart . adherent = model . run_random . random () < self . agent . location . params . incar . haart . adherence # type: ignore[attr-defined] # Add agent to HAART class set, update agent params self . agent . haart . active = True # type: ignore[attr-defined]","title":"update_agent()"},{"location":"api/features/partner_tracing/","text":"name : str Name of feature in the params file. Also used to name the attribute in Agent update_agent ( self , model ) Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. If the agent is was diagnosed last time step, trace their partners. If the agent is traced but not diagnosed, stochastically diagnose. If the agents tracking has expired, mark them as inactive. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/partner_tracing.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. If the agent is was diagnosed last time step, trace their partners. If the agent is traced but not diagnosed, stochastically diagnose. If the agents tracking has expired, mark them as inactive. args: model: the instance of TITAN currently being run \"\"\" params = self . agent . location . params . partner_tracing if model . time < params . start_time or model . time > params . stop_time : return agent_exposure = getattr ( self . agent , params . exposure ) if agent_exposure . active : # was this agent diagnosed with the target exposure last time step if agent_exposure . dx and agent_exposure . dx_time == model . time - 1 : for ptnr in self . agent . get_partners ( params . bond_type ): partner_exposure = getattr ( ptnr , params . exposure ) if ( not partner_exposure . dx and model . run_random . random () < params . prob ): ptnr . partner_tracing . active = True # type: ignore[attr-defined] ptnr . partner_tracing . time = model . time # type: ignore[attr-defined] # second chance at diagnosis if traced if ( self . active and self . time < model . time and not agent_exposure . dx and model . run_random . random () < params . dx_prob ): agent_exposure . diagnose ( model ) # stop tracing of this agent if time if self . active and model . time >= self . time + params . trace_duration : self . active = False self . time = None","title":"Partner Tracing"},{"location":"api/features/partner_tracing/#titan.features.partner_tracing.PartnerTracing.name","text":"Name of feature in the params file. Also used to name the attribute in Agent","title":"name"},{"location":"api/features/partner_tracing/#titan.features.partner_tracing.PartnerTracing.update_agent","text":"Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. If the agent is was diagnosed last time step, trace their partners. If the agent is traced but not diagnosed, stochastically diagnose. If the agents tracking has expired, mark them as inactive. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/partner_tracing.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. If the agent is was diagnosed last time step, trace their partners. If the agent is traced but not diagnosed, stochastically diagnose. If the agents tracking has expired, mark them as inactive. args: model: the instance of TITAN currently being run \"\"\" params = self . agent . location . params . partner_tracing if model . time < params . start_time or model . time > params . stop_time : return agent_exposure = getattr ( self . agent , params . exposure ) if agent_exposure . active : # was this agent diagnosed with the target exposure last time step if agent_exposure . dx and agent_exposure . dx_time == model . time - 1 : for ptnr in self . agent . get_partners ( params . bond_type ): partner_exposure = getattr ( ptnr , params . exposure ) if ( not partner_exposure . dx and model . run_random . random () < params . prob ): ptnr . partner_tracing . active = True # type: ignore[attr-defined] ptnr . partner_tracing . time = model . time # type: ignore[attr-defined] # second chance at diagnosis if traced if ( self . active and self . time < model . time and not agent_exposure . dx and model . run_random . random () < params . dx_prob ): agent_exposure . diagnose ( model ) # stop tracing of this agent if time if self . active and model . time >= self . time + params . trace_duration : self . active = False self . time = None","title":"update_agent()"},{"location":"api/features/prep/","text":"name : str Name of feature in the params file. Also used to name the attribute in Agent stats : List [ str ] PrEP collects the following stats: prep - number of agents with active PrEP prep_new - number of agents who became active PrEP this time step prep_injectable - number of agents on injectable PrEP prep_oral - number of agents on oral PrEP add_agent ( agent ) classmethod Add an agent to the class (not instance). Add agent to the PrEP counts by race, and add the agent to the set of new agents. Parameters: Name Type Description Default agent agent.Agent the agent to add to the class attributes required Source code in titan/features/prep.py @classmethod def add_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Add an agent to the class (not instance). Add agent to the PrEP counts by race, and add the agent to the set of new agents. args: agent: the agent to add to the class attributes \"\"\" # set up if this is the first time being called cls . counts [ agent . race ] += 1 cdc_eligible ( self ) Determine agent eligibility for PrEP under CDC criteria Returns: Type Description bool cdc eligibility Source code in titan/features/prep.py def cdc_eligible ( self ) -> bool : \"\"\" Determine agent eligibility for PrEP under CDC criteria returns: cdc eligibility \"\"\" if self . agent . is_msm (): return True ongoing_duration = self . agent . location . params . partnership . ongoing_duration for rel in self . agent . relationships : partner = rel . get_partner ( self . agent ) if rel . duration > ongoing_duration and partner . hiv . dx : # type: ignore[attr-defined] return True if partner . drug_type == \"Inj\" or partner . is_msm (): return True return False discontinue ( self ) Discontinue PrEP usage Source code in titan/features/prep.py def discontinue ( self ): \"\"\" Discontinue PrEP usage \"\"\" self . active = False self . type = \"\" self . time = None self . last_dose_time = None self . remove_agent ( self . agent ) eligible ( self , time ) Determine if an agent is eligible for PrEP Returns: Type Description bool whether the agent is eligible Source code in titan/features/prep.py def eligible ( self , time ) -> bool : \"\"\" Determine if an agent is eligible for PrEP returns: whether the agent is eligible \"\"\" params = self . agent . location . params if self . agent . hiv . active or time < params . prep . start_time : # type: ignore[attr-defined] return False target_model = params . prep . target_model gender = params . classes . sex_types [ self . agent . sex_type ] . gender if ( self . active or self . agent . vaccine . active # type: ignore[attr-defined] or params . features . random_trial ): return False all_eligible_models = { \"Allcomers\" , \"Racial\" } if all_eligible_models . intersection ( target_model ): return True if \"cdc_women\" in target_model : if gender == \"F\" : if self . cdc_eligible (): return True if \"cdc_msm\" in target_model : if gender == \"M\" and self . cdc_eligible (): return True if \"pwid_sex\" in target_model : if self . agent . drug_type == \"Inj\" and self . cdc_eligible (): return True if \"pwid\" in target_model : if self . agent . drug_type == \"Inj\" : return True if \"ssp_sex\" in target_model : if self . agent . syringe_services . active and self . cdc_eligible (): # type: ignore[attr-defined] return True if \"ssp\" in target_model : if self . agent . syringe_services . active : # type: ignore[attr-defined] return True return False enroll ( self , rand_gen , time ) Enroll an agent in PrEP Parameters: Name Type Description Default rand_gen random number generator required Source code in titan/features/prep.py def enroll ( self , rand_gen , time ): \"\"\" Enroll an agent in PrEP args: rand_gen: random number generator \"\"\" params = self . agent . location . params self . active = True self . time = time self . last_dose_time = time self . adherent = ( rand_gen . random () < params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . prep . adherence ) if \"Inj\" in params . prep . type and \"Oral\" in params . prep . type : if rand_gen . random () < params . prep . lai . prob : self . type = \"Inj\" else : self . type = \"Oral\" else : self . type = params . prep . type [ 0 ] self . add_agent ( self . agent ) get_acquisition_risk_multiplier ( self , time , interaction_type ) Get a multiplier for how prep reduces risk of HIV acquisition. By default, returns 1.0 Parameters: Name Type Description Default time int the current model time step required interaction_type str The type of interaction where the agent could acquire HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) required Source code in titan/features/prep.py def get_acquisition_risk_multiplier ( self , time : int , interaction_type : str ): \"\"\" Get a multiplier for how prep reduces risk of HIV acquisition. By default, returns 1.0 args: time: the current model time step interaction_type: The type of interaction where the agent could acquire HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) \"\"\" if self . active and self . last_dose_time is not None : params = self . agent . location . params if self . type == \"Oral\" : adherence = \"adherent\" if self . adherent else \"non_adherent\" return 1.0 - params . prep . efficacy [ adherence ] elif self . type == \"Inj\" : annualized_last_dose_time = ( time - self . last_dose_time ) / params . model . time . steps_per_year annualized_half_life = params . prep . half_life / 365 load = params . prep . peak_load * ( ( 0.5 ) ** ( annualized_last_dose_time / annualized_half_life ) ) return np . exp ( - 5.528636721 * load ) return 1.0 init_agent ( self , pop , time ) Initialize the agent for this feature during population initialization ( Population.create_agent ). Called on only features that are enabled per the params. If an agent does not have HIV, is PrEP eligible, and time is at least the prep start time, they are randomly asigned to enroll in PrEP. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/features/prep.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this feature during population initialization (`Population.create_agent`). Called on only features that are enabled per the params. If an agent does not have HIV, is PrEP eligible, and time is at least the prep start time, they are randomly asigned to enroll in PrEP. args: pop: the population this agent is a part of time: the current time step \"\"\" params = self . agent . location . params if self . eligible ( time ): if \"Racial\" in params . prep . target_model : if ( pop . pop_random . random () < params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . prep . init ): self . enroll ( pop . pop_random , time ) elif pop . pop_random . random () < params . prep . init : self . enroll ( pop . pop_random , time ) init_class ( params ) classmethod Initialize the counts dictionary for the races in the model. Parameters: Name Type Description Default params ObjMap the population params required Source code in titan/features/prep.py @classmethod def init_class ( cls , params : \"ObjMap\" ): \"\"\" Initialize the counts dictionary for the races in the model. args: params: the population params \"\"\" cls . counts = { race : 0 for race in params . classes . races } initiate ( self , model , force = False ) Place agents onto PrEP treatment. PrEP treatment assumes that the agent knows their HIV status is negative. Parameters: Name Type Description Default model model.TITAN instance of TITAN being run required force bool whether to force the agent to enroll instead of using the appropriate algorithm per the prep params False Source code in titan/features/prep.py def initiate ( self , model : \"model.TITAN\" , force : bool = False ): \"\"\" Place agents onto PrEP treatment. PrEP treatment assumes that the agent knows their HIV status is negative. args: model : instance of TITAN being run force : whether to force the agent to enroll instead of using the appropriate algorithm per the prep params \"\"\" # Prep only valid for agents not on prep and are HIV negative if self . active or self . agent . hiv . active : # type: ignore[attr-defined] return params = self . agent . location . params if force : self . enroll ( model . run_random , model . time ) elif params . prep . cap_as_prob : if \"Racial\" in params . prep . target_model : if ( model . run_random . random () <= params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . prep . cap ): self . enroll ( model . run_random , model . time ) else : if model . run_random . random () <= params . prep . cap : self . enroll ( model . run_random , model . time ) else : if \"Racial\" in params . prep . target_model : num_prep_agents = self . counts [ self . agent . race ] all_hiv_agents = exposures . HIV . agents all_race = { a for a in model . pop . all_agents if a . race == self . agent . race } num_hiv_agents = len ( all_hiv_agents & all_race ) target_prep = ( len ( all_race ) - num_hiv_agents ) * params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . prep . cap else : num_prep_agents = sum ( self . counts . values ()) target_prep = int ( ( model . pop . all_agents . num_members () - len ( exposures . HIV . agents )) * params . prep . cap ) if num_prep_agents < target_prep : self . enroll ( model . run_random , model . time ) progress ( self , model , force = False ) Update agent's PrEP status and discontinue stochastically or if force is True Parameters: Name Type Description Default model model.TITAN instance of the TITAN being run required force bool whether to force discontinuation of PrEP False Source code in titan/features/prep.py def progress ( self , model : \"model.TITAN\" , force : bool = False ): \"\"\" Update agent's PrEP status and discontinue stochastically or if `force` is True args: model: instance of the TITAN being run force: whether to force discontinuation of PrEP \"\"\" if force : self . discontinue () # TO_REVIEW should this just remove the agent from counts, or discontinue? does it depend on type? return if self . type == \"Oral\" : if ( model . run_random . random () < self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . prep . discontinue ): self . discontinue () else : self . last_dose_time = model . time # TO_REVIEW should inj prep have a way to continue at the year mark (besides maybe getting prep again through the normal channels of enrollment)? if ( self . type == \"Inj\" and self . last_dose_time + self . agent . location . params . model . time . steps_per_year == model . time ): self . discontinue () remove_agent ( agent ) classmethod Remove an agent from the class (not instance). Decrement the prep counts by race. Parameters: Name Type Description Default agent the agent to remove from the class attributes required Source code in titan/features/prep.py @classmethod def remove_agent ( cls , agent ): \"\"\" Remove an agent from the class (not instance). Decrement the prep counts by race. args: agent: the agent to remove from the class attributes \"\"\" cls . counts [ agent . race ] -= 1 set_stats ( self , stats , time ) Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled feature in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/features/prep.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . active : stats [ \"prep\" ] += 1 if self . time == time : stats [ \"prep_new\" ] += 1 if self . type == \"Inj\" : stats [ \"prep_injectable\" ] += 1 elif self . type == \"Oral\" : stats [ \"prep_oral\" ] += 1 update_agent ( self , model ) Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. If the agent is not hiv and time is at least the prep start time, if the agent is already on PrEP update their PrEP attributes, if the agent isn't on PrEP and is eleigible, initiate PrEP. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/prep.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. If the agent is not hiv and time is at least the prep start time, if the agent is already on PrEP update their PrEP attributes, if the agent isn't on PrEP and is eleigible, initiate PrEP. args: model: the instance of TITAN currently being run \"\"\" if ( not self . agent . hiv . active # type: ignore[attr-defined] and model . time >= self . agent . location . params . prep . start_time ): if self . active : self . progress ( model ) elif self . eligible ( model . time ): self . initiate ( model )","title":"PrEP"},{"location":"api/features/prep/#titan.features.prep.Prep.name","text":"Name of feature in the params file. Also used to name the attribute in Agent","title":"name"},{"location":"api/features/prep/#titan.features.prep.Prep.stats","text":"PrEP collects the following stats: prep - number of agents with active PrEP prep_new - number of agents who became active PrEP this time step prep_injectable - number of agents on injectable PrEP prep_oral - number of agents on oral PrEP","title":"stats"},{"location":"api/features/prep/#titan.features.prep.Prep.add_agent","text":"Add an agent to the class (not instance). Add agent to the PrEP counts by race, and add the agent to the set of new agents. Parameters: Name Type Description Default agent agent.Agent the agent to add to the class attributes required Source code in titan/features/prep.py @classmethod def add_agent ( cls , agent : \"agent.Agent\" ): \"\"\" Add an agent to the class (not instance). Add agent to the PrEP counts by race, and add the agent to the set of new agents. args: agent: the agent to add to the class attributes \"\"\" # set up if this is the first time being called cls . counts [ agent . race ] += 1","title":"add_agent()"},{"location":"api/features/prep/#titan.features.prep.Prep.cdc_eligible","text":"Determine agent eligibility for PrEP under CDC criteria Returns: Type Description bool cdc eligibility Source code in titan/features/prep.py def cdc_eligible ( self ) -> bool : \"\"\" Determine agent eligibility for PrEP under CDC criteria returns: cdc eligibility \"\"\" if self . agent . is_msm (): return True ongoing_duration = self . agent . location . params . partnership . ongoing_duration for rel in self . agent . relationships : partner = rel . get_partner ( self . agent ) if rel . duration > ongoing_duration and partner . hiv . dx : # type: ignore[attr-defined] return True if partner . drug_type == \"Inj\" or partner . is_msm (): return True return False","title":"cdc_eligible()"},{"location":"api/features/prep/#titan.features.prep.Prep.discontinue","text":"Discontinue PrEP usage Source code in titan/features/prep.py def discontinue ( self ): \"\"\" Discontinue PrEP usage \"\"\" self . active = False self . type = \"\" self . time = None self . last_dose_time = None self . remove_agent ( self . agent )","title":"discontinue()"},{"location":"api/features/prep/#titan.features.prep.Prep.eligible","text":"Determine if an agent is eligible for PrEP Returns: Type Description bool whether the agent is eligible Source code in titan/features/prep.py def eligible ( self , time ) -> bool : \"\"\" Determine if an agent is eligible for PrEP returns: whether the agent is eligible \"\"\" params = self . agent . location . params if self . agent . hiv . active or time < params . prep . start_time : # type: ignore[attr-defined] return False target_model = params . prep . target_model gender = params . classes . sex_types [ self . agent . sex_type ] . gender if ( self . active or self . agent . vaccine . active # type: ignore[attr-defined] or params . features . random_trial ): return False all_eligible_models = { \"Allcomers\" , \"Racial\" } if all_eligible_models . intersection ( target_model ): return True if \"cdc_women\" in target_model : if gender == \"F\" : if self . cdc_eligible (): return True if \"cdc_msm\" in target_model : if gender == \"M\" and self . cdc_eligible (): return True if \"pwid_sex\" in target_model : if self . agent . drug_type == \"Inj\" and self . cdc_eligible (): return True if \"pwid\" in target_model : if self . agent . drug_type == \"Inj\" : return True if \"ssp_sex\" in target_model : if self . agent . syringe_services . active and self . cdc_eligible (): # type: ignore[attr-defined] return True if \"ssp\" in target_model : if self . agent . syringe_services . active : # type: ignore[attr-defined] return True return False","title":"eligible()"},{"location":"api/features/prep/#titan.features.prep.Prep.enroll","text":"Enroll an agent in PrEP Parameters: Name Type Description Default rand_gen random number generator required Source code in titan/features/prep.py def enroll ( self , rand_gen , time ): \"\"\" Enroll an agent in PrEP args: rand_gen: random number generator \"\"\" params = self . agent . location . params self . active = True self . time = time self . last_dose_time = time self . adherent = ( rand_gen . random () < params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . prep . adherence ) if \"Inj\" in params . prep . type and \"Oral\" in params . prep . type : if rand_gen . random () < params . prep . lai . prob : self . type = \"Inj\" else : self . type = \"Oral\" else : self . type = params . prep . type [ 0 ] self . add_agent ( self . agent )","title":"enroll()"},{"location":"api/features/prep/#titan.features.prep.Prep.get_acquisition_risk_multiplier","text":"Get a multiplier for how prep reduces risk of HIV acquisition. By default, returns 1.0 Parameters: Name Type Description Default time int the current model time step required interaction_type str The type of interaction where the agent could acquire HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) required Source code in titan/features/prep.py def get_acquisition_risk_multiplier ( self , time : int , interaction_type : str ): \"\"\" Get a multiplier for how prep reduces risk of HIV acquisition. By default, returns 1.0 args: time: the current model time step interaction_type: The type of interaction where the agent could acquire HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) \"\"\" if self . active and self . last_dose_time is not None : params = self . agent . location . params if self . type == \"Oral\" : adherence = \"adherent\" if self . adherent else \"non_adherent\" return 1.0 - params . prep . efficacy [ adherence ] elif self . type == \"Inj\" : annualized_last_dose_time = ( time - self . last_dose_time ) / params . model . time . steps_per_year annualized_half_life = params . prep . half_life / 365 load = params . prep . peak_load * ( ( 0.5 ) ** ( annualized_last_dose_time / annualized_half_life ) ) return np . exp ( - 5.528636721 * load ) return 1.0","title":"get_acquisition_risk_multiplier()"},{"location":"api/features/prep/#titan.features.prep.Prep.init_agent","text":"Initialize the agent for this feature during population initialization ( Population.create_agent ). Called on only features that are enabled per the params. If an agent does not have HIV, is PrEP eligible, and time is at least the prep start time, they are randomly asigned to enroll in PrEP. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/features/prep.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this feature during population initialization (`Population.create_agent`). Called on only features that are enabled per the params. If an agent does not have HIV, is PrEP eligible, and time is at least the prep start time, they are randomly asigned to enroll in PrEP. args: pop: the population this agent is a part of time: the current time step \"\"\" params = self . agent . location . params if self . eligible ( time ): if \"Racial\" in params . prep . target_model : if ( pop . pop_random . random () < params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . prep . init ): self . enroll ( pop . pop_random , time ) elif pop . pop_random . random () < params . prep . init : self . enroll ( pop . pop_random , time )","title":"init_agent()"},{"location":"api/features/prep/#titan.features.prep.Prep.init_class","text":"Initialize the counts dictionary for the races in the model. Parameters: Name Type Description Default params ObjMap the population params required Source code in titan/features/prep.py @classmethod def init_class ( cls , params : \"ObjMap\" ): \"\"\" Initialize the counts dictionary for the races in the model. args: params: the population params \"\"\" cls . counts = { race : 0 for race in params . classes . races }","title":"init_class()"},{"location":"api/features/prep/#titan.features.prep.Prep.initiate","text":"Place agents onto PrEP treatment. PrEP treatment assumes that the agent knows their HIV status is negative. Parameters: Name Type Description Default model model.TITAN instance of TITAN being run required force bool whether to force the agent to enroll instead of using the appropriate algorithm per the prep params False Source code in titan/features/prep.py def initiate ( self , model : \"model.TITAN\" , force : bool = False ): \"\"\" Place agents onto PrEP treatment. PrEP treatment assumes that the agent knows their HIV status is negative. args: model : instance of TITAN being run force : whether to force the agent to enroll instead of using the appropriate algorithm per the prep params \"\"\" # Prep only valid for agents not on prep and are HIV negative if self . active or self . agent . hiv . active : # type: ignore[attr-defined] return params = self . agent . location . params if force : self . enroll ( model . run_random , model . time ) elif params . prep . cap_as_prob : if \"Racial\" in params . prep . target_model : if ( model . run_random . random () <= params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . prep . cap ): self . enroll ( model . run_random , model . time ) else : if model . run_random . random () <= params . prep . cap : self . enroll ( model . run_random , model . time ) else : if \"Racial\" in params . prep . target_model : num_prep_agents = self . counts [ self . agent . race ] all_hiv_agents = exposures . HIV . agents all_race = { a for a in model . pop . all_agents if a . race == self . agent . race } num_hiv_agents = len ( all_hiv_agents & all_race ) target_prep = ( len ( all_race ) - num_hiv_agents ) * params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . prep . cap else : num_prep_agents = sum ( self . counts . values ()) target_prep = int ( ( model . pop . all_agents . num_members () - len ( exposures . HIV . agents )) * params . prep . cap ) if num_prep_agents < target_prep : self . enroll ( model . run_random , model . time )","title":"initiate()"},{"location":"api/features/prep/#titan.features.prep.Prep.progress","text":"Update agent's PrEP status and discontinue stochastically or if force is True Parameters: Name Type Description Default model model.TITAN instance of the TITAN being run required force bool whether to force discontinuation of PrEP False Source code in titan/features/prep.py def progress ( self , model : \"model.TITAN\" , force : bool = False ): \"\"\" Update agent's PrEP status and discontinue stochastically or if `force` is True args: model: instance of the TITAN being run force: whether to force discontinuation of PrEP \"\"\" if force : self . discontinue () # TO_REVIEW should this just remove the agent from counts, or discontinue? does it depend on type? return if self . type == \"Oral\" : if ( model . run_random . random () < self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . prep . discontinue ): self . discontinue () else : self . last_dose_time = model . time # TO_REVIEW should inj prep have a way to continue at the year mark (besides maybe getting prep again through the normal channels of enrollment)? if ( self . type == \"Inj\" and self . last_dose_time + self . agent . location . params . model . time . steps_per_year == model . time ): self . discontinue ()","title":"progress()"},{"location":"api/features/prep/#titan.features.prep.Prep.remove_agent","text":"Remove an agent from the class (not instance). Decrement the prep counts by race. Parameters: Name Type Description Default agent the agent to remove from the class attributes required Source code in titan/features/prep.py @classmethod def remove_agent ( cls , agent ): \"\"\" Remove an agent from the class (not instance). Decrement the prep counts by race. args: agent: the agent to remove from the class attributes \"\"\" cls . counts [ agent . race ] -= 1","title":"remove_agent()"},{"location":"api/features/prep/#titan.features.prep.Prep.set_stats","text":"Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled feature in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/features/prep.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . active : stats [ \"prep\" ] += 1 if self . time == time : stats [ \"prep_new\" ] += 1 if self . type == \"Inj\" : stats [ \"prep_injectable\" ] += 1 elif self . type == \"Oral\" : stats [ \"prep_oral\" ] += 1","title":"set_stats()"},{"location":"api/features/prep/#titan.features.prep.Prep.update_agent","text":"Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. If the agent is not hiv and time is at least the prep start time, if the agent is already on PrEP update their PrEP attributes, if the agent isn't on PrEP and is eleigible, initiate PrEP. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/prep.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. If the agent is not hiv and time is at least the prep start time, if the agent is already on PrEP update their PrEP attributes, if the agent isn't on PrEP and is eleigible, initiate PrEP. args: model: the instance of TITAN currently being run \"\"\" if ( not self . agent . hiv . active # type: ignore[attr-defined] and model . time >= self . agent . location . params . prep . start_time ): if self . active : self . progress ( model ) elif self . eligible ( model . time ): self . initiate ( model )","title":"update_agent()"},{"location":"api/features/random_trial/","text":"name : str Name of feature in the params file. Also used to name the attribute in Agent stats : List [ str ] Random Trial collects the following stats: random_trial - number of agents with active random_trial random_trial_treated - number of active agents treated random_trial_treated_hiv - number of HIV+ agents treated random_trial_suitable - number of active agents suitable set_stats ( self , stats , time ) Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled feature in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/features/random_trial.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . active : stats [ \"random_trial\" ] += 1 if self . treated : stats [ \"random_trial_treated\" ] += 1 if self . agent . hiv . active : # type: ignore[attr-defined] stats [ \"random_trial_treated_hiv\" ] += 1 if self . suitable : stats [ \"random_trial_suitable\" ] += 1 update_pop ( model ) classmethod Update the feature for the entire population (class method). Initialize a random trial in the population if time is the random trial start time. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/random_trial.py @classmethod def update_pop ( cls , model : \"model.TITAN\" ): \"\"\" Update the feature for the entire population (class method). Initialize a random trial in the population if time is the random trial start time. args: model: the instance of TITAN currently being run \"\"\" rt_params = model . params . random_trial if not model . time == rt_params . start_time : return assert ( model . params . model . network . enable ), \"Network must be enabled for random trial\" logging . info ( f \"Starting random trial ( { rt_params . choice } )\" ) components = model . pop . connected_components () # set up helper methods based on params if rt_params . treatment == \"prep\" : assert ( model . params . features . prep ), \"Prep feature must be enabled to use the prep random trial treatment\" treat = treat_prep suitable = suitable_prep elif rt_params . treatment == \"knowledge\" : assert ( model . params . exposures . knowledge ), \"Knowledge exposure must be enabled to use the knowledge random trial treatment\" treat = treat_knowledge suitable = suitable_knowledge total_nodes = 0 logging . info ( f \"Number of components { len ([ 1 for comp in components if comp . number_of_nodes ()]) } \" , ) for comp in components : total_nodes += comp . number_of_nodes () if model . run_random . random () < rt_params . prob : # Component selected as treatment pod! for agent in comp . nodes : agent . random_trial . active = True # treat all agents if rt_params . choice == \"all\" : for agent in comp . nodes (): if suitable ( agent , model ): treat ( agent , model ) agent . random_trial . suitable = True agent . random_trial . treated = True # chose an agent central to the component elif rt_params . choice == \"eigenvector\" : centrality = nx . algorithms . centrality . eigenvector_centrality ( comp ) assert len ( centrality ) >= 1 , \"Empty centrality\" ordered_centrality = sorted ( centrality , key = centrality . get ) # find the most central suitable agent, or if none, use most central intervention_agent = ordered_centrality [ 0 ] for agent in ordered_centrality : if suitable ( agent , model ): intervention_agent = agent intervention_agent . random_trial . suitable = True break intervention_agent . random_trial . treated = True treat ( intervention_agent , model ) # chose an agent that is a bridge in the network elif rt_params . choice == \"bridge\" : # list all edges that are bridges all_bridges = list ( nx . bridges ( comp )) suitable_agents = [ agent for agents in all_bridges for agent in agents if suitable ( agent , model ) ] # all suitable agents in bridges chosen_agent = utils . safe_random_choice ( suitable_agents , model . run_random ) # select change agent if chosen_agent is not None : chosen_agent . random_trial . suitable = True # type: ignore[attr-defined] else : # if no suitable agents, mark a non-suitable agent chosen_agent = utils . safe_random_choice ( list ( comp . nodes ), model . run_random ) chosen_agent . random_trial . treated = True # type: ignore[attr-defined] treat ( chosen_agent , model ) # chose an agent from the component at random elif rt_params . choice == \"random\" : suitable_agents = [ agent for agent in comp . nodes if suitable ( agent , model ) ] # if there are agents who meet eligibility criteria, # select one randomly chosen_agent = utils . safe_random_choice ( suitable_agents , model . run_random ) if chosen_agent is not None : chosen_agent . random_trial . suitable = True else : # if no suitable agents, mark a non-suitable agent chosen_agent = utils . safe_random_choice ( list ( comp . nodes ), model . run_random ) chosen_agent . random_trial . treated = True # type: ignore[attr-defined] treat ( chosen_agent , model ) logging . info ( f \"Total agents in trial: { total_nodes } \" )","title":"Random Trial"},{"location":"api/features/random_trial/#titan.features.random_trial.RandomTrial.name","text":"Name of feature in the params file. Also used to name the attribute in Agent","title":"name"},{"location":"api/features/random_trial/#titan.features.random_trial.RandomTrial.stats","text":"Random Trial collects the following stats: random_trial - number of agents with active random_trial random_trial_treated - number of active agents treated random_trial_treated_hiv - number of HIV+ agents treated random_trial_suitable - number of active agents suitable","title":"stats"},{"location":"api/features/random_trial/#titan.features.random_trial.RandomTrial.set_stats","text":"Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled feature in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/features/random_trial.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . active : stats [ \"random_trial\" ] += 1 if self . treated : stats [ \"random_trial_treated\" ] += 1 if self . agent . hiv . active : # type: ignore[attr-defined] stats [ \"random_trial_treated_hiv\" ] += 1 if self . suitable : stats [ \"random_trial_suitable\" ] += 1","title":"set_stats()"},{"location":"api/features/random_trial/#titan.features.random_trial.RandomTrial.update_pop","text":"Update the feature for the entire population (class method). Initialize a random trial in the population if time is the random trial start time. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/random_trial.py @classmethod def update_pop ( cls , model : \"model.TITAN\" ): \"\"\" Update the feature for the entire population (class method). Initialize a random trial in the population if time is the random trial start time. args: model: the instance of TITAN currently being run \"\"\" rt_params = model . params . random_trial if not model . time == rt_params . start_time : return assert ( model . params . model . network . enable ), \"Network must be enabled for random trial\" logging . info ( f \"Starting random trial ( { rt_params . choice } )\" ) components = model . pop . connected_components () # set up helper methods based on params if rt_params . treatment == \"prep\" : assert ( model . params . features . prep ), \"Prep feature must be enabled to use the prep random trial treatment\" treat = treat_prep suitable = suitable_prep elif rt_params . treatment == \"knowledge\" : assert ( model . params . exposures . knowledge ), \"Knowledge exposure must be enabled to use the knowledge random trial treatment\" treat = treat_knowledge suitable = suitable_knowledge total_nodes = 0 logging . info ( f \"Number of components { len ([ 1 for comp in components if comp . number_of_nodes ()]) } \" , ) for comp in components : total_nodes += comp . number_of_nodes () if model . run_random . random () < rt_params . prob : # Component selected as treatment pod! for agent in comp . nodes : agent . random_trial . active = True # treat all agents if rt_params . choice == \"all\" : for agent in comp . nodes (): if suitable ( agent , model ): treat ( agent , model ) agent . random_trial . suitable = True agent . random_trial . treated = True # chose an agent central to the component elif rt_params . choice == \"eigenvector\" : centrality = nx . algorithms . centrality . eigenvector_centrality ( comp ) assert len ( centrality ) >= 1 , \"Empty centrality\" ordered_centrality = sorted ( centrality , key = centrality . get ) # find the most central suitable agent, or if none, use most central intervention_agent = ordered_centrality [ 0 ] for agent in ordered_centrality : if suitable ( agent , model ): intervention_agent = agent intervention_agent . random_trial . suitable = True break intervention_agent . random_trial . treated = True treat ( intervention_agent , model ) # chose an agent that is a bridge in the network elif rt_params . choice == \"bridge\" : # list all edges that are bridges all_bridges = list ( nx . bridges ( comp )) suitable_agents = [ agent for agents in all_bridges for agent in agents if suitable ( agent , model ) ] # all suitable agents in bridges chosen_agent = utils . safe_random_choice ( suitable_agents , model . run_random ) # select change agent if chosen_agent is not None : chosen_agent . random_trial . suitable = True # type: ignore[attr-defined] else : # if no suitable agents, mark a non-suitable agent chosen_agent = utils . safe_random_choice ( list ( comp . nodes ), model . run_random ) chosen_agent . random_trial . treated = True # type: ignore[attr-defined] treat ( chosen_agent , model ) # chose an agent from the component at random elif rt_params . choice == \"random\" : suitable_agents = [ agent for agent in comp . nodes if suitable ( agent , model ) ] # if there are agents who meet eligibility criteria, # select one randomly chosen_agent = utils . safe_random_choice ( suitable_agents , model . run_random ) if chosen_agent is not None : chosen_agent . random_trial . suitable = True else : # if no suitable agents, mark a non-suitable agent chosen_agent = utils . safe_random_choice ( list ( comp . nodes ), model . run_random ) chosen_agent . random_trial . treated = True # type: ignore[attr-defined] treat ( chosen_agent , model ) logging . info ( f \"Total agents in trial: { total_nodes } \" )","title":"update_pop()"},{"location":"api/features/syringe_services/","text":"name : str Name of feature in the params file. Also used to name the attribute in Agent init_class ( params ) classmethod Initialize enrolled risk to 0. Parameters: Name Type Description Default params the population params required Source code in titan/features/syringe_services.py @classmethod def init_class ( cls , params ): \"\"\" Initialize enrolled risk to 0. args: params: the population params \"\"\" cls . enrolled_risk = 0.0 update_pop ( model ) classmethod Update the feature for the entire population (class method). This is useful for initializing class level trackers that need to be reset each time step, or if enabling a feature for agents needs to be evaluated within the context of the full population (limited slots, or similar). Enroll PWID agents in syringe services according to the syring_services timeline and params. Parameters: Name Type Description Default model hiv_model.TITAN the instance of TITAN currently being run required Source code in titan/features/syringe_services.py @classmethod def update_pop ( cls , model : \"hiv_model.TITAN\" ): \"\"\" Update the feature for the entire population (class method). This is useful for initializing class level trackers that need to be reset each time step, or if enabling a feature for agents needs to be evaluated within the context of the full population (limited slots, or similar). Enroll PWID agents in syringe services according to the syring_services timeline and params. args: model: the instance of TITAN currently being run \"\"\" logging . info (( \" \\n\\n !!!!Engaging syringe services program\" )) ssp_num_slots = 0 ssp_agents = { agent for agent in model . pop . pwid_agents if agent . syringe_services . active # type: ignore[attr-defined] } for item in model . params . syringe_services . timeline . values (): if item . start_time <= model . time < item . stop_time : cls . enrolled_risk = item . risk # linearly interpolate slots between start and stop ssp_num_slots = ( item . num_slots_stop - item . num_slots_start ) / ( item . stop_time - item . start_time ) * ( model . time - item . start_time ) + item . num_slots_start # If cap indicates all or no agents, do not change # otherwise, find true number of slots through distribution num_pwid_agents = model . pop . pwid_agents . num_members () if 0 < ssp_num_slots < num_pwid_agents : ssp_num_slots = round ( model . run_random . betavariate ( ssp_num_slots , num_pwid_agents - ssp_num_slots , ) * num_pwid_agents ) break target_set = utils . safe_shuffle ( ( model . pop . pwid_agents . members - ssp_agents ), model . run_random ) # unenroll agents if above cap for agent in ssp_agents . copy (): if len ( ssp_agents ) > ssp_num_slots : agent . syringe_services . active = False # type: ignore[attr-defined] ssp_agents . remove ( agent ) else : break # enroll agents if below cap for agent in target_set : if len ( ssp_agents ) < ssp_num_slots : agent . syringe_services . active = True # type: ignore[attr-defined] ssp_agents . add ( agent ) else : break logging . info ( f \"SSP has { ssp_num_slots } target slots with \" f \" { len ( ssp_agents ) } slots filled\" )","title":"Syringe Services"},{"location":"api/features/syringe_services/#titan.features.syringe_services.SyringeServices.name","text":"Name of feature in the params file. Also used to name the attribute in Agent","title":"name"},{"location":"api/features/syringe_services/#titan.features.syringe_services.SyringeServices.init_class","text":"Initialize enrolled risk to 0. Parameters: Name Type Description Default params the population params required Source code in titan/features/syringe_services.py @classmethod def init_class ( cls , params ): \"\"\" Initialize enrolled risk to 0. args: params: the population params \"\"\" cls . enrolled_risk = 0.0","title":"init_class()"},{"location":"api/features/syringe_services/#titan.features.syringe_services.SyringeServices.update_pop","text":"Update the feature for the entire population (class method). This is useful for initializing class level trackers that need to be reset each time step, or if enabling a feature for agents needs to be evaluated within the context of the full population (limited slots, or similar). Enroll PWID agents in syringe services according to the syring_services timeline and params. Parameters: Name Type Description Default model hiv_model.TITAN the instance of TITAN currently being run required Source code in titan/features/syringe_services.py @classmethod def update_pop ( cls , model : \"hiv_model.TITAN\" ): \"\"\" Update the feature for the entire population (class method). This is useful for initializing class level trackers that need to be reset each time step, or if enabling a feature for agents needs to be evaluated within the context of the full population (limited slots, or similar). Enroll PWID agents in syringe services according to the syring_services timeline and params. args: model: the instance of TITAN currently being run \"\"\" logging . info (( \" \\n\\n !!!!Engaging syringe services program\" )) ssp_num_slots = 0 ssp_agents = { agent for agent in model . pop . pwid_agents if agent . syringe_services . active # type: ignore[attr-defined] } for item in model . params . syringe_services . timeline . values (): if item . start_time <= model . time < item . stop_time : cls . enrolled_risk = item . risk # linearly interpolate slots between start and stop ssp_num_slots = ( item . num_slots_stop - item . num_slots_start ) / ( item . stop_time - item . start_time ) * ( model . time - item . start_time ) + item . num_slots_start # If cap indicates all or no agents, do not change # otherwise, find true number of slots through distribution num_pwid_agents = model . pop . pwid_agents . num_members () if 0 < ssp_num_slots < num_pwid_agents : ssp_num_slots = round ( model . run_random . betavariate ( ssp_num_slots , num_pwid_agents - ssp_num_slots , ) * num_pwid_agents ) break target_set = utils . safe_shuffle ( ( model . pop . pwid_agents . members - ssp_agents ), model . run_random ) # unenroll agents if above cap for agent in ssp_agents . copy (): if len ( ssp_agents ) > ssp_num_slots : agent . syringe_services . active = False # type: ignore[attr-defined] ssp_agents . remove ( agent ) else : break # enroll agents if below cap for agent in target_set : if len ( ssp_agents ) < ssp_num_slots : agent . syringe_services . active = True # type: ignore[attr-defined] ssp_agents . add ( agent ) else : break logging . info ( f \"SSP has { ssp_num_slots } target slots with \" f \" { len ( ssp_agents ) } slots filled\" )","title":"update_pop()"},{"location":"api/features/vaccine/","text":"name : str Name of feature in the params file. Also used to name the attribute in Agent stats : List [ str ] Vaccine collects the following stats: vaccine - number of agents with active vaccine get_acquisition_risk_multiplier ( self , time , interaction_type ) Get a multiplier for how vaccine affects acquisition of HIV for the given interaction_type. By default, returns 1.0 Parameters: Name Type Description Default time int the current model time step required interaction_type str The type of interaction where the agent could acquire HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) required Source code in titan/features/vaccine.py def get_acquisition_risk_multiplier ( self , time : int , interaction_type : str ): \"\"\" Get a multiplier for how vaccine affects acquisition of HIV for the given interaction_type. By default, returns 1.0 args: time: the current model time step interaction_type: The type of interaction where the agent could acquire HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) \"\"\" # not protected the time step the agent is vaccinaetd if self . active and self . time is not None and self . time < time : vaccine_time_months = ( ( time - self . time ) / self . agent . location . params . model . time . steps_per_year ) * 12 if self . type == \"HVTN702\" : return np . exp ( - 2.88 + 0.76 * ( np . log (( vaccine_time_months + 0.001 ) * 30 )) ) elif self . type == \"RV144\" : return np . exp ( - 2.40 + 0.76 * ( np . log ( vaccine_time_months ))) return 1.0 init_agent ( self , pop , time ) Initialize the agent for this feature during population initialization ( Population.create_agent ). Called on only features that are enabled per the params. If the agent is HIV-, randomly vaccinate per the params. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/features/vaccine.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this feature during population initialization (`Population.create_agent`). Called on only features that are enabled per the params. If the agent is HIV-, randomly vaccinate per the params. args: pop: the population this agent is a part of time: the current time step \"\"\" if ( not self . agent . hiv . active # type: ignore[attr-defined] and self . agent . location . params . vaccine . on_init and pop . pop_random . random () < self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . vaccine . init ): self . vaccinate ( time ) set_stats ( self , stats , time ) Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled feature in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/features/vaccine.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . active : stats [ \"vaccine\" ] += 1 update_agent ( self , model ) Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. If PrEP feature is enable and the agent is not active PrEP and not HIV, either update or stochastically vaccinate the agent. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/vaccine.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. If PrEP feature is enable and the agent is not active PrEP and not HIV, either update or stochastically vaccinate the agent. args: model: the instance of TITAN currently being run \"\"\" if ( not self . agent . prep . active # type: ignore[attr-defined] and not self . agent . hiv . active # type: ignore[attr-defined] ): vaccine_params = self . agent . location . params . vaccine agent_params = ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . vaccine ) if self . active : if ( vaccine_params . booster and ( model . time - self . time ) == agent_params . booster . interval and model . run_random . random () < agent_params . booster . prob ): self . vaccinate ( model . time ) elif model . time == vaccine_params . start_time : if model . run_random . random () < agent_params . prob : self . vaccinate ( model . time ) vaccinate ( self , time ) Vaccinate an agent and update relevant fields. Source code in titan/features/vaccine.py def vaccinate ( self , time ): \"\"\" Vaccinate an agent and update relevant fields. \"\"\" self . active = True self . type = self . agent . location . params . vaccine . type self . time = time","title":"Vaccine"},{"location":"api/features/vaccine/#titan.features.vaccine.Vaccine.name","text":"Name of feature in the params file. Also used to name the attribute in Agent","title":"name"},{"location":"api/features/vaccine/#titan.features.vaccine.Vaccine.stats","text":"Vaccine collects the following stats: vaccine - number of agents with active vaccine","title":"stats"},{"location":"api/features/vaccine/#titan.features.vaccine.Vaccine.get_acquisition_risk_multiplier","text":"Get a multiplier for how vaccine affects acquisition of HIV for the given interaction_type. By default, returns 1.0 Parameters: Name Type Description Default time int the current model time step required interaction_type str The type of interaction where the agent could acquire HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) required Source code in titan/features/vaccine.py def get_acquisition_risk_multiplier ( self , time : int , interaction_type : str ): \"\"\" Get a multiplier for how vaccine affects acquisition of HIV for the given interaction_type. By default, returns 1.0 args: time: the current model time step interaction_type: The type of interaction where the agent could acquire HIV (e.g. 'sex', 'injection' - from [params.classes.interaction_types]) \"\"\" # not protected the time step the agent is vaccinaetd if self . active and self . time is not None and self . time < time : vaccine_time_months = ( ( time - self . time ) / self . agent . location . params . model . time . steps_per_year ) * 12 if self . type == \"HVTN702\" : return np . exp ( - 2.88 + 0.76 * ( np . log (( vaccine_time_months + 0.001 ) * 30 )) ) elif self . type == \"RV144\" : return np . exp ( - 2.40 + 0.76 * ( np . log ( vaccine_time_months ))) return 1.0","title":"get_acquisition_risk_multiplier()"},{"location":"api/features/vaccine/#titan.features.vaccine.Vaccine.init_agent","text":"Initialize the agent for this feature during population initialization ( Population.create_agent ). Called on only features that are enabled per the params. If the agent is HIV-, randomly vaccinate per the params. Parameters: Name Type Description Default pop population.Population the population this agent is a part of required time int the current time step required Source code in titan/features/vaccine.py def init_agent ( self , pop : \"population.Population\" , time : int ): \"\"\" Initialize the agent for this feature during population initialization (`Population.create_agent`). Called on only features that are enabled per the params. If the agent is HIV-, randomly vaccinate per the params. args: pop: the population this agent is a part of time: the current time step \"\"\" if ( not self . agent . hiv . active # type: ignore[attr-defined] and self . agent . location . params . vaccine . on_init and pop . pop_random . random () < self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . vaccine . init ): self . vaccinate ( time )","title":"init_agent()"},{"location":"api/features/vaccine/#titan.features.vaccine.Vaccine.set_stats","text":"Update the stats dictionary passed for this agent. Called from output.get_stats for each enabled feature in the model. The stats to be updated must be declared in the class attribute stats to make sure the dictionary has the expected keys/counter value initialized. Parameters: Name Type Description Default stats Dict[str, int] the dictionary to update with this agent's feature statistics required time int the time step of the model when the stats are set required Source code in titan/features/vaccine.py def set_stats ( self , stats : Dict [ str , int ], time : int ): if self . active : stats [ \"vaccine\" ] += 1","title":"set_stats()"},{"location":"api/features/vaccine/#titan.features.vaccine.Vaccine.update_agent","text":"Update the agent for this feature for a time step. Called once per time step in TITAN.update_all_agents . Agent level updates are done after population level updates. Called on only features that are enabled per the params. If PrEP feature is enable and the agent is not active PrEP and not HIV, either update or stochastically vaccinate the agent. Parameters: Name Type Description Default model model.TITAN the instance of TITAN currently being run required Source code in titan/features/vaccine.py def update_agent ( self , model : \"model.TITAN\" ): \"\"\" Update the agent for this feature for a time step. Called once per time step in `TITAN.update_all_agents`. Agent level updates are done after population level updates. Called on only features that are enabled per the params. If PrEP feature is enable and the agent is not active PrEP and not HIV, either update or stochastically vaccinate the agent. args: model: the instance of TITAN currently being run \"\"\" if ( not self . agent . prep . active # type: ignore[attr-defined] and not self . agent . hiv . active # type: ignore[attr-defined] ): vaccine_params = self . agent . location . params . vaccine agent_params = ( self . agent . location . params . demographics [ self . agent . race ] . sex_type [ self . agent . sex_type ] . vaccine ) if self . active : if ( vaccine_params . booster and ( model . time - self . time ) == agent_params . booster . interval and model . run_random . random () < agent_params . booster . prob ): self . vaccinate ( model . time ) elif model . time == vaccine_params . start_time : if model . run_random . random () < agent_params . prob : self . vaccinate ( model . time )","title":"update_agent()"},{"location":"api/features/vaccine/#titan.features.vaccine.Vaccine.vaccinate","text":"Vaccinate an agent and update relevant fields. Source code in titan/features/vaccine.py def vaccinate ( self , time ): \"\"\" Vaccinate an agent and update relevant fields. \"\"\" self . active = True self . type = self . agent . location . params . vaccine . type self . time = time","title":"vaccinate()"},{"location":"api/interactions/","text":"Agent Interactions Interactions from params.classes.bond_types.acts_allowed are implemented in standalone files that implement the interface from interactions.BaseInteraction . This allows for the logic related to an interaction type to be consolidated into one place and make incorporating a new interaction type as simple as possible. To add a new interaction: Add the param to param.classes.bond_types.acts_allowed Add a file to interactions/ which creates a class that is a sub-class of BaseInteraction Implement the methods of BaseInteraction which are needed for this interaction Not all methods are needed for all interactions (see below for details on the methods) Re-export the feature from interactions/__init__.py Add tests in tests/interactions/ Add it to the docs in docs/api/interactions/ and to the nav in mkdocs.yml The TITAN class uses sub-classes of BaseInteraction to initialize the object/call methods as appropriate. BaseInteraction name : str Name of interaction in the params file. interact ( model , rel ) classmethod Given a model and a relation, have the agents in the relationship interact for a time step. Parameters: Name Type Description Default model model.TITAN The running model required rel agent.Relationship The relationship where interaction is happening required Source code in titan/interactions/base_interaction.py @classmethod def interact ( cls , model : \"model.TITAN\" , rel : \"agent.Relationship\" ): \"\"\" Given a model and a relation, have the agents in the relationship interact for a time step. args: model: The running model rel: The relationship where interaction is happening \"\"\" num_acts = cls . get_num_acts ( model , rel ) if num_acts < 1 : return for exposure in model . exposures : if model . time >= model . params [ exposure . name ] . start_time : exposure . expose ( model , cls . name , rel , num_acts )","title":"Overview"},{"location":"api/interactions/#agent-interactions","text":"Interactions from params.classes.bond_types.acts_allowed are implemented in standalone files that implement the interface from interactions.BaseInteraction . This allows for the logic related to an interaction type to be consolidated into one place and make incorporating a new interaction type as simple as possible. To add a new interaction: Add the param to param.classes.bond_types.acts_allowed Add a file to interactions/ which creates a class that is a sub-class of BaseInteraction Implement the methods of BaseInteraction which are needed for this interaction Not all methods are needed for all interactions (see below for details on the methods) Re-export the feature from interactions/__init__.py Add tests in tests/interactions/ Add it to the docs in docs/api/interactions/ and to the nav in mkdocs.yml The TITAN class uses sub-classes of BaseInteraction to initialize the object/call methods as appropriate.","title":"Agent Interactions"},{"location":"api/interactions/#titan.interactions.base_interaction.BaseInteraction","text":"","title":"BaseInteraction"},{"location":"api/interactions/#titan.interactions.base_interaction.BaseInteraction.name","text":"Name of interaction in the params file.","title":"name"},{"location":"api/interactions/#titan.interactions.base_interaction.BaseInteraction.interact","text":"Given a model and a relation, have the agents in the relationship interact for a time step. Parameters: Name Type Description Default model model.TITAN The running model required rel agent.Relationship The relationship where interaction is happening required Source code in titan/interactions/base_interaction.py @classmethod def interact ( cls , model : \"model.TITAN\" , rel : \"agent.Relationship\" ): \"\"\" Given a model and a relation, have the agents in the relationship interact for a time step. args: model: The running model rel: The relationship where interaction is happening \"\"\" num_acts = cls . get_num_acts ( model , rel ) if num_acts < 1 : return for exposure in model . exposures : if model . time >= model . params [ exposure . name ] . start_time : exposure . expose ( model , cls . name , rel , num_acts )","title":"interact()"},{"location":"api/interactions/injection/","text":"Injection name : str Name of interaction in the params file. get_num_acts ( model , rel ) classmethod Simulate random transmission of HIV between two PWID agents through injection. Parameters: Name Type Description Default model model.TITAN The currently running model required rel agent.Relationship The relationship in which the interaction is happening required Source code in titan/interactions/injection.py @classmethod def get_num_acts ( cls , model : \"model.TITAN\" , rel : \"agent.Relationship\" ) -> int : \"\"\" Simulate random transmission of HIV between two PWID agents through injection. args: model: The currently running model rel: The relationship in which the interaction is happening \"\"\" # make sure both agents have Inj drug type, should only be possible for # the relationship to have the injection interaction type if both agents PWID assert rel . agent1 . drug_type == \"Inj\" assert rel . agent2 . drug_type == \"Inj\" agent_params = ( rel . agent1 . location . params . demographics [ rel . agent1 . race ] . sex_type [ rel . agent1 . sex_type ] . injection ) partner_params = ( rel . agent2 . location . params . demographics [ rel . agent2 . race ] . sex_type [ rel . agent2 . sex_type ] . injection ) mean_num_acts = ( min ( agent_params . num_acts , partner_params . num_acts ) * model . calibration . injection . act ) share_acts = utils . poisson ( mean_num_acts , model . np_random ) if share_acts < 1 : return 0 if ( rel . agent1 . syringe_services . active or rel . agent2 . syringe_services . active # type: ignore[attr-defined] ): # syringe services program risk p_unsafe_injection = features . SyringeServices . enrolled_risk else : p_unsafe_injection = agent_params . unsafe_prob # diagnosis risk reduction if rel . agent1 . hiv . dx or rel . agent1 . hiv . dx : # type: ignore[attr-defined] p_unsafe_injection *= 1 - model . params . hiv . dx . risk_reduction . injection for n in range ( share_acts ): if model . run_random . random () > p_unsafe_injection : share_acts -= 1 return share_acts","title":"Injection"},{"location":"api/interactions/injection/#titan.interactions.injection.Injection","text":"","title":"Injection"},{"location":"api/interactions/injection/#titan.interactions.injection.Injection.name","text":"Name of interaction in the params file.","title":"name"},{"location":"api/interactions/injection/#titan.interactions.injection.Injection.get_num_acts","text":"Simulate random transmission of HIV between two PWID agents through injection. Parameters: Name Type Description Default model model.TITAN The currently running model required rel agent.Relationship The relationship in which the interaction is happening required Source code in titan/interactions/injection.py @classmethod def get_num_acts ( cls , model : \"model.TITAN\" , rel : \"agent.Relationship\" ) -> int : \"\"\" Simulate random transmission of HIV between two PWID agents through injection. args: model: The currently running model rel: The relationship in which the interaction is happening \"\"\" # make sure both agents have Inj drug type, should only be possible for # the relationship to have the injection interaction type if both agents PWID assert rel . agent1 . drug_type == \"Inj\" assert rel . agent2 . drug_type == \"Inj\" agent_params = ( rel . agent1 . location . params . demographics [ rel . agent1 . race ] . sex_type [ rel . agent1 . sex_type ] . injection ) partner_params = ( rel . agent2 . location . params . demographics [ rel . agent2 . race ] . sex_type [ rel . agent2 . sex_type ] . injection ) mean_num_acts = ( min ( agent_params . num_acts , partner_params . num_acts ) * model . calibration . injection . act ) share_acts = utils . poisson ( mean_num_acts , model . np_random ) if share_acts < 1 : return 0 if ( rel . agent1 . syringe_services . active or rel . agent2 . syringe_services . active # type: ignore[attr-defined] ): # syringe services program risk p_unsafe_injection = features . SyringeServices . enrolled_risk else : p_unsafe_injection = agent_params . unsafe_prob # diagnosis risk reduction if rel . agent1 . hiv . dx or rel . agent1 . hiv . dx : # type: ignore[attr-defined] p_unsafe_injection *= 1 - model . params . hiv . dx . risk_reduction . injection for n in range ( share_acts ): if model . run_random . random () > p_unsafe_injection : share_acts -= 1 return share_acts","title":"get_num_acts()"},{"location":"api/interactions/pca/","text":"PCA name : str Name of interaction in the params file.","title":"Peer Change Agent"},{"location":"api/interactions/pca/#titan.interactions.pca.PCA","text":"","title":"PCA"},{"location":"api/interactions/pca/#titan.interactions.pca.PCA.name","text":"Name of interaction in the params file.","title":"name"},{"location":"api/interactions/sex/","text":"Sex name : str Name of interaction in the params file. get_num_acts ( model , rel ) classmethod Simulate random transmission of HIV between two agents through Sex. One of the agents must be HIV+. Parameters: Name Type Description Default model model.TITAN The model being run required rel agent.Relationship Relationship required Source code in titan/interactions/sex.py @classmethod def get_num_acts ( cls , model : \"model.TITAN\" , rel : \"agent.Relationship\" ) -> int : \"\"\" Simulate random transmission of HIV between two agents through Sex. One of the agents must be HIV+. args: model: The model being run rel : Relationship \"\"\" # unprotected sex probabilities for primary partnerships mean_sex_acts = ( rel . get_number_of_sex_acts ( model . np_random ) * model . calibration . sex . act ) total_sex_acts = utils . poisson ( mean_sex_acts , model . np_random ) # Get condom usage p_safe_sex = ( rel . agent1 . location . params . demographics [ rel . agent1 . race ] . sex_type [ rel . agent1 . sex_type ] . safe_sex [ rel . bond_type ] . prob ) # increase condom usage if diagnosed if rel . agent1 . hiv . dx or rel . agent2 . hiv . dx : # type: ignore[attr-defined] # Calculate probability of safe sex given risk reduction p_unsafe_sex = ( 1 - p_safe_sex ) * ( 1 - model . params . hiv . dx . risk_reduction . sex ) p_safe_sex = 1 - p_unsafe_sex # Reduction of risk acts between partners for condom usage unsafe_sex_acts = total_sex_acts for n in range ( unsafe_sex_acts ): if model . run_random . random () < p_safe_sex : unsafe_sex_acts -= 1 return unsafe_sex_acts","title":"Sex"},{"location":"api/interactions/sex/#titan.interactions.sex.Sex","text":"","title":"Sex"},{"location":"api/interactions/sex/#titan.interactions.sex.Sex.name","text":"Name of interaction in the params file.","title":"name"},{"location":"api/interactions/sex/#titan.interactions.sex.Sex.get_num_acts","text":"Simulate random transmission of HIV between two agents through Sex. One of the agents must be HIV+. Parameters: Name Type Description Default model model.TITAN The model being run required rel agent.Relationship Relationship required Source code in titan/interactions/sex.py @classmethod def get_num_acts ( cls , model : \"model.TITAN\" , rel : \"agent.Relationship\" ) -> int : \"\"\" Simulate random transmission of HIV between two agents through Sex. One of the agents must be HIV+. args: model: The model being run rel : Relationship \"\"\" # unprotected sex probabilities for primary partnerships mean_sex_acts = ( rel . get_number_of_sex_acts ( model . np_random ) * model . calibration . sex . act ) total_sex_acts = utils . poisson ( mean_sex_acts , model . np_random ) # Get condom usage p_safe_sex = ( rel . agent1 . location . params . demographics [ rel . agent1 . race ] . sex_type [ rel . agent1 . sex_type ] . safe_sex [ rel . bond_type ] . prob ) # increase condom usage if diagnosed if rel . agent1 . hiv . dx or rel . agent2 . hiv . dx : # type: ignore[attr-defined] # Calculate probability of safe sex given risk reduction p_unsafe_sex = ( 1 - p_safe_sex ) * ( 1 - model . params . hiv . dx . risk_reduction . sex ) p_safe_sex = 1 - p_unsafe_sex # Reduction of risk acts between partners for condom usage unsafe_sex_acts = total_sex_acts for n in range ( unsafe_sex_acts ): if model . run_random . random () < p_safe_sex : unsafe_sex_acts -= 1 return unsafe_sex_acts","title":"get_num_acts()"}]}